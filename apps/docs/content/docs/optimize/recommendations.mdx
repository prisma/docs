---
title: Recommendations
description: Comprehensive guide to Prisma Optimize recommendations for improving database performance
url: /docs/optimize/recommendations
metaTitle: 'Optimize: Recommendations'
metaDescription: Learn about using Optimize's recommendations.
---

Prisma Optimize provides actionable recommendations to help you identify and resolve performance issues in your database. These recommendations cover indexing strategies, query patterns, data type choices, and storage optimization.

:::info
Use [Prisma AI](/docs/optimize/prisma-ai) to ask follow-up questions about any recommendation.
:::

## Indexing recommendations

### Queries on unindexed columns

**Problem:** Queries that filter on columns without indexes may require full table scans, significantly impacting performance.

**Example:**

```ts
await prisma.user.findFirst({
  where: { name: "Marc" },
});
```

**Impact:**

- **User experience:** Longer wait times for large datasets
- **Resource utilization:** Higher CPU usage, memory consumption, and disk I/O

**Understanding indexes:**

An index allows the database to retrieve data quickly, similar to how a book's index helps locate information without reading every page. Indexes create a data structure storing column values with pointers to corresponding rows.

**When to use indexes:**

- Large datasets with frequent filtering or sorting operations
- Foreign key columns for faster relation lookups
- Columns frequently used in `where` clauses

**When NOT to use indexes:**

- Small tables (overhead outweighs benefits)
- Write-heavy tables (slows down `create`, `update`, `delete`)
- Columns with large data or rarely used for filtering

:::warning
Even with an index, the database query optimizer may choose a different execution plan if it estimates better performance.
:::

---

### Indexing on unique columns

**Problem:** Adding explicit indexes to columns with unique constraints creates redundancy.

**Why this matters:**

Unique constraints automatically generate an underlying index to enforce uniqueness. Adding another index:

- Increases write overhead
- Slows down updates
- Wastes storage space

**Solution:** Remove redundant indexes on uniquely constrained columns.

---

### Unnecessary indexes

**Problem:** Unused or redundant indexes waste resources and can confuse the query optimizer.

**Impact:**

- Increased write costs (every `INSERT`, `UPDATE`, `DELETE` must update indexes)
- Higher storage usage
- Potential for suboptimal query plans

**Solution:** Regularly audit and remove indexes that aren't improving query performance.

---

## Query pattern recommendations

### Full table scans from LIKE operations

**Problem:** Using `contains` or `endsWith` in Prisma (translating to `LIKE`/`ILIKE`) can cause full table scans.

**Example:**

```ts
await prisma.user.findMany({
  where: {
    email: { contains: "gmail.com" },
    name: { endsWith: "Burk" },
  },
});
```

**Impact:**

- Slower load times
- Increased CPU, memory, and disk I/O
- Higher costs in serverless pricing models

**Solution:** Consider using full-text search indexes for text pattern matching on larger datasets.

---

### Excessive rows returned

**Problem:** Queries without `take` limits return all matching rows, overwhelming users and systems.

**Example:**

```ts
await prisma.user.findMany({
  where: { email: "jane@example.com" },
});
```

**Impact:**

- **User experience:** Slow page loads, browser freezes
- **Resources:** Excessive memory usage, unnecessary data transfer

**Solution:** Always specify a `take` limit for queries that return multiple rows:

```ts
await prisma.user.findMany({
  where: { email: "jane@example.com" },
  take: 20,
});
```

---

### Overfetching data

**Problem:** Retrieving all columns or unnecessary relations wastes bandwidth and processing power.

**Example:**

```ts
await prisma.user.findMany({
  where: { email: { contains: "gmail" } },
  include: { links: true }, // May not be needed
});
```

**Impact:**

- Increased load times
- Greater resource consumption
- Higher processing costs
- Potential security risks from exposing sensitive data

**Solution:** Use `select` to fetch only required fields:

```ts
await prisma.user.findMany({
  where: { email: { contains: "gmail" } },
  select: { id: true, name: true, email: true },
});
```

---

### Repeated queries

**Problem:** Executing identical queries multiple times within a short timeframe wastes resources.

**Example:**

```ts
// Executed multiple times with same parameters
await prisma.post.findMany({
  where: { published: true },
  take: 20,
});
```

**Impact:**

- Repeated connection overhead
- Unnecessary CPU/memory/disk usage
- Higher costs in serverless environments

**Solution:** Implement caching or fetch data once and reuse it.

---

### Long-running transactions

**Problem:** Transactions that hold locks and connections for extended periods harm scalability and resilience.

**Example:**

```ts
await prisma.$transaction(async (prisma) => {
  const order = await prisma.order.create({
    data: {
      /* ... */
    },
  });
  await prisma.user.update({
    where: { id: userId },
    data: { balance: { decrement: order.total } },
  });
  await prisma.shipping.create({ data: { orderId: order.id } });
  // More operations...
});
```

**Impact:**

- Database locks blocking concurrent operations
- Connection pool exhaustion
- Increased contention and reduced throughput
- Fragility (full rollback on any failure)
- Difficult debugging

**Solution:**

- Break large transactions into smaller, independent units
- Use optimistic concurrency control where possible
- Consider event-driven architectures for complex workflows

---

## Data type recommendations

### Avoid `@db.Char(n)`

**Problem:** Fixed-length `CHAR(n)` types pad shorter values with spaces, causing comparison issues.

**Example:**

```prisma
model Item {
  name String @db.Char(10)
}
```

**Why it's problematic:**

PostgreSQL doesn't optimize `CHAR(n)` like some databases. Space padding can cause unexpected behavior in comparisons and string operations.

**Solution:** Use `TEXT` or `VARCHAR` instead:

```prisma
model Item {
  name String // Defaults to TEXT in PostgreSQL
}
```

---

### Avoid `@db.VarChar(n)`

**Problem:** In PostgreSQL, `VARCHAR(n)` performs identically to `TEXT` without any optimizations.

**Example:**

```prisma
model Item {
  name String @db.VarChar(255)
}
```

**Solution:** Use `TEXT` unless you specifically need length constraints:

```prisma
model Item {
  name String // TEXT type
}
```

---

### Avoid `@db.Money`

**Problem:** The `MONEY` type lacks flexibility and doesn't store currency information.

**Example:**

```prisma
model Item {
  price Decimal @db.Money
}
```

**Issues:**

- Implemented as integer internally (limited precision)
- Unexpected rounding behavior
- Relies on global `lc_monetary` locale setting
- No currency information stored

**Solution:** Use `DECIMAL` or `NUMERIC` for monetary values:

```prisma
model Item {
  price Decimal @db.Decimal(10, 2)
}
```

---

### Avoid `timestamp(0)` and `timestamptz(0)`

**Problem:** Zero precision rounds times to nearest second, potentially showing future times.

**Example:**

```prisma
model User {
  createdAt DateTime @db.Timestamp(0)
  deletedAt DateTime @db.Timestamptz(0)
}
```

**Issue:**

Inserting `15:30:45.678` rounds to `15:30:46`, appearing half a second in the future.

**Solution:** Use higher precision or default precision:

```prisma
model User {
  createdAt DateTime // Default precision
}
```

---

### Avoid `CURRENT_TIME`

**Problem:** Returns only time without date, unsuitable for timestamps or event logging.

**Example:**

```ts
prisma.$queryRaw`SELECT CURRENT_TIME;`;
```

**Issue:**

Returns `timetz` type (time with timezone) without date context, making it useless for precise event tracking.

**Solution:** Use `CURRENT_TIMESTAMP` or `NOW()` instead:

```ts
prisma.$queryRaw`SELECT CURRENT_TIMESTAMP;`;
```

---

## Storage recommendations

### Storing BLOBs in database

**Problem:** Storing large binary objects (images, files) directly in the database causes performance and scalability issues.

**Example:**

```prisma
model User {
  id Int @id @default(autoincrement())
  name String
  avatarBytes Bytes? // Storing image data directly
}
```

**Impact:**

- Excessive storage usage
- Increased I/O load
- Slower query performance
- Bloated backups
- Performance bottlenecks under high traffic

**Solution:** Store BLOBs in object storage (S3, Cloudflare R2, etc.) and save references in the database:

```prisma
model User {
  id Int @id @default(autoincrement())
  name String
  avatarUrl String? // URL to external storage
}
```

---

## Next steps

- [Set up Optimize](/docs/optimize/getting-started) to start receiving recommendations
- [Review query recordings](/docs/optimize/recordings) to understand your application's query patterns
- [Use Prisma AI](/docs/optimize/prisma-ai) to get personalized optimization suggestions
