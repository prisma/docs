---
title: "How Prisma and GraphQL fit together"
slug: "prisma-and-graphql-mfl5y2r7t49c"
date: "2019-03-19"
authors:
  - "Nikolas Burk"
  - "Tim Suchanek"
metaTitle: "How Prisma and GraphQL fit together | Prisma"
metaImagePath: "/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/meta-fa8e2859efa37829166cc290e4913124ad4a99a0-1200x630.png"
heroImagePath: "/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/hero-a170d7e275c2b415bc159d86a7a0eacf7b92acef-870x457.png"
heroImageAlt: "How Prisma and GraphQL fit together"
excerpt: |
  There are many confusions around the relationship Prisma has with GraphQL. In this article, we clarify how developers
    should think about GraphQL and Prisma and provide a glimpse into Prisma's future.

---

## TLDR: GraphQL is one of many use cases for Prisma

We love GraphQL and strongly believe in its bright future! We will keep investing into the GraphQL ecosystem and strive to make Prisma the best tool for building database-backed GraphQL servers. One example of our efforts is the upcoming [Yoga2](https://github.com/prisma/yoga2) framework which will enable a [_Ruby-on-Rails_-like experience](https://rubyonrails.org/doctrine) for GraphQL.

Prisma is an ORM replacement that has many more use cases beyond GraphQL, such as building [REST](https://github.com/prisma/prisma-examples/tree/master/typescript/rest-express) or [gRPC](https://github.com/prisma/prisma-examples/tree/master/typescript/grpc) APIs. **Prisma's goal is to simplify database workflows.** Think of it as a suite of database tools to ease _database access_, _migrations_ and _data management_.

---

## History: From GraphQL to ORMs & databases

Let's start with a short history lesson and revisit how Prisma evolved to what it is today.

![GraphQL to ORMs](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/ykahwzh.png)

### 1) Graphcool: Making GraphQL easy for frontend developers

Before the launch of Prisma and the [official rebranding](https://www.prisma.io/blog/prisma-raises-4-5m-to-build-the-graphql-data-layer-for-all-databases-663484df0f60), our core product used to be Graphcool (an open-source GraphQL BaaS). From the very beginning, the goal of Graphcool was to make it as easy as possible for developers to use GraphQL.

The architecture was simple since Graphcool represented the entire backend stack. It included the database, application layer and GraphQL API:

![Graphcool is the entire backend: Database, application layer and GraphQL API](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/Felin65.png)

After running Graphcool in production for two years, we've noticed the following recurring customer feedback and requests:

- Graphcool was _loved_ for its ease-of-use. Developers used it for prototyping but then often dropped it in production in favor of building their own GraphQL servers.
- Developers wanted more control and flexibility in their backend stack, for example:
  - Decoupling the database from the API layer
  - Defining their own domain-driven GraphQL schemas (instead of generic CRUD)
  - Flexibility in choosing programming languages, frameworks, testing & CI/CD tools

### 2) Prisma bindings: Build a GraphQL server with any database

It was clear that the requirements developers have for building sophisticated GraphQL backends weren't met by a tool like Graphcool. This realization led us to Prisma. The first version of Prisma was a standalone version of Graphcool's _query engine_ component.

By making Prisma available as a standalone component, we gave developers the opportunity to quickly generate a CRUD GraphQL API for their database. This API was not to be consumed from the frontend. Instead, the idea was to build an additional application layer on top of it to add business logic and customize the client-facing API.

This application layer was implemented using _Prisma bindings_. The mental model required developers to understand that they were dealing with two GraphQL APIs (a custom client-facing API on top of a generated CRUD API):

![When working with Prisma bindings, developers need to understand the concept of two GraphQL APIs](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/NS0YFih.png)

While the primary goal of Prisma still was to make it as easy as possible for developers to use GraphQL, the focus had shifted to becoming a _data access layer_ that connects your GraphQL resolvers with a database.

### 3) Prisma client: Replacing traditional ORMs

After talking to lots of customers and the Prisma community, our understanding of what Prisma was (and could eventually become) had again evolved quite a bit.

The prior approach of building GraphQL servers with Prisma bindings had a few issues:

- While Prisma bindings made it easy to get started, the complexity of the concepts developers needed to understand in more advanced use cases went through the roof (due to the intricacies of [schema delegation](https://www.prisma.io/blog/graphql-schema-stitching-explained-schema-delegation-4c6caf468405) and the [`info`](https://www.prisma.io/blog/graphql-server-basics-demystifying-the-info-argument-in-graphql-resolvers-6f26249f613a) object).
- Very difficult and impractical to achieve fully type-safe resolvers.
- Limited to the JavaScript ecosystem.
- Limited to GraphQL as a use case.

The [Prisma client](https://www.prisma.io/blog/prisma-client-preview-ahph4o1umail) solves these issues. It is an auto-generated database client with a simple and fully type-safe data access API.

With this new approach, the generated CRUD GraphQL API is not part of the core Prisma development workflows any more. It rather becomes an _implementation detail_:

![Simplified mental model: Developers only need to understand the Prisma client API](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/I9D33PU.png)

Note that very soon there will be a version of Prisma that can be used right inside your application server, omitting the need for the extra Prisma server:

![The upcoming Prisma 2 will enable running Prisma without an extra server](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/wDONhZ6.png)

While we believe that the Prisma client API today already is one of the best data access APIs out there, a lot of community feedback helped us improving it even further. The result is an extremely powerful and intuitive database API that we'll release soon.

Because the Prisma client has a built-in [dataloader](https://github.com/facebook/dataloader), it's the perfect tool to implement the resolvers in a GraphQL server.

---

## How to think about Prisma's generated GraphQL API

Understanding that the generated Prisma GraphQL CRUD API is considered an implementation detail is crucial to comprehend Prisma's focus and future direction.

### From a declarative datamodel to generated GraphQL CRUD

The core idea of Prisma was always the same:

1. Developers define their datamodel in GraphQL SDL and map it to their database
1. Prisma generates a powerful CRUD GraphQL API based on the datamodel
1. The generated CRUD GraphQL API is used as foundation for the application layer and the client-facing API (_except with Graphcool_)

While the generated CRUD GraphQL API was absoutely essential with Prisma bindings, it has become an implementation detail with the Prisma client.

This is also reflected in the latest redesign of the [Prisma website](https://www.prisma.io), where the Prisma client has replaced GraphQL as the dominant theme:

![New Prisma website](/blog/prisma-and-graphql-mfl5y2r7t49c/imgs/Cyyt5un.png)

### De-emphasizing Prisma's CRUD GraphQL API

Today, developers shouldn't care about _how_ the Prisma client talks to the underlying database. **What developers should care about is the Prisma client API!**

To reflect this in our official documentation, we have removed the Prisma GraphQL API docs in the last Prisma release. If you still need the documentation, you can access it by navigating to [older Prisma versions in the docs](https://v1.prisma.io/docs/1.27/prisma-graphql-api).

We also just introduced Prisma Admin as an additional tool to interact with the data in your Prisma project (in addition to the GraphQL Playground).

### Data modelling in GraphQL SDL

Another common source of confusion in regards to Prisma and GraphQL can be data modelling. When using Prisma, the datamodel is specified using a subset of GraphQL's schema definition language (SDL).

While we've already adjusted the file type of the datamodel from `.graphql` to `.prisma`, using SDL for data modelling is still a strong tie to GraphQL. However, we are currently working on our own model language (which will be a modified version of SDL).

### Comparing Prisma to AWS AppSync & Hasura

With the new understanding of the role of Prisma's CRUD GraphQL API, it becomes clear that Prisma is not in the category of "GraphQL-as-a-Service" anymore.

Tools like [AWS AppSync](https://aws.amazon.com/appsync/) and [Hasura](https://hasura.io/) provision a generated GraphQL API for your database (or in the case of AppSync also other data sources). In contrast, Prisma enables simplified and type-safe database access in various languages.

---

## GraphQL is an important use case for Prisma

Since the Prisma client was released, it's considered an implementation detail that Prisma uses GraphQL under the hood. So what role does GraphQL then play for Prisma?

### We love GraphQL

The answer is clear to us: We still see GraphQL as one of the most important upcoming API technologies and want to make it as easy as possible for developers to build GraphQL servers. GraphQL remains to be an important Prisma use case for Prisma!

### Investing into the GraphQL ecosystem

We will keep investing in the open-source GraphQL ecosystem. Many of the tools we've built have become the default in many GraphQL development workflows, such as the [GraphQL Playground](https://github.com/prisma/graphql-playground), [`graphql-yoga`](https://github.com/prisma/graphql-yoga) and [GraphQL Nexus](https://github.com/prisma/nexus) (built by [Tim Griesser](https://twitter.com/tgriesser)).

The [recently announced](https://www.prisma.io/blog/using-graphql-nexus-with-a-database-pmyl3660ncst) `nexus-prisma` makes it incredibly easy to implement a GraphQL server on top of Prisma. With the upcoming [Yoga2](https://www.youtube.com/watch?v=3eoxXwllmpk) framework, we further aim to create a Ruby-on-Rails developer experience for GraphQL.

### Contributing to the GraphQL community

Similar to how we invest into the GraphQL ecosystem, we want to contribute to the GraphQL community. We're running the world's largest [GraphQL community conference](https://graphqlconf.org) and maintain popular resources like [How to GraphQL](https://howtographql.com) and [GraphQL Weekly](https://www.graphqlweekly.com).

> While we weren't among the first companies to join, we're certainly also planning to become part of the [**GraphQL Foundation**](https://gql.foundation/) and help steer the future direction of it.

---

## ðŸ”® A glimpse into the future

As highlighted throughout this post, we are working on many exciting and fundamental improvements to Prisma. To get an overview of what we are working on, feel free to check out our [roadmap](https://pris.ly/roadmap).

We are speccing all upcoming features in public (via GitHub issues and an [RFC](https://github.com/prisma/specs) process), so please join the discussion on [GitHub](https://github.com/prisma) and share your opinions with us!

**If you have any questions or comments, [please share them on Spectrum](https://spectrum.chat/prisma/general/how-prisma-and-graphql-fit-together~8c05c8f2-84c7-4ced-8f16-74d9798c71fa).**

> [**We are hiring!**](https://www.prisma.io/careers) As you will find, one item on the roadmap is a full rewrite of the Prisma core in Rust. If you are a Rust engineer or just generally interested in highly technical challenges and open-source development, definitely check out our [jobs page](https://www.prisma.io/careers).

