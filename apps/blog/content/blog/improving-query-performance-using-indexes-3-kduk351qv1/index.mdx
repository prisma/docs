---
title: "Improving Query Performance with Indexes using Prisma: Hash Indexes"
slug: "improving-query-performance-using-indexes-3-kduk351qv1"
date: "2022-10-12"
authors:
  - "Alex Ruheni"
metaTitle: "Improving query performance with database indexes using Prisma: Hash indexes"
metaDescription: "Learn how you can optimize a slow database query in your application with a Hash index using Prisma"
metaImagePath: "/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/meta-a2babe32fc26290c3dee9a6d0cb09decc68fae6a-1269x714.png"
heroImagePath: "/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/hero-f7add11b063d3376bf02a64092431ac5397e82ba-844x474.svg"
heroImageAlt: "Improving Query Performance with Indexes using Prisma: Hash Indexes"
series:
  title: "Improving query performance with indexes using Prisma"
  slug: "improving-query-performance-using-indexes-2gozGfdxjevI"
seriesIndex: 3
excerpt: |
  One strategy for improving performance for your database queries is using indexes. This article will dive into hash indexes: taking a look at the data structure used and improve the performance of an existing query with an index using Prisma.

---

## Overview
- [Introduction](#introduction)
- [Hash tables: the data structure that powers hash indexes](#hash-tables-the-data-structure-that-powers-hash-indexes)
- [When to use a hash index](#when-to-use-a-hash-index)
- [Working with hash indexes using Prisma](#working-with-hash-indexes-using-prisma)
    - [Assumed knowledge](#assumed-knowledge)
    - [Development environment](#development-environment)
  - [Clone the repository and install dependencies](#clone-the-repository-and-install-dependencies)
  - [Project walkthrough](#project-walkthrough)
  - [Create and seed the database](#create-and-seed-the-database)
  - [Make an API request](#make-an-api-request)
  - [Improve query performance with a hash index](#improve-query-performance-with-a-hash-index)
- [Summary and next steps](#summary-and-next-steps)
## Introduction 

In this part of the series, you will learn what hash indexes are, how they work, and when to use them, and then dive into a concrete example of how you can improve the performance of a query with a hash index using Prisma.

If you want to learn more about the fundamentals of database indexes, check out the [first part](/improving-query-performance-using-indexes-1-zuLNZwBkuL).

## Hash tables: the data structure that powers hash indexes

Hash indexes use the [hash table](https://en.wikipedia.org/wiki/Hash_table) data structure. Hash tables (also known as hash maps) are great data structures that allow fast data retrieval in almost _constant_ time (`O(1)`). This means the retrieval time of a record won't be affected by the size of the data being searched.

> If you're unfamiliar with the concept of Big O notation, take a look at [What is Big O notation](https://jarednielsen.com/big-o-notation/).

PostgreSQL's hash index is composed of "buckets" or "slots" into which [tuples](https://en.wikipedia.org/wiki/Tuple) are placed.


![](/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/194055764-a7c4adfd-b649-4597-af10-1676b0159272.png)

PostgreSQL uses a _hash function_ to compute a _hash key_ or _hash code_ when storing a value to the index:
- Hash key: maps the value to a 32-bit integer. 
- Hash code: maps to a bucket number in which the value will be stored. 

> **Hash function**: a function that maps data of arbitrary size to fixed-size values.
>
> **Hash code/ key**: the output of a hash function.

When retrieving a record using a hash index, the database applies the hash function to the value to determine the bucket that might contain the value. After determining the bucket, the database will search through the tuple to find the records that match your query.

![](/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/194057994-bdf3aeca-85f8-4b06-801a-63bac39621be.png)
If you're interested in reading about PostgreSQL's implementation of the hash index, you can read further [here](https://github.com/postgres/postgres/blob/master/src/backend/access/hash/README).


## When to use a hash index

Hash indexes would be a solid choice if you only intend to use the equality operator (`=`) to query your data. For example, in the query in the example below, a hash index would be suitable.
```sql
SELECT firstName from 'User' where lastName = 'Wick';
```
If you intend to use range operators (`<`, `<=`,`>`, `>=`) when filtering your data, you can use a B-Tree index. You can refer to [part 2](/improving-query-performance-using-indexes-2-MyoiJNMFTsfq) to learn more about B-tree indexes.

Hash indexes only work with the equality (`=`) operator. This means that a hash index would be a solid choice if you're using the `=` operator when querying your data.

While a hash index might be a good choice for speeding up your queries, it comes with some caveats. Some of the limitations are that they:
- Cannot be used to index multiple columns
- Cannot be used to create sorted indexes
- Cannot be used to enforce unique constraints

## Working with hash indexes using Prisma

#### Assumed knowledge
To follow along, the following knowledge will be assumed:
- Some familiarity with JavaScript/TypeScript
- Some experience working with REST APIs
- A basic understanding of working with Git

#### Development environment

You will also be expected to have the following tools set up in your development environment:
- [Node.js](https://nodejs.org/)
- [Git](https://git-scm.com/downloads)
- [Docker](https://www.docker.com/) or [PostgresQL](https://www.postgresql.org/download/)
- [Prisma VS Code extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) _(optional)_: intellisense and syntax highlighting for Prisma
- [REST Client VS Code extension](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) _(optional)_: sending HTTP requests on VS Code

> **Note**: If you don't have Docker or PostgreSQL installed, you can set up a free database on [Railway](http://railway.app/).


### Clone the repository and install dependencies

Navigate to your directory of choice and clone the repository:

```shell
git clone -b hash-indexes git@github.com:ruheni/prisma-indexes.git
```
Change the directory to the cloned repository and install dependencies: 

```shell
cd prisma-indexes
npm install
```
Next, rename the `.env.example` file to `.env`.



```shell
mv .env.example .env
```
```cmd
ren .env.example .env
```


### Project walkthrough

The sample project is a minimal REST API built with TypeScript and [Fastify](https://www.fastify.io/).

The project contains the following file structure:
```
prisma-indexes
  â”œâ”€â”€ .github/workflows
  â”‚   â”‚   â””â”€â”€ test.yaml
  â”‚   â””â”€â”€ renovate.json
  â”œâ”€â”€ node_modules
  â”œâ”€â”€ prisma
  â”‚   â”œâ”€â”€ migrations/
  â”‚   â”œâ”€â”€ schema.prisma
  â”‚   â””â”€â”€ seed.ts
  â”œâ”€â”€ src
  â”‚   â””â”€â”€ index.ts
  â”œâ”€â”€ README.md
  â”œâ”€â”€ .env
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ docker-compose.yml
  â”œâ”€â”€ package-lock.json
  â”œâ”€â”€ package.json
  â”œâ”€â”€ requests.http
  â””â”€â”€ tsconfig.json
```
The notable files and directories for this project are:

- The `prisma` folder contains:
  - The `schema.prisma` file that defines the database schema
  - The `migrations` directory that contains the database migrations history
  - The `seed.ts` file that contains a script to seed your development database
- The `src` directory:
  - The `index.ts` file defines a REST API using Fastify. It contains one endpoint called `/users` and accepts one optional query parameter â€” `firstName`
- The `docker-compose.yml` file defining the PostgreSQL database docker image
- The `.env` file containing your database connection string

The application contains a single model in the Prisma schema called `User` with the following fields:

```prisma
// prisma/schema.prisma
model User {
  id        Int    @id @default(autoincrement())
  firstName String
  lastName  String
  email     String
}
```
The `src/index.ts` file contains _primitive_ [logging middleware](https://www.prisma.io/docs/concepts/components/prisma-client/middleware/logging-middleware) to measure the time taken by a Prisma query:

```typescript
// src/index.ts
prisma.$use(async (params, next) => {
  const before = Date.now()
  const result = await next(params)
  const after = Date.now()

  logger.info(`Query took ${after - before}ms`)
  return result
})
```
You can use the logged data to determine which Prisma queries are slow. You can use the logs to gauge queries that could require some performance improvements.

`src/index.ts` also logs Prisma `query` events and parameters to the terminal. The `query` event and parameters contains the SQL query and parameters that Prisma executes against your database.
```typescript
const prisma = new PrismaClient({
  log: [{ emit: "event", level: "query", },],
})

prisma.$on("query", async (e) => {
  logger.info(`Query: ${e.query}`)
  logger.info(`Params: ${e.params}`)
});
```
The SQL queries (with filled-in parameters) can be copied and prefixed with `EXPLAIN` to view the query plan the database will provide.

### Create and seed the database

Start up the PostgreSQL database with docker:

```shell
docker-compose up -d
```
Next, apply the existing database migration in `prisma/migrations`:

```shell
npx prisma migrate dev
```
The above command will:

1. Create a new database called `users-db` (inferred from the connection string defined in the `.env` file)
1. Create a `User` table as defined by the model in `prisma/schema.prisma`.
1. Trigger the seeding script defined in `package.json`. The seeding step is triggered because it's run against a new database.

The seed file in `prisma/seed.ts` will populate the database with a million user records.

Start up the application server:

```shell
npm run dev
```
### Make an API request

The cloned repository contains a `requests.http` file that contains sample requests to `http://localhost:3000/users` that can be used by the installed REST Client VS Code extension. The requests contain different `firstName` query parameters.

> **Note**: Ensure you've installed the [REST Client VS Code extension](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) for this step. You can also use other API testing tools such as [Postman](https://www.postman.com/), [Insomnia](https://www.insomnia.rest/), or your preferred tool of choice.
```
Click the **Send Request** button right above the request to make the request. 

![](/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/184096935-1a680505-14fc-47ef-8862-126ef0d15708.png)

VS Code will open an editor tab on the right side of the window with the responses. You should also see some information logged on the terminal.

![](/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/194079327-6dab2f11-a528-45f6-99f9-13db3a84cb0d.png)

In the screenshot above, the query took 55 ms.
### Improve query performance with a hash index

You can define a hash index in your Prisma schema file using the `@@index()` attribute function and providing the following arguments:
- `fields`: a list of fields to be indexed
- `type`: the name of the index created in the database

The `@@index` attribute supports more arguments you can learn more about in the [Prisma Schema API Reference](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#index).

Next, specify the `firstName` in the `fields` argument and `Hash` as the value of the `type` argument.
```prisma
diff
model User {
  id        Int    @id @default(autoincrement())
  firstName String
  lastName  String
  email     String

+  @@index(fields: [firstName], type: Hash)
}
```
After making the change, create and run another migration to create the index on the `firstName` field in the `User` model:

```shell
npx prisma migrate dev --name add-firstName-index
```
<Accordions type="single">
  <Accordion title="Generated SQL migration">
```sql
--- prisma/migrations/[timestamp]_add_firstName_index/migration.sql
-- CreateIndex
CREATE INDEX "User_firstName_idx" ON "User" USING HASH ("firstName");
```
  </Accordion>
</Accordions>

Next, navigate to the `requests.http` file again and resend the requests to the `/users` route.

You will notice an improvement in response times. In my case, in the screenshot below, the response times have been down to about 9 to 11ms.

![](/blog/improving-query-performance-using-indexes-3-kduk351qv1/imgs/194080275-c4bd1059-595b-40b0-b2d9-b05339dac8cc.png)

Congratulations! ðŸŽ‰

You've learned how to reduce your database queries' response times using a hash index.

## Summary and next steps

In this part, you learned what hash indexes are, their internal structure and limitations, and how to define and use a hash index using Prisma.

If you would like learn about the fundamentals of database indexes and B-Tree indexes, refer to [part 1](/improving-query-performance-using-indexes-1-zuLNZwBkuL) and [part 2](/improving-query-performance-using-indexes-2-MyoiJNMFTsfq).

In the following article, you will learn about GIN indexes: what it is, their structure, how it works, and how you can utilize a GIN index in your application using Prisma.

