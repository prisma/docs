---
title: "Try the New \"Rust-free\" Version of Prisma ORM (Early Access)"
slug: "try-the-new-rust-free-version-of-prisma-orm-early-access"
date: "2025-04-30"
authors:
  - "Nikolas Burk"
metaTitle: "Try the New \"Rust-free\" Version of Prisma ORM (Early Access)"
metaImagePath: "/blog/try-the-new-rust-free-version-of-prisma-orm-early-access/imgs/meta-ff0b26daee0a92c1135e8397f9af50c91aec798c-1266x711.png"
heroImagePath: "/blog/try-the-new-rust-free-version-of-prisma-orm-early-access/imgs/hero-72705c07c42651a759db9aab07ea8a062c671a46-844x474.svg"
series:
  title: "Prisma ORM: The Complete Rust-to-TypeScript Migration Journey"
  slug: "prisma-orm-the-complete-rust-to-typescript-migration-journey"
seriesIndex: 3
excerpt: |
  Faster, more flexible, better DX: This is what our move from Rust to TypeScript unlocks! But it’s even more, it’s not just a re-write from one language to another, it’s a fundamental improvement in the Prisma ORM architecture—and you can [try it now](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine)!
---

### TL;DR: The Rust-Free ORM is ready for production-use

Prisma ORM's core engine has undergone a major shift from the **Rust based query engine** to a leaner **TypeScript/WASM core** (the **Query Compiler**). This [new architecture is now **production-ready** (v6.16+)](https://github.com/prisma/prisma/releases/tag/6.16.0) and fundamentally improves your developer experience (DX) and application performance.

- **No binary overhead:** The dependency on native Rust binaries is eliminated, drastically simplifying deployment and reducing potential complexity issues.
- **Performance:** Get **up to 3.4x faster queries** (by removing cross-language serialization) and a **90% smaller bundle size** (from ~14MB to 1.6 MB).
- **Better support for different runtimes:** Enables better support for deployement environments and runtimes like Cloudflare Workers, Deno, Bun, Vercel Edge and more.

To implement these benefits now, see the [official usage guide for the new Rust-Free ORM](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine). You can also follow the entire development and release history in our **[Prisma ORM: The Complete Rust-to-TypeScript Migration Journey](https://www.prisma.io/blog/series/prisma-orm-the-complete-rust-to-typescript-migration-journey)** blog series**.**

## A brief history of Prisma ORM

Let’s take a quick look back to understand the origins of the Prisma architecture and its Rust-based query engine.

### From GraphQL to databases

If you're newer to the Prisma community, this may surprise you: Prisma ORM emerged out of a GraphQL Backend-as-a-Service called [Graphcool](https://graph.cool). After several iterations where abstraction layers were peeled off and we moved down from the API layer to the database, we released Prisma ORM back in 2020:

![](/blog/try-the-new-rust-free-version-of-prisma-orm-early-access/imgs/d58c2ba3c9e5ad5777d73b46616c520cc2afab44-2220x746.png)

### Why the Rust query engine in the first place?

When Prisma ORM was conceived in 2020, we had the ambition of building Prisma ORM for various languages. So, we chose an architecture that would support us in that effort and split the query layer of Prisma ORM into two parts: 

- A **query engine**: Does the heavy-lifting of generating SQL queries and managing DB connections.
- A **lightweight language-specific client**: Lets developers easily send queries to the DB.

### Faster, more flexible, better DX

Five years later, the developer ecosystem has changed a lot: TypeScript is becoming the predominant language for the web and developers gravitate towards serverless deployments. We also gained valuable insights into the friction points our approach with the Rust engine has caused, most notably _compatibility issues_ with modern runtimes, _deployment complexities_ (e.g., due to the engine binary size or the need to compile it for a specific target), and _performance overhead_ due to extra serialization steps between language boundaries. 

With all that knowledge, we embarked on a journey of removing Rust from the architecture to create a version of Prisma ORM that's faster, more flexible and provides an overall much better developer experience! If you want to learn more about the migration process, check out our previous two articles on the topic:

- [From Rust to TypeScript: A New Chapter for Prisma ORM](https://www.prisma.io/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm)
- [Rust to TypeScript Update: Boosting Prisma ORM Performance](https://www.prisma.io/blog/rust-to-typescript-update-boosting-prisma-orm-performance)

## Prisma ORM v6.7.0: A new architecture without Rust engines (Early Access)

Following our previous updates, we're excited to release the new, _Rust-free_ architecture in [Early Access](https://www.prisma.io/docs/orm/more/releases#early-access) for PostgreSQL and SQLite with this week's [v6.7.0](http://github.com/prisma/prisma/releases/6.7.0) release. Please try it out and let us know what you think! 

### Usage with native JavaScript driver packages

The Rust-based query engine used to be responsible for managing database connections via built-in database drivers (that were also written in Rust). That's why, unlike other ORMs, Prisma ORM never required you to install additional packages (like [`pg`](https://node-postgres.com/) or [`better-sqlite3`](https://github.com/WiseLibs/better-sqlite3)).

By moving away from Rust, Prisma ORM also won't have built-in drivers anymore and now depends on a native JS driver to be used. This works via [driver adapters](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) which have been part of Prisma ORM since [v5.4.0](https://github.com/prisma/prisma/releases/tag/5.4.0) and are available via the `driverAdapters` Preview feature flag.

### Getting started with the new Prisma ORM architecture

To get started with the new _Rust-free_ version of Prisma ORM, you need to update your `prisma` and `@prisma/client` versions to `6.7.0`, and then set the `queryCompiler` and `driverAdapters` feature flags on your Prisma Client generator:

```prisma
generator client {
  provider        = "prisma-client-js" // or use the new "prisma-client" generator
  previewFeatures = ["queryCompiler", "driverAdapters"]
  output          = "../generated/prisma"
}
```
Next, you need to re-generate Prisma Client by running the following command:

```shell
npx prisma generate
```
Depending on whether you're using PostgreSQL or SQLite, you'll need to install the driver adapter for `pg` or `better-sqlite3`:



```shell
npm install @prisma/adapter-pg
```
```shell
npm install @prisma/better-sqlite3
```


After installation, you can instantiate your `PrismaClient` instance as follows:



```ts
import { PrismaPg } from '@prisma/adapter-pg'
import { PrismaClient } from './generated/prisma'

const adapter = new PrismaPg({ connectionString: process.env.DATABASE_URL })
const prisma = new PrismaClient({ adapter })
```
```ts
import { PrismaBetterSQLite3 } from '@prisma/adapter-better-sqlite3';
import { PrismaClient } from './generated/prisma';

const adapter = new PrismaBetterSQLite3({ url: process.env.DATABASE_URL })
const prisma = new PrismaClient({ adapter });
```


At this point, you can use your `PrismaClient` instance as usual — there are no other changes to how you use it for interacting with your database. The switch will be especially useful if you're using Prisma ORM in monorepos, newer runtimes like Bun and Deno, or deploy your application to Serverless and Edge environments.

## Performance boosts of Prisma ORM without Rust engines

The new architecture not only is more flexible and provides a friendlier DX. It also shows much better numbers when it comes to query performance. That's not because Rust itself is slow (quite the contrary), but because some queries experience a notable serialization overhead when queries and data are passing language boundaries. This overhead is saved with the new architecture, making query execution leaner and faster.

We've started comparing the performance of the old with the new architecture and found that almost all **queries become notably faster, sometimes they're twice as fast or even faster**!

For details on that, you can check out our recent [article](https://www.prisma.io/blog/rust-to-typescript-update-boosting-prisma-orm-performance) where we presented these measurements in detail.

## What's next for Prisma ORM?

Prisma ORM is undergoing major changes at the moment. We've announced our [ORM manifesto](https://www.prisma.io/blog/prisma-orm-manifesto) a few months ago with all details about changes to our OSS governance process. Since then, we've been working hard at making Prisma ORM _simpler_, _more robust_, and _more flexible_ with features like the new [`prisma-client` generator,](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#prisma-client-early-access) a [TypeScript-based configuration file](https://www.prisma.io/docs/orm/reference/prisma-config-reference) (called `prisma.config.ts`, and removing magic behaviors, like generating Prisma Client into `node_modules`). Check out our [roadmap](https://github.com/prisma/prisma/issues/26592) to see what's next!  

## Try out Prisma ORM without Rust

To summarize, the new Prisma ORM architecture without Rust:

- makes Prisma ORM more lightweight by removing the need for extra binaries
- makes Prisma ORM faster by saving serialization overhead across language boundaries
- provides a better DX because deployment is simpler (no more "binary targets")

Give it a shot and let us know what you think of it on [X](https://pris.ly/x) and our [Discord](https://pris.ly/discord)!

<br />
[Try Prisma ORM without Rust engines](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine)

## Frequently Asked Questions (FAQ)

The [Rust binary-free version](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine) of Prisma ORM is ready for production use as of [Prisma ORM version 6.16](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine?utm_source=chatgpt.com), and here are some common FAQs from our users:

### How much smaller is Prisma’s bundle without the Rust engine, and why does that help with cold starts?

When Prisma removed the Rust binary query engine, the bundle size dropped from about **14 MB (7 MB gzipped)** to around **1.6 MB (600 KB gzipped)**, which is an **85 to 90 percent reduction**.

This smaller bundle loads faster in serverless and edge environments such as [AWS Lambda](https://aws.amazon.com/lambda/), [Cloudflare Workers](https://workers.cloudflare.com/), and [Vercel Edge Functions](https://vercel.com/features/edge-functions).

Because less code needs to load and initialize, cold starts become faster and memory usage decreases.

### How much faster are queries with the Rust binary-free Prisma ORM compared to the old Rust engine?

In internal benchmarks, the Rust binary-free version of Prisma ORM, also called the **Query Compiler**, delivers significant performance improvements:

- `findMany` with 25,000 records improved from **185 ms to 55 ms** (about **3.4 times faster**)
- `findMany` with take = 2000 improved from **6.6 ms to 3.1 ms** (about **2.1 times faster**)
- Complex joins improved from **207 ms to 130 ms** (about **1.6 times faster**)

You can read more in the [Rust to TypeScript performance update blog](https://www.prisma.io/blog/rust-to-typescript-update-boosting-prisma-orm-performance?utm_source=chatgpt.com).

These improvements are most noticeable on large or complex queries.

### Will the Rust binary-free Prisma ORM work in runtimes like Cloudflare, Deno, and Bun?

Yes. Because Prisma’s new engine runs entirely in TypeScript and WebAssembly, it no longer depends on a native binary.

You can now use Prisma in environments that support JavaScript or WASM, such as [Cloudflare Workers](https://developers.cloudflare.com/workers/), [Bun](https://bun.sh/), and [Deno](https://deno.com/).

To enable it, use the new `prisma-client` generator and configure the correct driver adapter for your database, for example `@prisma/adapter-pg` for PostgreSQL.

See the [Prisma Client generator documentation](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#prisma-client?utm_source=chatgpt.com) for setup instructions.

### If Rust is already fast, why does switching to TypeScript and WebAssembly make Prisma faster?

Rust is a very fast systems language, but in the old architecture Prisma had to serialize and deserialize data between Rust and JavaScript.

That cross-language communication added overhead, especially for large queries.

The new Query Compiler runs in TypeScript and WebAssembly, which removes the need for this serialization step and results in faster query execution.

You can learn more about the change in [From Rust to TypeScript: A New Chapter for Prisma ORM](https://www.prisma.io/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm?utm_source=chatgpt.com).

### What changes are needed to use the Rust binary-free Prisma ORM?

To migrate to the new version:

1. Use the new `prisma-client` generator and set `engineType = "client"` in your `schema.prisma` file
2. Remove the `binaryTargets` configuration (it is no longer required)
3. Install the appropriate driver adapter for your database, such as `@prisma/adapter-pg` for PostgreSQL or `@prisma/adapter-sqlite` for SQLite
4. Run `npx prisma generate` to regenerate your Prisma Client

You can follow the full usage guide in the [Prisma documentation for the Rust binary-free ORM](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine?utm_source=chatgpt.com).

### Can I switch back to the Rust engine if needed?

Yes. If you encounter compatibility issues, you can temporarily revert to the legacy Rust engine by using an older Prisma ORM version before `6.16.0`.

However, the Rust binary-free engine is now the default moving forward and is recommended for all new projects.

Migration steps and fallback guidance are available in the [Rust-free Prisma ORM production release blog](https://www.prisma.io/blog/rust-free-prisma-orm-is-ready-for-production?utm_source=chatgpt.com).
