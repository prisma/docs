---
title: "Prisma 6: Better Performance, More Flexibility & Type-Safe SQL"
slug: "prisma-6-better-performance-more-flexibility-and-type-safe-sql"
date: "2024-11-28"
authors:
  - "Nikolas Burk"
metaTitle: "Prisma 6: Better Performance, More Flexibility & Type-Safe SQL"
metaDescription: "Today, we are releasing Prisma v6! Since the last major version, we have been hard at work incorporating user feedback, making Prisma ORM faster and more flexible, and adding amazing features like type-safe raw SQL queries."
metaImagePath: "/blog/prisma-6-better-performance-more-flexibility-and-type-safe-sql/imgs/meta-0bbe2e336e0bd55cb08133c81dc5cf297137b893-1200x630.png"
heroImagePath: "/blog/prisma-6-better-performance-more-flexibility-and-type-safe-sql/imgs/hero-1613e4843bb6239ae9f0e74962909b219dfafbc8-844x474.svg"
excerpt: |
  Today, we are releasing [Prisma v6](https://github.com/prisma/prisma/releases/tag/6.0.0)! Since the last major version, we have been hard at work incorporating user feedback, making Prisma ORM faster and more flexible, and adding amazing features like type-safe raw SQL queries.
---


## Prisma v6: What you need to know

We are excited to share that we've released another major version increment of Prisma ORM. We want to take this opportunity to recap everything that has happened since Prisma v5.

If you are using Prisma ORM and want to upgrade to v6, check out the [upgrade guide](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-6).

<br />
[Upgrade to v6](https://www.prisma.io/docs/orm/more/upgrade-guides/upgrading-versions/upgrading-to-prisma-6)

## Performance: JOINs and more efficient queries

With our development of Prisma ORM, we have followed the "_Make it work, make it right, make it fast_" approach. Since the [initial release](https://www.prisma.io/blog/prisma-the-complete-orm-inw24qjeawmb) in 2021, we have continuously invested in better query performance and are proud to share that we've been able to significantly improve query speed since [last major release](https://www.prisma.io/blog/prisma-5-f66prwkjx72s).

### Pick the best JOIN strategy

In principle, there are two different approaches when you need to query data from multiple tables that are related via _foreign keys_:

- **Database-level**: Send a single query to the database using the SQL `JOIN` keyword and let the data be _joined_ by the database directly.
- **Application-level**: Send multiple queries to individual tables to the database and _join_ the data yourself in your application.

Depending on your use case, your database schema, and several other factors, one strategy may be more appropriate than the other. Up until Prisma ORM [v5.7.0](https://github.com/prisma/prisma/releases/tag/5.7.0), Prisma ORM would always use the application-level JOIN strategy. 

However, with the v5.7.0 release, we now allow you to pick the best JOIN strategy for your use case, ensuring you can always get the best performance for your queries. To choose a join strategy, you can use the `relationLoadStrategy` option on relation queries, e.g.:

```ts
const usersWithPosts = await prisma.user.findMany({
  relationLoadStrategy: "join", // or "query"
  include: {
    posts: true,
  },
}); 
```
If you want to learn more about how these two approaches work under the hood and when to prefer which JOIN strategy, check out this blog post: [Prisma ORM Now Lets You Choose the Best Join Strategy (Preview)](https://www.prisma.io/blog/prisma-orm-now-lets-you-choose-the-best-join-strategy-preview).

### Performance improvements in nestedÂ create-operations

With Prisma ORM, you can create multiple new records inÂ _nested_Â queries, for example:

```ts
const user = await prisma.user.update({
  where: { id: 9 },
  data: {
    name: 'Elliott',
    posts: {
      create: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```
In versions before [v5.11.0](https://github.com/prisma/prisma/releases/tag/5.11.0), Prisma ORM would translate this into multiple SQLÂ `INSERT`Â queries, each requiring its own round-trip to the database. As of this release, these nestedÂ `create`Â queries are optimized and theÂ `INSERT`Â queries are sent to the databaseÂ _in bulk_Â in a single roundtrip. These optimizations apply to one-to-many as well as many-to-many relations.

### Faster queries in almost every release since v5

If you go through Prisma ORM [releases](https://github.com/prisma/prisma/releases/) on GitHub, you'll find that almost every release came with some kind of performance improvements.

We're committed to continue our investment in query performance to ensure your queries are as fast as possible ðŸ’šÂ By the way, if you're curious to learn how Prisma ORM compares to other TypeScript ORMs in terms of performance, check out our [TypeScript ORM benchmarks](https://www.prisma.io/blog/performance-benchmarks-comparing-query-latency-across-typescript-orms-and-databases).

## Flexibility: Node.js drivers, Edge support, multiple schema files & more

Over the past year, we not only improved performance, but also made Prisma ORM a lot more flexible. Since Prisma v5, we have made it possible to use Prisma ORM in new environments (like Cloudflare Workers or even React Native apps [via Expo](https://www.prisma.io/blog/bringing-prisma-orm-to-react-native-and-expo)), with new databases, and have implemented highly popular features like splitting your `schema.prisma` into multiple files, being able to return created records from a bulk create query, or exclude specific fields from the result payload of a query.

### Support for serverless drivers from PlanetScale and Neon

Both [PlanetScale](https://planetscale.com/docs/tutorials/planetscale-serverless-driver) and [Neon](https://neon.tech/docs/serverless/serverless-driver) have released _serverless drivers_ that enable accessing their database instances via HTTP (instead of TCP, which is commonly used for database connections). These serverless drivers are particularly useful in serverless and edge environments, where initiating a TCP connection may be too expensive or entirely impossible.

In [v5.4.0](https://github.com/prisma/prisma/releases/tag/5.4.0), we released [support for custom database drivers in Prisma ORM](https://www.prisma.io/blog/serverless-database-drivers-KML1ehXORxZV), enabling the use of both the PlanetScale and Neon serverless drivers. Here's an example for connecting to a PlanetScale instance using their serverless driver:

```ts
import { connect } from '@planetscale/database';
import { PrismaPlanetScale } from '@prisma/adapter-planetscale';
import { PrismaClient } from '@prisma/client';

const connection = connect({ url: process.env.DATABASE_URL });
const adapter = new PrismaPlanetScale(connection);
const prisma = new PrismaClient({ adapter });
```
### Prisma ORM: An edge-ready way to talk to your database

Edge functions, such as Cloudflare Workers or Vercel Edge Functions, have been rising in popularity. Thanks to their high geographic distribution and closeness to users, they enable lightning-fast response times.

![](/blog/prisma-6-better-performance-more-flexibility-and-type-safe-sql/imgs/cdc1687a8bc84dd978cd3e2270618719a6da7207-1920x1080.png)

Since [v5.11.0](https://github.com/prisma/prisma/releases/tag/5.11.0), Prisma ORM can be used in these edge environments. This has been a major achievement and we're excited to see what developers are building with Prisma ORM at the edge!

You can learn more about this feature in this blog post: [Prisma ORM Support for Edge Functions is Now in Preview](https://www.prisma.io/blog/prisma-orm-support-for-edge-functions-is-now-in-preview).

### New databases: D1 and Turso

Since v5, we not only enabled usage of Prisma ORM in new runtimes. We also added support for new databases, like [Cloudflare D1](https://www.prisma.io/blog/build-applications-at-the-edge-with-prisma-orm-and-cloudflare-d1-preview) and [Turso](https://www.prisma.io/blog/prisma-turso-ea-support-rXGd_Tmy3UXX).

Both databases are based on SQLite and well-suited for building applications at the edge.

### Split your Prisma schema into multiple files

In [v5.15.0](https://github.com/prisma/prisma/releases/tag/5.15.0), we tackled a popular feature request and made it possible to have _multiple_ files that make up your Prisma schema. For example, you can now have these two files that each contain a single model:

#### `user.prisma`

```prisma
model User {
  id    Int     @id @default(autoincrement())
  name  String
  posts Post[]
}
```
#### `post.prisma`

```prisma
model Post {
  id       Int     @id @default(autoincrement())
  title    String
  content  String
  authorId Int
  author   User    @relation(fields: [authorId], references: [id])
}
```
When you run a migration or another Prisma CLI command, the CLI will merge the individual files into a single file. Learn more about this feature in our announcement blog post: [Organize Your Prisma Schema into Multiple Files in v5.15](https://www.prisma.io/blog/organize-your-prisma-schema-with-multi-file-support)

### Making the Prisma Client API more flexible

Besides all these improvements, we've also incorporated new capabilities in the Prisma Client API, making it even easier and more convenient to query data from the database.

As an example, the new `createManyAndReturn()` query enables you to create multiple records in a single query while also returning all the new records:

```ts
const posts = prisma.post.createManyAndReturn({
  where: { id: 9 },
  data: [
    { title: 'Hello World' }, 
    { title: 'The new createManyAndReturn query is super handy' },
    // ... more
  ],
})
```
In previous versions, the only way to create multiple records at once was by using `createMany` which only returned the count of the created records.

Another example for more flexibility in the Prisma Client API is the new `omit` option. It is the counterpart to `select` and lets you [exclude fields](https://www.prisma.io/docs/orm/prisma-client/queries/select-fields#omit-specific-fields) from the result payload of a query:

```ts
const users = await prisma.user.findFirst({
  omit: { password : true }
})
```
The query above will return all fields of the `User` model, except for the `password` field.

## Typed SQL: Type-safe, raw SQL queries

Finally, one of the most exciting features we've delivered this year was a way to write type-safe raw SQL queries. With that addition, Prisma ORM now gives you the best of both worlds: A convenient high-level abstraction for the majority of queriesÂ andÂ a flexible, type-safe escape hatch for raw SQL.

Consider this example of a raw SQL query you may need to write in your application:

```sql
-- prisma/sql/conversionByVariant.sql

SELECT "variant", CAST("checked_out" AS FLOAT) / CAST("opened" AS FLOAT) AS "conversion"
FROM (
  SELECT
    "variant",
    COUNT(*) FILTER (WHERE "type"='PageOpened') AS "opened",
    COUNT(*) FILTER (WHERE "type"='CheckedOut') AS "checked_out"
  FROM "TrackingEvent"
  GROUP BY "variant"
) AS "counts"
ORDER BY "conversion" DESC
```
After a generation step, you'll be able to use the `conversionByVariant` query via the new `$queryRawTyped` method in Prisma Client:

```ts
import { PrismaClient } from '@prisma/client'
import { conversionByVariant } from '@prisma/client/sql'

// `result` is fully typed!
const result = await prisma.$queryRawTyped(conversionByVariant())
```
Learn more about this on our blog: [Announcing TypedSQL: Make your raw SQL queries type-safe with Prisma ORM](https://www.prisma.io/blog/announcing-typedsql-make-your-raw-sql-queries-type-safe-with-prisma-orm)

## One more thing: Prisma Postgres â€” The best database to use with Prisma ORM

While we've made great progress with Prisma ORM, our highlight has been the recent launch of Prisma Postgres â€” the best database to use with Prisma ORM!

<Youtube videoId="JDV8CKULPIk" />

Prisma Postgres is **a managed PostgreSQL service that gives developers anÂ _always-on_Â database withÂ _pay-as-you-go_Â pricing for storage and queries**Â (no fixed cost, no cost for compute). It's like a serverless database â€” but without cold starts and a generous free tier!

To build a service with these capabilities, we've designed a unique architecture using bare metal machines, a revolutionary millisecond cloud stack, andÂ _unikernels_Â (think: "hyper-specialized operating systems") running as ultra-lightweight microVMs.

Thanks to the first-class integration of Prisma products,Â **Prisma Postgres comes with connection pooling, caching, real-time subscriptions, and query optimization recommendations**Â out-of-the-box.


<br />
[Try Prisma Postgres](https://www.prisma.io/docs/getting-started/quickstart-prismaPostgres)


## Thank you for your support ðŸ’š

It is only thanks to _you_â€”our amazing communityâ€”that we have been able to create the [most popular ORM in the TypeScript ecosystem](https://www.prisma.io/blog/how-prisma-orm-became-the-most-downloaded-orm-for-node-js).

Thank you all so much for the ongoing support, your feedback and input that helps us make Prisma better every day. 

If you have anything to share, be it a help request, an excited compliment, or constructive feedback, you can always reach us on our [Discord](https://pris.ly/discord) and on [X](https://pris.ly/x).


> âœ¨ We're always trying to improve! If you've recently used Prisma ORM, we'd appreciate hearing your thoughts about your experience via this [2min survey](https://pris.ly/orm/survey/release-5-22).

