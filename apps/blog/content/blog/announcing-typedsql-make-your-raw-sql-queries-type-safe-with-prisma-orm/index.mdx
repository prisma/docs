---
title: "Announcing TypedSQL: Make your raw SQL queries type-safe with Prisma ORM"
slug: "announcing-typedsql-make-your-raw-sql-queries-type-safe-with-prisma-orm"
date: "2024-08-27"
authors:
  - "Nikolas Burk"
metaTitle: "Announcing TypedSQL: Make your raw SQL queries type-safe with Prisma ORM"
metaDescription: "Prisma ORM now supports the ability to write raw sql queries and have the inputs and outputs be fully type-safe! Get the benefit of a high-level API with the power of raw SQL."
metaImagePath: "/blog/announcing-typedsql-make-your-raw-sql-queries-type-safe-with-prisma-orm/imgs/meta-6212889ff7d56ad41636c0f7938159b1fd740651-1688x948.png"
heroImagePath: "/blog/announcing-typedsql-make-your-raw-sql-queries-type-safe-with-prisma-orm/imgs/hero-9d1c710f959ab75107576ad53720a7731c75797a-844x474.png"
excerpt: |
  With todayâ€™s [v5.19.0](https://github.com/prisma/prisma/releases/tag/5.19.0) release, Prisma ORM introduces a new way to write raw SQL queries in a type-safe way! You now get the best of both worlds with Prisma ORM: A convenient  high-level abstraction for the majority of queries _and_ a flexible, type-safe escape hatch for raw SQL.
---

## TL;DR: We made raw SQL fully type-safe

With Prisma ORM, we have designed what we believe to be the best API to write regular CRUD queries that make up 95% of most apps! 

For the remaining 5% â€” the complex queries that either can't be expressed with the Prisma Client API or rCopy the port number from the terminal output, youâ€™ll need it in the next step for the pg_restore command.equire maximum performance â€” we have provided a lower level API to write raw SQL. However, this escape hatch didn't offer type safety and developers were missing the great DX they were used to from Prisma ORM, so we looked for a better way!

With todayâ€™s Prisma ORM [v5.19.0](https://github.com/prisma/prisma/releases/tag/5.19.0) release, we are thrilled to announce TypedSQL: The best way to write complex and highly performant queries. **[TypedSQL](https://www.prisma.io/typedsql) is just SQL, but better.** Itâ€™s fully type-safe, provides auto-completion, and gives you a fantastic DX whenever you need to craft raw SQL queries. Hereâ€™s how it works:

1. Write a SQL query in a `.sql` file and put it into the `prisma/sql` directory:

    

    ```sql
    -- prisma/sql/conversionByVariant.sql
    
    SELECT "variant", CAST("checked_out" AS FLOAT) / CAST("opened" AS FLOAT) AS "conversion"
    FROM (
      SELECT
        "variant",
        COUNT(*) FILTER (WHERE "type"='PageOpened') AS "opened",
        COUNT(*) FILTER (WHERE "type"='CheckedOut') AS "checked_out"
      FROM "TrackingEvent"
      GROUP BY "variant"
    ) AS "counts"
    ORDER BY "conversion" DESC
    ```
    
    ```prisma
    model User {
      id             String          @id @default(uuid())
      email          String          @unique
      trackingEvents TrackingEvent[]
    }
    
    model TrackingEvent {
      id        String   @id @default(uuid())
      timestamp DateTime @default(now())
      userId    String
      type      String
      variant   String
      user      User     @relation(fields: [userId], references: [id])
    }
    ```
    
		You can also create SQL queries with arguments!
		

    ```sql
    -- prisma/sql/conversionByVariantByVersion.sql
	-- note that this syntax is for PostgreSQL.
	-- Argument syntax will depend on your database engine.
    
    SELECT "variant", CAST("checked_out" AS FLOAT) / CAST("opened" AS FLOAT) AS "conversion"
    FROM (
      SELECT
        "variant",
        COUNT(*) FILTER (WHERE "type"='PageOpened') AS "opened",
        COUNT(*) FILTER (WHERE "type"='CheckedOut') AS "checked_out"
      FROM "TrackingEvent"
	    WHERE version = $1
      GROUP BY "variant"
    ) AS "counts"
    ORDER BY "conversion" DESC
    ```
    
    ```prisma
    model User {
      id             String          @id @default(uuid())
      email          String          @unique
      trackingEvents TrackingEvent[]
    }
    
    model TrackingEvent {
      id        String   @id @default(uuid())
      timestamp DateTime @default(now())
      userId    String
      type      String
      variant   String
	    version Int
      user      User     @relation(fields: [userId], references: [id])
    }
    ```
    
    
2. Generate query functions by using the `--sql` flag on `prisma generate`:
```
    npx prisma generate --sql
    ```
    
3. Import the query function from `@prisma/client/sql` â€¦
    
    ```typescript
    import { PrismaClient } from '@prisma/client'
    import { conversionByVariant } from '@prisma/client/sql'
    ```
    
    â€¦ and call it inside the new `$queryRawTyped` function to get fully typed results ðŸ˜Ž
    
    ```typescript
    // `result` is fully typed!
    const result = await prisma.$queryRawTyped(conversionByVariant())
    ```
		
		If your SQL query has arguments, they are provided to the query function passed to `$queryRawTyped`
		
		```typescript
		// only give me conversion results from TrackingEvent version 5
		const result = await prisma.$queryRawTyped(conversionByVariantByVersion(5))
		```
    
The Prisma Client API together with TypedSQL provides the best experience for both CRUD operations and highly complex queries. With this addition, we hope you will never have to touch a SQL query builder again!


<Youtube  videoId="ZwYcCti6CEs"/>


## High-level abstraction for high productivity

Raw SQL still provides the most powerful and flexible way to query your data in a relational database. But it does come with some drawbacks.

### Drawbacks of raw SQL

If youâ€™ve written raw SQL in a TypeScript project before, you likely know it doesnâ€™t exactly provide the best DX:

- No auto-completion when writing SQL queries.
- No type-safety for query results.
- Intricacies of writing and debugging complex SQL queries.
- Development teams often have varying levels of SQL experience and not everyone on the team is proficient in writing SQL.
- SQL uses a different data model (_relations_) compared to TypeScript (_objects_) which needs to be mapped from one to another; this is especially prevalent when it comes to relationships between your models which are expressed via _foreign keys_ in SQL but as _nested objects_ in TypeScript.

### Application developers should care about _data_ â€“ not SQL

At Prisma, we strongly believe that application developers should care about _data_ â€“ not SQL. 

The majority of queries a typical application developer writes uses a fairly limited set of features, typically related to common CRUD operations, such as _pagination_, _filters_ or _nested queries_.

<TweetEmbedComp tweets={['1815664017781735475']}/>

Our main goal is to ensure that application developers can quickly get the data they need without thinking much about the query and the mapping of rows in their database to the objects in their code.

### Ship fast with Prisma ORM

This is why weâ€™ve built Prisma ORM, to provide developers an abstraction that makes them productive and lets them ship fast! Hereâ€™s an overview of the typical workflow for using Prisma ORM.

First, you define your data model in a human-readable schema:

```prisma
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}
```
Using the Prisma CLI, you can then generate a (customizable) SQL migration and run the migration against your database. Once the schema has been mapped to your database, you can query it with Prisma Client:



```typescript
// Create new user with posts
await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
  },
})
```
```typescript
// Query users with posts
await prisma.user.findMany({
  include: {
    posts: true,
  },
})
```


## Escape hatch: Dropping down to raw SQL

While we believe that this kind of higher-level abstraction makes developers more productive, we have seen that many projects require the option to write raw SQL. This typically happens when:

- the Prisma Client API isnâ€™t flexible enough to express a certain query.
- a query needs to be optimized for speed.

In these cases, Prisma ORM offers an escape hatch for raw SQL by using the `$queryRaw` method of Prisma Client: 

```typescript
const result = await prisma.$queryRaw`
SELECT "variant", CAST("checked_out" AS FLOAT) / CAST("opened" AS FLOAT) AS "conversion"
FROM (
  SELECT
    "variant",
    COUNT(*) FILTER (WHERE "type"='PageOpened') AS "opened",
    COUNT(*) FILTER (WHERE "type"='CheckedOut') AS "checked_out"
  FROM "TrackingEvent"
  GROUP BY "variant"
) AS "counts"
ORDER BY "conversion" DESC
`
```
The main problem with this approach is that this query isnâ€™t type-safe. If the developer wants to enjoy the type safety benefits they get from the standard Prisma Client API, they need to manually write the return types of this query, which can be cumbersome and time-consuming. Another problem is that these manually defined types donâ€™t auto-update with schema changes, which introduces another possibility for error.

While there are ways to improve the DX using Prisma ORMâ€™s raw queries, e.g. by using the [Kysely query builder extension for Prisma Cient](https://github.com/eoin-obrien/prisma-extension-kysely)  or [SafeQL](https://safeql.dev/compatibility/prisma.html), we wanted to address this problem in a native way.

## New in Prisma ORM: TypedSQL ðŸŽ‰

Thatâ€™s why weâ€™re excited to introduce [TypedSQL](https://www.prisma.io/docs/orm/prisma-client/using-raw-sql/typedsql), a new workflow in Prisma ORM that gives you type safety for raw SQL queries. TypedSQL is inspired by projects like [PgTyped](https://pgtyped.dev/) and [sqlx](https://github.com/launchbadge/sqlx) that are based on similar ideas.

With TypedSQL, Prisma ORM now gives you the best of both worlds:

- A higher-level abstraction that makes developers productive and can serve the majority of queries in a project.
- A delightful and type-safe escape hatch for when you need to craft SQL directly.

It also gives development teams, where individual developers have different preferences, the option to choose their favorite approach: Do you have an Engineer on the team whoâ€™s a die-hard SQL fan but also some that wouldnâ€™t touch SQL with a ten-foot pole? 

Prisma ORM now gives both groups what they want without sacrificing DX or flexibility!

## Try it out and share your feedback

TypedSQL is your new companion whenever you would have resorted to using `$queryRaw` in the past.

We see TypedSQL as the evolution of SQL query builders, giving developers even more flexibility in their database queries because it removes all abstractions. 

<br />
[Try TypedSQL](https://pris.ly/typedsql-example)

Weâ€™d love for you to try out TypedSQL and let us know what you think of it on [X](https://pris.ly/x) and on [Discord](https://pris.ly/discord)!

