---
title: "Prisma ORM without Rust: Latest Performance Benchmarks"
slug: "prisma-orm-without-rust-latest-performance-benchmarks"
date: "2025-07-24"
authors:
  - "Nikolas Burk"
metaTitle: "Prisma ORM without Rust: Latest Performance Benchmarks"
metaImagePath: "/blog/prisma-orm-without-rust-latest-performance-benchmarks/imgs/meta-8d83e1420faca85afbc7a1cf78f660374577d3f3-1266x711.png"
heroImagePath: "/blog/prisma-orm-without-rust-latest-performance-benchmarks/imgs/hero-be74183d9d749c0b17c850334f376711d8a44d22-844x474.svg"
series:
  title: "Prisma ORM: The Complete Rust-to-TypeScript Migration Journey"
  slug: "prisma-orm-the-complete-rust-to-typescript-migration-journey"
seriesIndex: 5
excerpt: |
  Our move from Rust to TypeScript in the Prisma ORM internals is now in Preview for all first-class databases! In this article, weâ€™re sharing the performance improvements we observed in our latest benchmarks and give an outlook for Prisma v7 where the ORM will become â€œRust-freeâ€ by default.
---

### TL;DR: The Rust-Free ORM is ready for production-use

Prisma ORM's core engine has undergone a major shift from the **Rust based query engine** to a leaner **TypeScript/WASM core** (the **Query Compiler**). This [new architecture is now **production-ready** (v6.16+)](https://github.com/prisma/prisma/releases/tag/6.16.0) and fundamentally improves your developer experience (DX) and application performance.

- **No binary overhead:** The dependency on native Rust binaries is eliminated, drastically simplifying deployment and reducing potential complexity issues.
- **Performance:** Get **up to 3.4x faster queries** (by removing cross-language serialization) and a **90% smaller bundle size** (from ~14MB to 1.6 MB).
- **Better support for different runtimes:** Enables better support for deployement environments and runtimes like Cloudflare Workers, Deno, Bun, Vercel Edge and more.

To implement these benefits now, see the [official usage guide for the new Rust-Free ORM](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine). You can also follow the entire development and release history in our **[Prisma ORM: The Complete Rust-to-TypeScript Migration Journey](https://www.prisma.io/blog/series/prisma-orm-the-complete-rust-to-typescript-migration-journey)** blog series**.**

## Prisma ORM without Rust engines is in Preview

Our move from Rust to TypeScript not only improves the developer experience, it also makes Prisma ORM more flexible and easier to useâ€”whether you're working with different JavaScript runtimes, deployment platforms, or project setups like monorepos. On top of that, it brings significant performance improvements.

Over the past few [releases](https://github.com/prisma/prisma/releases/), weâ€™ve gradually rolled out [Preview](https://www.prisma.io/docs/orm/more/releases#preview) support for Prisma ORM for all major SQL databases supported by Prisma ORM. Itâ€™s now available for: PostgreSQL, CockroachDB, Neon, MySQL, MariaDB, PlanetScale, SQLite, D1 and MS SQL Server databases.

Our work on moving away from Rust continues with the goal of making â€œRust-freeâ€ Prisma ORM the default in the upcoming Prisma v7 release. In this article, we are sharing an update on the performance improvements weâ€™ve measured using the latest Rust-free Preview version of Prisma ORM.

## Recap: Why move away from Rust?

We [chose a Rust-based architecture initially](https://www.prisma.io/blog/try-the-new-rust-free-version-of-prisma-orm-early-access#why-the-rust-query-engine-in-the-first-place) because we wanted to make Prisma ORM available for various programming languages. Five years later, it has become clear that TypeScript is the dominant language for building web applications and the goal of supporting multiple languages has become secondary to providing the best DX possible for TypeScript developers.

With that in mind, our main reasons for moving away from Rust are:

- **Lower bundle size:** While weâ€™ve managed to decrease it quite a bit over the past years, the engine binary still notably contributes to the bundle size of your application.
- **Faster queries:** The serialization across language boundaries makes queries (especially those returning larger sets of data) slower. Eliminating this overhead makes Prisma ORM notably faster.
- **Lower CPU footprint:** Running the query engine as a binary alongside your application causes extra CPU usage that will be eliminated by the Rust-free ORM version.
- **Less deployment complexity:** When deploying your app, the query engine binary needs to be compiled for the OS of your hosting provider. This extra step sometimes caused extra issues that are not going to be present with the engine-free Prisma ORM.
- **Easier community contributions:** Prisma ORM is open-source, but having a core written in Rust made it difficult for our community to make significant contributions to it. Weâ€™re excited that our move to TypeScript will lower the barrier for developers to contribute and are looking forward to collaborating more with our community.

If you want to learn more, you can check out our previous articles on this topic:

- [From Rust to TypeScript: A New Chapter for Prisma ORM](https://www.prisma.io/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm) (January 30th)
- [Rust to TypeScript Update: Boosting Prisma ORM Performance](https://www.prisma.io/blog/rust-to-typescript-update-boosting-prisma-orm-performance) (March 3rd)
- [Try the New "Rust-free" Version of Prisma ORM (Early Access)](https://www.prisma.io/blog/try-the-new-rust-free-version-of-prisma-orm-early-access) (April 30th)

## Benchmark update: Rust-free Prisma ORM is faster

We continuously run benchmarks on the new releases of Prisma ORM in order to monitor any changes and prevent performance regressions as we continue the migration from Rust to TypeScript. You can find all details about our setup in the [benchmark repo](https://github.com/prisma/query-compiler-benchmarks/).

In the latest benchmark run, we found that for almost all queries that we tested, the performance improved compared to the prior Rust-based version of Prisma ORM:

| Query                                                    | Rust    | Rust-free w/ pg | Comparison (Rust Ã· QC) |
| -------------------------------------------------------- | ------- | --------------- | ---------------------- |
| findMany (all 25k)                                       | 163 ms  | 77 ms           | 2.12Ã—                  |
| findMany (take 2k)                                       | 8 ms    | 5 ms            | 1.60Ã—                  |
| findMany (where + take 2k)                               | 10 ms   | 8 ms            | 1.25Ã—                  |
| findMany (orderBy + take 50)                             | 5 ms    | 5 ms            | 1.00Ã—                  |
| update (single)                                          | 1 ms    | 1 ms            | 1.00Ã—                  |
| findMany (include cast, m2m, take 2k)                    | 1539 ms | 136 ms          | 11.32Ã—                 |
| findMany (where + include cast, m2m, take 2k)            | 82 ms   | 38 ms           | 2.16Ã—                  |
| findMany (include cast + person, where, take 2k)         | 169 ms  | 70 ms           | 2.41Ã—                  |
| findMany (where reviews.author, to-many â†’ to-one)        | 177 ms  | 182 ms          | 0.97Ã—                  |
| findMany (where cast.person, m2m â†’ to-one)               | 1 ms    | 2 ms            | 0.50Ã—                  |
| review.findMany (where author, to-one)                   | 1 ms    | 1 ms            | 1.00Ã—                  |
| actor.findMany (movies.reviews.author, to-many â†’ to-one) | 178 ms  | 179 ms          | 0.99Ã—                  |
| findUnique (include reviews.take 3)                      | 19 ms   | 25 ms           | 0.76Ã—                  |
| findUnique (include cast.take 3)                         | 1 ms    | 1 ms            | 1.00Ã—                  |
| actor + 25 movies (ordered), 15 actors each              | 9 ms    | 11 ms           | 0.82Ã—                  |

> **Note**: These benchmarks were created on a PostgreSQL database and the Rust-free Prisma ORM version uses the [`pg`](https://node-postgres.com/) driver.

Overall, the Rust-free version of Prisma ORM delivers strong performance improvementsâ€”especially when working with large datasets. In our benchmarks, queries that returned a lot of data were consistently faster with the new TypeScript-based implementation.

For smaller queries, performance differences between the two versions are minimal. In some cases, the Rust-based version was slightly faster, but only when the absolute query time was already extremely low (e.g. 1â€“2â€¯ms). These marginal gains are not meaningful in practice and donâ€™t outweigh the broader benefits of the Rust-free version.

Our key takeaway is that Prisma ORM without Rust is often significantly faster where it matters mostâ€”on large and complex queriesâ€”while remaining on par for simpler ones.

Another benefit: The CPU footprint of the Rust-free Prisma ORM is notably reduced, as there's no longer a separate [engine binary](https://www.prisma.io/docs/orm/more/under-the-hood/engines) running alongside your app.

## Get started with Rust-free Prisma ORM

If you read this and have become curious, here are the steps you need to follow to try out the Rust-free version of Prisma ORM:

1. Enable the `queryCompiler` and `driverAdapters` Preview feature flags in your Prisma schema:
   ```prisma
   generator client {
     provider        = "prisma-client-js" // or `prisma-client`
     output          = "../generated/prisma"
     previewFeatures = ["queryCompiler", "driverAdapters"]
   }
   ```
   > **Note**: The new internal component replacing the query engine is called _query compiler_, hence the name of the Preview feature flag.

2. Run `prisma generate` to re-generate Prisma Client
3. Install a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) for your database (e.g. `@prisma/adapter-pg` if youâ€™re using PostgreSQL):
   ```shell
   npm install @prisma/adapter-pg
   ```

4. You can instantiateÂ `PrismaClient`Â as follows:
   ```ts
   import { PrismaClient } from "./generated/prisma";
   import { PrismaPg } from "@prisma/adapter-pg";

   const adapter = new PrismaPg({ connectionString: env.DATABASE_URL });
   const prisma = new PrismaClient({ adapter });
   ```

In the Rust-based version of Prisma ORM, youâ€™ll find an engine binary file in your `output` directory (or in `node_modules` if you havenâ€™t set a dedicated `output` path). You can now check that youâ€™re using the Rust-free version of Prisma ORM by validating that this binary file isnâ€™t there. By the way, this will significantly decrease the bundle size of your entire application ðŸŽ‰

## Try it out and share your feedback

The Rust-free version of Prisma ORM is approaching General Availability and weâ€™re excited that you can now try it out for any major database supported by Prisma ORM.

Follow the instructions above or try one of our [ready-to-run example projects](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client) (which also use the new, ESM-first `prisma-client` generator), for example:

- [Next.js + Turborepo + Node.js](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client/nextjs-starter-webpack-turborepo)
- [Next.js in a monorepo](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client/nextjs-starter-webpack-monorepo)
- [React Router + Vite + Cloudflare](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client/react-router-starter-cloudflare-workerd)
- [Nuxt 3 + Vite + Nitro](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client/nuxt3-starter-nodejs)
- [Deno Deploy](https://github.com/prisma/prisma-examples/tree/latest/generator-prisma-client/deno-deploy)

Share your feedback [on Discord](https://pris.ly/discord) or ping us [on X](https://pris.ly/x).

