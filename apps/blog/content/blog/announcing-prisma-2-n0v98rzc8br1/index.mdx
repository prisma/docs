---
title: "Prisma 2.0: Confidence and productivity for your database"
slug: "announcing-prisma-2-n0v98rzc8br1"
date: "2020-06-09"
authors:
  - "Nikolas Burk"
metaTitle: "Announcing Prisma 2: Confidence and productivity for your database"
metaImagePath: "/blog/announcing-prisma-2-n0v98rzc8br1/imgs/hero-11436ec45c7ccbc812212d1d6d7c8794d9514f2f-1692x852.jpg"
heroImagePath: "/blog/announcing-prisma-2-n0v98rzc8br1/imgs/hero-11436ec45c7ccbc812212d1d6d7c8794d9514f2f-1692x852.jpg"
heroImageAlt: " Ombre Prisma"
excerpt: |
  Accessing databases in Node.js and TypeScript can feel brittle and painful. Prisma removes the pain with an auto-generated and type-safe query builder that's tailored to your data! [Try it out!](https://www.prisma.io/docs/getting-started/quickstart)

---


## Contents

- [The problem: Working with databases is difficult](#the-problem-working-with-databases-is-difficult)
- [The solution: Prisma makes databases easy](#the-solution-prisma-makes-databases-easy)
- [What you can build with Prisma](#what-you-can-build-with-prisma)
- [A strong ecosystem growing around Prisma](#a-strong-ecosystem-growing-around-prisma)
- [Getting started with Prisma](#getting-started-with-prisma)
- [A huge thank you to our community ðŸ’š](#a-huge-thank-you-to-our-community-)

---

## The problem: Working with databases is difficult

The existing [landscape of database access libraries](https://www.prisma.io/dataguide/types/relational/comparing-sql-query-builders-and-orms) ranges from sending raw SQL strings to higher-level abstractions like SQL query builders and ORMs. Each of these approaches come with their own [problems and pitfalls](https://www.prisma.io/docs/concepts/overview/why-prisma#problems-with-sql-orms-and-other-database-tools). Overall, there's a lack of best practices for application developers who work with databases in Node.js and TypeScript.

The jungle of existing tools and lack of best practices have two main consequences:

- Developers aren't _productive_ because the existing tools don't fit their needs
- Developers aren't _confident_ that they're doing the "right thing" 

## The solution: Prisma makes databases easy

Prisma is an open source database toolkit. It replaces traditional ORMs and makes database access easy with an auto-generated and type-safe query builder for Node.js and TypeScript.

Prisma currently supports **PostgreSQL**, **MySQL** and **SQLite** databases â€“Â with more planned. Please create [new GitHub issues](https://github.com/prisma/prisma/issues/new) or subscribe to existing ones (e.g. for [MongoDB](https://github.com/prisma/prisma/issues?q=is%3Aissue+is%3Aopen+mongo) or [DynamoDB](https://github.com/prisma/prisma/issues/1676)) if you'd like to see support for specific databases.

After running the Preview and Beta versions of Prisma 2.0 for almost a year and gathering lots of helpful feedback from our community, we are excited to launch Prisma Client for General Availability ðŸŽ‰

### Prisma Client: Modern database access for Node.js and TypeScript

Prisma Client provides an entirely new way for developers to access a database with two main goals in mind:

- **Boost productivity** by letting developers query data in natural and familiar ways
- **Increase confidence** with type-safety, auto-completion and a robust query API 

### How Prisma Client boosts productivity and raises confidence

In this section, we'll take a closer look at how Prisma Client enables developers to build applications faster while writing more resilient and robust code.

Here's an overview of the benefits you get from Prisma Client:

- [Thinking in objects: A natural and familiar query API](#thinking-in-objects-a-natural-and-familiar-query-api)
- [Working intuitively with relations](#working-intuitively-with-relations)
- [Auto-completion for database queries](#auto-completion-for-database-queries)
- [Fully type-safe database queries](#fully-type-safe-database-queries)
- [A declarative and human-readable database schema](#a-declarative-and-human-readable-database-schema)
- [A single source of truth for database and application models](#a-single-source-of-truth-for-database-and-application-models)

#### Thinking in objects: A natural and familiar query API

One of the biggest benefits of Prisma Client is the level of abstraction it provides. It allows developers to think of their data in _objects_ (instead of SQL), reducing the cognitive and practical overhead of mapping _relational_ to _object-oriented_ data.

Although Prisma Client returns data as objects, [it's not an ORM](https://www.prisma.io/docs/concepts/overview/prisma-in-your-stack/is-prisma-an-orm) and therefore doesn't suffer from [common problems often caused by the object-relational impedance mismatch](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/). 

Prisma doesn't map classes to tables and there are no complex model instances or hidden performance pitfalls (e.g. due to lazy loading) as often seen in traditional ORMs. Prisma Client provides a query API for _your_ database schema with a focus on _structural typing_ and natural querying (in that sense, it gets closest to the _data mapper_ pattern of traditional ORMs).

As an example, assume you have these `User` and `Post` tables:



![Entity Relationship Diagram](/blog/announcing-prisma-2-n0v98rzc8br1/imgs/cQRivY4.png)

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name TEXT
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    title VARCHAR(25) NOT NULL,
    content TEXT,
    "authorId" INTEGER NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User"(id)
);
```


With Prisma Client, you can formulate queries like the following to read and write data in these tables:



```ts
const postsByAuthor = await prisma.post.findMany({
  where: { 
    author: { id: 42 } 
  },
})
```
```js
[{
  id: 1,
  title: "Follow Prisma on Twitter"
  authorId: 42,
}, {
  id: 2,
  title: "Join us online for Prisma Day 2020"
  authorId: 42,
}]
```


As you can see, the resulting `postsByAuthor` contains an array of plain JavaScript objects (if you're using TypeScript, these objects will be strongly typed). 

> **Note**: The `author` field is a _virtual_ [relation field](https://www.prisma.io/docs/concepts/components/prisma-schema/relations#relation-fields) that connects the `Post` to the `User` table in the Prisma Client API. Since it's not directly represented in the database, it can be [named in any way you like](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/use-custom-model-and-field-names).

You can also easily include the relations of a model, in this case, you could also retrieve the information about the "author" of the return posts:



```ts
const postsByAuthorWithAuthorInfo = await prisma.post.findMany({
  where: { 
    author: { id: 42 } 
  },
  include: {
    author: true,
  }
})
```
```js
[{
  id: 1,
  title: "Follow Prisma on Twitter",
  content: null,
  authorId: 42,
  author: {
    id: 42,
    email: "alice@prisma.io",
    name: "Alice"
  }
}, {
  id: 2,
  title: "Join us online for Prisma Day 2020",
  content: null,
  authorId: 42,
  author: {
    id: 42,
    email: "alice@prisma.io",
    name: "Alice"
  }
}]
```


Note again that the objects in `postsByAuthorWithAuthorInfo` are fully typed when using TypeScript, so accessing a non-existing property on the `author` of a post, in this case, would throw a compiler error.

#### Working intuitively with relations

Accessing related data (meaning, data from tables that are connected via _foreign keys_) can be especially tricky with existing database tools. This is mostly due to the fundamental mismatch of how these relations are represented in relational databases and object-oriented languages:

- **Relational**:  Data is typically [_normalized_](https://en.wikipedia.org/wiki/Database_normalization) (flat) and uses _foreign keys_ to link across entities. The entities then need to be JOINed to manifest the actual relationships.
- **Object-oriented**: Objects can be _deeply nested structures_ where you can traverse relationships simply by using [dot notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors#Dot_notation).

Prisma Client lets you intuitively read and write nested data:



```ts
const result = await prisma.user.findMany({
  include: { 
    posts: {
      select: {
        id: true,
        title: true
      }
    } 
  }
})
```
```ts
const result = await prisma.user.create({
  data: {
    name: "Alice",
    email: "alice@prisma.io",
    posts: {
      create: {
        title: "Hello World"
      }
    }
  }
})
```
```ts
const result = await prisma.user
  .findOne({ where: { id: 42 }})
  .posts()
```
```ts
const result = await prisma.user
  .findOne({
    where: { email: 'alice@prisma.io' },
  })
  .posts({
    where: {
      title: {
        startsWith: 'Hello',
      },
    },
  })
```


Note again that in all of the above cases, the `result` will be fully typed if you're using TypeScript! 

#### A declarative and human-readable database schema

Reading definitions of tables and other database structures using SQL (e.g. `CREATE TABLE User`, `ALTER TABLE User ADD COLUMN email`) can feel noisy. Prisma introduces a declarative version of your database schema known as the [Prisma schema](https://www.prisma.io/docs/concepts/components/prisma-schema).

The Prisma schema is generated by introspecting your database and serves as the foundation for the query API of Prisma Client. As an example, this is the equivalent version of the [above](#thinking-in-objects-a-natural-and-familiar-query-api) `User` and `Post` definitions:



```prisma
model User {
  id    Int     @default(autoincrement()) @id
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id       Int     @default(autoincrement()) @id
  title    String
  content  String?
  author   User    @relation(fields: [authorId], references: [id])
  authorId Int
}
```
```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name TEXT
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    title VARCHAR(25) NOT NULL,
    content TEXT,
    "authorId" INTEGER NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User"(id)
);
```


> **Note**: We are also working on a tool for _database migrations_ called [Prisma Migrate](https://www.prisma.io/docs/concepts/components/prisma-migrate). With Prisma Migrate, the [introspection-based workflow](https://www.prisma.io/docs/concepts/overview/what-is-prisma#typical-prisma-workflows) is "reversed" and you can map your declarative Prisma schema to the database; Prisma Migrate will generate the required SQL statements and execute them against the database.

#### Auto-completion for database queries

Auto-completion is an immensely powerful feature that enables developers to explore an API in their editors instead of looking up reference docs. Because Prisma Client is generated from _your_ database schema, the query API will feel very familiar to you.

Having auto-completion available largely contributes to greater productivity because you can "learn the API as you use it". Auto-completion also increases confidence because you can be sure that the suggested API operations will work.

{/* <Video src="/blog/announcing-prisma-2-n0v98rzc8br1/imgs/YWeTRfU.mp4" width="740" height="430" /> */}

#### Fully type-safe database queries

Prisma Client guarantees full type-safety for _all_ database queries, even when only a subset of a model's properties are retrieved or relations are loaded using `include`.

Consider again the `User` and `Post` tables from the example before, Prisma generates the following TypeScript types to represent the data from these tables in your application:

```ts
type User = {
  id: number
  email: string
  name: string | null
}

type Post = {
  id: number
  authorId: number | null
  title: string | null
  content: string | null
}
```
Any plain [CRUD](https://www.prisma.io/docs/concepts/components/prisma-client/crud) query sent by Prisma Client will return a response of objects that are typed accordingly. However, consider again the query from above where `include` was used to fetch a relation:



```ts
const postsByAuthorWithAuthorInfo = await prisma.post.findMany({
  where: { 
    author: { id: 42 } 
  },
  include: {
    author: true,
  }
})
```
```js
[{
  id: 1,
  title: "Follow Prisma on Twitter",
  content: null,
  authorId: 42,
  author: {
    id: 42,
    email: "alice@prisma.io",
    name: "Alice"
  }
}, {
  id: 2,
  title: "Join us online for Prisma Day 2020",
  content: null,
  authorId: 42,
  author: {
    id: 42,
    email: "alice@prisma.io",
    name: "Alice"
  }
}]
```


The objects inside `postsByAuthorWithAuthorInfo` don't match the generated `Post` type because they carry the additional `author` object. In that case, Prisma Client still provides full type-safety and is able to statically type the result! Here's what the type looks like:

```ts
const postsByAuthorWithAuthorInfo: (Post & {
    author: User | null;
})[]
```
Thanks to this, the TypeScript compiler will catch cases where you're accessing properties that don't exist. For example, this would be illegal:

```ts
// caught by the TypeScript compiler because `firstName` doesn't exist
postsByAuthorWithAuthorInfo[0].author.firstName
```
#### A single source of truth for database and application models

Database tools often have the problem of needing to _synchronize_ changes that are made to data models between _application code_ and the _database_. For example, after having changed a database table, developers often need to manually adjust the respective model in their application code and scan the codebase for usages of the table to update it.

This makes database schema migrations and code refactorings scary because there's no guarantee the two layers remain in sync after the change!

Prisma Client takes a different approach to this problem. Instead of manually synchronizing changes between application code and database, Prisma Client's query API is _generated_ based on your database schema. 

With that approach, you can simply re-generate Prisma Client after a database schema change and the changes will automatically be synchronized to your Prisma Client query API. Thanks to auto-completion and type-safety, updating your application code to the new queries will be a lot faster than with any other approach.

---

## What you can build with Prisma

The main use case for Prisma is building server-side applications that need to persist data in a database.

Since the Preview phase of Prisma 2.0, we have seen developers build a wide range of applications, from social networking apps to e-commerce shops, to productivity tools and marketplaces. We are excited to see what you're building with Prisma!

<Quotes
  speakerImgLink="/blog/announcing-prisma-2-n0v98rzc8br1/imgs/5YEs4IC.png"
  speakerName="Sean Emmer"
  position="CTO"
  companyLink="https://www.pearlyplan.com/"
  companyName="Pearly"
>

This is the fastest Iâ€™ve developed in my career, by far.
Prisma has dramatically reduced implementation time, while increasing confidence in my code.
Iâ€™ve also been able to say yes to a lot of new incremental features;
it now takes half a day to implement something that used to take two or three.

</Quotes>

### REST, GraphQL, Thrift, gRPC and more

Server-side applications typically expose an _API_ that's consumed by frontend (e.g. web or mobile) or other apps. Prisma Client is compatible with all existing API technologies, such as REST, GraphQL, Thrift, or gRPC.

![REST, GraphQL, Thrift, gRPC and more](/blog/announcing-prisma-2-n0v98rzc8br1/imgs/kPGJU6j.png)

### Prisma works with various deployment models

Prisma Client can be used in traditional monolithic servers, microservice architectures, and serverless deployments. Read the docs page about [deployment](https://www.prisma.io/docs/guides/deployment/deployment) to learn more.

---

## A strong ecosystem growing around Prisma

Despite Prisma's young age, we are very proud and excited about the emerging ecosystem and a variety of tools we see growing around it. 

### The next generation of fullstack frameworks is based on Prisma 

The Node.js ecosystem is known for lots of different frameworks that try to streamline workflows and prescribe certain conventions. We are extremely humbled that many framework authors decide to use Prisma as their data layer of choice.

The new [RedwoodJS](https://redwoodjs.com/) framework by GitHub co-founder [Tom Preston-Werner](https://twitter.com/mojombo) seeks to become the "Ruby on Rails" equivalent for Node.js. RedwoodJS is based on React and GraphQL and comes with a baked-in deployment model for serverless functions.

<br/>
<TweetEmbedComp tweets={['1244877311196856320']} />
<br/>

Another framework with increasing anticipation and excitement in the community is [Blitz.js](http://blitzjs.com/). Blitz is build on top of Next.js and takes a fundamentally different approach compared to Redwood. Its goal is to completely eliminate the API server and ["bring back the simplicity of server rendered frameworks"](https://github.com/blitz-js/blitz/blob/canary/rfc-docs/01-architecture.md#introduction). 

### Build type safe GraphQL servers with Nexus and the Prisma plugin

At Prisma, we're huge fans of GraphQL and believe in its bright future. That's why we founded the [Prisma Labs](https://github.com/prisma-labs/) team which dedicates its time to work on open source tools in the GraphQL ecosystem.

It is currently focused on building [Nexus](https://www.nexusjs.org/#/), a delightful application framework for developing GraphQL servers. As opposed to Redwood, Nexus is a _backend-only_ GraphQL framework and has no opinions on how you access the GraphQL API from the frontend. 

Using the Prisma plugin for Nexus, you can expose Prisma models in your GraphQL API without the overhead of implementing the typical CRUD boilerplate that's needed when connecting GraphQL resolvers to a database.



```prisma
model User {
  id        Int      @default(autoincrement()) @id
  email     String   @unique
  name      String?
  posts     Post[]
}

model Post {
  id         Int     @default(autoincrement()) @id
  title      String
  content    String?
  author     User    @relation(fields: [authorId], references: [id])
  authorId   Int
}
```
```ts
import { schema } from 'nexus'

schema.queryType({
  definition(t) {
    t.crud.user()
    t.crud.users({
      ordering: true,
    })
    t.crud.post()
    t.crud.posts({
      filtering: true,
    })
  },
})

schema.mutationType({
  definition(t) {
    t.crud.createOneUser()
    t.crud.createOnePost()
    t.crud.deleteOneUser()
    t.crud.deleteOnePost()
  },
})

schema.objectType({
  name: 'User',
  definition(t) {
    t.model.id()
    t.model.email()
    t.model.name()
    t.model.posts()
  },
})

schema.objectType({
  name: 'Post',
  definition(t) {
    t.model.id()
    t.model.title()
    t.model.content()
    t.model.author()
  },
})
```
```graphql
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Mutation {
  createOnePost(
    data: PostCreateInput!
  ): Post!
  createOneUser(
    data: UserCreateInput!
  ): User!
  deleteOnePost(
    where: PostWhereUniqueInput!
  ): Post
  deleteOneUser(
    where: UserWhereUniqueInput!
  ): User
}

enum OrderByArg {
  asc
  desc
}

type Post {
  author(
    after: String
    before: String
    first: Int
    last: Int
    skip: Int
  ): [User!]!
  id: ID!
}

input PostCreateInput {
  author: UserCreateManyWithoutAuthorInput
  id: ID
}

input PostCreateManyWithoutPostsInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateWithoutAuthorInput {
  id: ID
}

input PostFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: UserFilter
  id: StringFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  post(
    where: PostWhereUniqueInput!
  ): Post
  posts(
    after: String
    before: String
    first: Int
    last: Int
    skip: Int
    where: PostWhereInput
  ): [Post!]!
  user(
    where: UserWhereUniqueInput!
  ): User
  users(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserOrderByInput
    skip: Int
  ): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  birthDate: DateTime!
  email: String!
  id: ID!
  posts(
    after: String
    before: String
    first: Int
    last: Int
    skip: Int
  ): [Post!]!
}

input UserCreateInput {
  birthDate: DateTime!
  email: String!
  id: ID
  posts: PostCreateManyWithoutPostsInput
}

input UserCreateManyWithoutAuthorInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutPostsInput!]
}

input UserCreateWithoutPostsInput {
  birthDate: DateTime!
  email: String!
  id: ID
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  birthDate: OrderByArg
  email: OrderByArg
  id: OrderByArg
}

input UserWhereInput {
  AND: [UserWhereInput!]
  birthDate: DateTimeFilter
  email: StringFilter
  id: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  posts: PostFilter
}

input UserWhereUniqueInput {
  email: String
  id: ID
}
```


Thanks to that plugin, there's almost no boilerplate needed to expose full CRUD operations, including filters, pagination, and ordering capabilities, for Prisma models. 

---

## Getting started with Prisma

There are various ways for getting started with Prisma:

<br />
{/* <GettingStarted /> */}

---

## A huge thank you to our community ðŸ’š

We've been overwhelmed by the positive response to the Beta release in March and are excited to share today's General Availability with everyone! A huge thank you to everyone who has accompanied us on this journey!

### Share what you are building on Slack and `awesome-prisma`

If you're new to Prisma, we'd love to see you around in our [Slack](https://slack.prisma.io/)! In case you're already using Prisma, let everyone know by posting what you build in the [**`#showcase`**](https://app.slack.com/client/T0MQBS8JG/C565176N6) channel.

We're proud of our community of content creators who created lots of awesome articles and videos about Prisma! For an overview of the best Prisma resources, check out the [**`awesome-prisma`**](https://github.com/catalinmiron/awesome-prisma) repo. And don't forget to create a PR with anything that's missing!

<Accordions type="single">
  <Accordion title="Expand for some Prisma highlights from our community">

A few highlights include:

- an [egghead video series](https://egghead.io/playlists/get-started-with-prisma-v2-prisma-client-8bae) by [Dimitri Ivashchuk](https://twitter.com/DivDev_)
- a [tutorial](https://leerob.io/blog/next-prisma) and [video](https://www.youtube.com/watch?v=wk-dUsLUADg) about using Prisma with Next.js by [Lee Robinson](https://twitter.com/leeerob)
- a [Nest.js starter kit](https://github.com/fivethree-team/nestjs-prisma-starter) by [Marc Julian](https://twitter.com/mrcjln) and [friends](https://github.com/fivethree-team/nestjs-prisma-starter/graphs/contributors)
</Accordion>
</Accordions>

### Join us at Prisma Day on June 25th and 26th for workshops and talks

After the successful premiere last year, we are excited to host another edition of [Prisma Day](https://www.prisma.io/day) on June 25th (workshops) and 26th (talks).

This year, we are going remote and are inviting everyone to join us for amazing talks around modern application development, best practices for database workflows and everything Prisma! 

<br />
{/* <PrismaDay /> */}

