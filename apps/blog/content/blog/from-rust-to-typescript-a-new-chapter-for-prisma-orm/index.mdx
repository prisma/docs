---
title: "From Rust to TypeScript: A New Chapter for Prisma ORM"
slug: "from-rust-to-typescript-a-new-chapter-for-prisma-orm"
date: "2025-01-30"
authors:
  - "Jon Harrell"
metaTitle: "Prisma ORM Architecture Shift: Why We Moved from Rust to TypeScript"
metaDescription: "Why is Prisma ORM switching from Rust to TypeScript? Read the full architectural rationale and what the new Query Compiler means for your app's speed"
metaImagePath: "/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/meta-ded124ddfa8412b0d678ab94a9804127188fde00-1266x711.png"
heroImagePath: "/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/hero-0f2a3395d4395fe407ce7fb6b603bb7c5ff3e460-844x474.svg"
heroImageAlt: "Prisma ORM Architecture Shift: Why We Moved from Rust to TypeScript"
series:
  title: "Prisma ORM: The Complete Rust-to-TypeScript Migration Journey"
  slug: "prisma-orm-the-complete-rust-to-typescript-migration-journey"
seriesIndex: 1
excerpt: |
  The Prisma query engine, written in Rust, has always been a core part of Prisma ORM. It was developed for the future, but is no longer compatible with Prisma ORM’s current direction. Read on to learn more about our rewrite from Rust to TypeScript.
---

## TL;DR: The Rust-Free ORM is ready for production-use

Prisma ORM's core engine has undergone a major shift from the **Rust based query engine** to a leaner **TypeScript/WASM core** (the **Query Compiler**). This [new architecture is now **production-ready** (v6.16+)](https://github.com/prisma/prisma/releases/tag/6.16.0) and fundamentally improves your developer experience (DX) and application performance.

- **No binary overhead:** The dependency on native Rust binaries is eliminated, drastically simplifying deployment and reducing potential complexity issues.
- **Performance:** Get **up to 3.4x faster queries** (by removing cross-language serialization) and a **90% smaller bundle size** (from ~14MB to 1.6 MB).
- **Better support for different runtimes:** Enables better support for deployement environments and runtimes like Cloudflare Workers, Deno, Bun, Vercel Edge and more.

To implement these benefits now, see the [official usage guide for the new Rust-Free ORM](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine). You can also follow the entire development and release history in our **[Prisma ORM: The Complete Rust-to-TypeScript Migration Journey](https://www.prisma.io/blog/series/prisma-orm-the-complete-rust-to-typescript-migration-journey)** blog series.

## Prisma’s doing what now?!

In our [recently released ORM Manifesto](https://www.prisma.io/blog/prisma-orm-manifesto), we described how Prisma ORM will be managed in the coming months and years. One small inclusion was the following tidbit:

> We’re addressing this by migrating Prisma’s core logic from Rust to TypeScript and redesigning the ORM to make customization and extension easier.

This may have been only a sentence in our post, but it has caused quite a few reactions:

<TweetEmbedComp tweets={['1863837970471784924']}/>
For example we really loved this video from Theo:

<p><iframe width="560" height="315" src="/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/vXvfrfqqDbU" title="" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"  allowFullScreen></iframe></p>

All in all, these are pretty reasonable reactions. The Rust query engine has been with Prisma ORM since the beginning. The discussion we have seen online has been great, but we also wanted to step in and provide some updates as our TypeScript implementation approaches Early Access.

In short, we want to let everyone in the community know **what is changing, the motivation behind those changes, and how those changes will be implemented**.

## Why did Prisma choose Rust?

Before we can explore the future of Prisma ORM, we need to understand why Prisma ORM uses a Rust engine. When we started planning Prisma 2 (now known as Prisma ORM), we had a pretty clear vision: we wanted to build ORMs for as many languages as possible—TypeScript, Go, Python, Scala, Rust, and others. We needed a solution that would make adding support for new languages relatively straightforward. Rust’s performance benefits and systems-level approach made it a natural choice for this core query engine. 

This decision was also a continuation of the work done on GraphCool and Prisma 1. The core, deployable infrastructure of these earlier solutions evolved into the Rust-based query engine—a binary designed to handle the heavy lifting of generating SQL queries, managing connection pools, and returning results from your database. This freed up language-specific clients like `prisma-client-js` to remain lightweight layers on top of the engine.

## Why move away from Rust?

While having a powerful Rust engine helped us deliver great performance quickly, we’ve since discovered that it creates some notable challenges:

- **Skillset barriers:** Contributing to the query engine requires a combination of Rust and TypeScript proficiency, reducing the opportunity for community involvement.
- **Deployment complexity:** Each operating system and OpenSSL library version needs its own binary, complicating deployments and slowing down development.
- **Compatibility issues:** Modern JavaScript runtimes, serverless, and edge environments aren’t always compatible with large Rust binaries, limiting how and where Prisma can be deployed.

Additionally, the core benefit of the query engine—the ability to support multiple clients—is no longer our focus. Prisma ORM is a TypeScript project and while we support our community clients, we won’t be developing them in house.

Taking these into account and adding in our commitment to building an inclusive, community-driven ecosystem (as outlined in our [ORM Manifesto](https://www.prisma.io/blog/prisma-orm-manifesto)) has led us to **migrate as many pieces as possible from our Rust query engine to TypeScript**—simplifying contributions and reducing deployment headaches, without sacrificing the developer experience Prisma ORM users know and love.

## Redefining query execution

The major architectural change we’re introducing in Early Access involves moving query execution and database result handling from Rust to TypeScript.

To understand this change, let’s review the current query engine setup.

### Execution of a Prisma ORM query today

Today, there are two ways that you can query a database with Prisma ORM:

- Using a database driver written in *Rust*.
- Using a [driver adapter](https://www.prisma.io/docs/orm/overview/databases/database-drivers#driver-adapters) and driver both written in *TypeScript*.

In the first approach, Prisma ORM queries are passed to the query engine, written in Rust. This engine manages everything from building the query plan to executing queries and returning results to the JavaScript client:

![Prisma ORM communicating with a database](/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/598f7a3ad7506e4515a5b40eead655dcf35c0551-1280x600.png)

However, this architecture cannot support databases that only provide JavaScript drivers, such as D1 and Turso. To address this limitation, we introduced driver adapters.

When using a driver adapter, the query engine still develops the query plan and generates SQL statements. The execution, however, is delegated through the driver adapter to the database:

![Prisma ORM communicating with a database via a driver adapter.](/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/c63df7c781f89520601e5a727a48e01b07475569-1280x889.png)

This approach enables compatibility with JavaScript drivers but introduces a tradeoff: data must be serialized from JavaScript to Rust and then back to JavaScript, reducing efficiency and negating some of the benefits of this method.

### Execution of a Prisma ORM query tomorrow

In the new architecture, driver adapters will remain in use. However, instead of relying on a Rust-based query engine, Prisma ORM will pass the query to a WASM compiler, which will return the query plan. This plan will then be **executed entirely in TypeScript**:

![Prisma ORM communicating with a database in the query compiler project](/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm/imgs/1a90825c7f7897d07fa9422a4c9a2415befb0a80-1480x695.png)

This simplified architecture delivers several immediate benefits:

- Retains support for proven JavaScript database drivers.
- Reduces the need for data translation between JavaScript and Rust.
- Minimizes the volume of data transferred between Rust and JavaScript.
- **Eliminates the need to ship an external binary**, as the query compiler no longer depends on system-specific utilities.

By shifting query execution to TypeScript, we streamline the architecture and enhance compatibility and performance for developers.

## A streamlined experience coming soon

Moving logic across languages is a significant transformation, but we’re approaching it gradually to minimize disruption. While these changes are substantial, our priority is ensuring a smooth transition that maintains the simplicity and reliability you expect from Prisma. In this migration we’re not just addressing today’s challenges but also laying the foundation for an enhanced developer experience.

### Steps toward a smooth transition

Our engineering team is incrementally transitioning query engine logic into the TypeScript side of the codebase. Components that cannot yet be moved are being re-packaged into a WASM file included in the `@prisma/client` npm module. This WASM file functions as the query compiler, simplifying workflows without significant API changes.

For instance, we plan to remove the requirement for `binaryTargets`, further streamlining the developer experience. Overall, **the Prisma ORM experience will remain familiar and intuitive**.

### Unlocking future opportunities

This transition isn’t just about addressing current challenges—it creates new opportunities for innovation. In fact, the query compiler enables many possibilities for our team and the community to explore. For example, the use of parameterized query plans could allow for **saving query plans for re-use** to speed up execution. Another avenue would be to build the initial query plans *at compile time*, further reducing runtime computation needs. 

We’re excited about these possibilities and eager to hear your thoughts! Join the discussion on our GitHub or Discord.

### TL;DR: The Rust-Free ORM is ready for production-use

## Help us build a better Prisma ORM experience

This project is a significant step toward making Prisma ORM better for everyone. At its core, Prisma ORM is built for developers like you. Your feedback and collaboration are crucial to this journey.

Here’s how you can help:

- [File issues](https://github.com/prisma/prisma/issues/new/choose) to report bugs or suggest features.
- [Use discussions](https://github.com/prisma/prisma/discussions) to share your ideas.
- [Join our Discord](https://pris.ly/discord) to participate in community events and dev AMAs.

Finally, test our Early Access client! We’ll share updates on GitHub and Discord.

This is an exciting time for Prisma, with even more improvements and opportunities ahead. Thank you for inspiring us to grow and for being part of this journey.

*Want to be among the first to try our new Early Access client? [Follow us on X](https://pris.ly/x) and [join our Discord](https://pris.ly/discord) to stay updated.*

## Frequently Asked Questions (FAQ)

The [Rust binary-free version](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine) of Prisma ORM is ready for production use as of [Prisma ORM version 6.16](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine?utm_source=chatgpt.com), and here are some common FAQs from our users:

### How much smaller is Prisma’s bundle without the Rust engine, and why does that help with cold starts?

When Prisma removed the Rust binary query engine, the bundle size dropped from about **14 MB (7 MB gzipped)** to around **1.6 MB (600 KB gzipped)**, which is an **85 to 90 percent reduction**.

This smaller bundle loads faster in serverless and edge environments such as [AWS Lambda](https://aws.amazon.com/lambda/), [Cloudflare Workers](https://workers.cloudflare.com/), and [Vercel Edge Functions](https://vercel.com/features/edge-functions).

Because less code needs to load and initialize, cold starts become faster and memory usage decreases.

### How much faster are queries with the Rust binary-free Prisma ORM compared to the old Rust engine?

In internal benchmarks, the Rust binary-free version of Prisma ORM, also called the **Query Compiler**, delivers significant performance improvements:

- `findMany` with 25,000 records improved from **185 ms to 55 ms** (about **3.4 times faster**)
- `findMany` with take = 2000 improved from **6.6 ms to 3.1 ms** (about **2.1 times faster**)
- Complex joins improved from **207 ms to 130 ms** (about **1.6 times faster**)

You can read more in the [Rust to TypeScript performance update blog](https://www.prisma.io/blog/rust-to-typescript-update-boosting-prisma-orm-performance?utm_source=chatgpt.com).

These improvements are most noticeable on large or complex queries.

### Will the Rust binary-free Prisma ORM work in runtimes like Cloudflare, Deno, and Bun?

Yes. Because Prisma’s new engine runs entirely in TypeScript and WebAssembly, it no longer depends on a native binary.

You can now use Prisma in environments that support JavaScript or WASM, such as [Cloudflare Workers](https://developers.cloudflare.com/workers/), [Bun](https://bun.sh/), and [Deno](https://deno.com/).

To enable it, use the new `prisma-client` generator and configure the correct driver adapter for your database, for example `@prisma/adapter-pg` for PostgreSQL.

See the [Prisma Client generator documentation](https://www.prisma.io/docs/orm/prisma-schema/overview/generators#prisma-client?utm_source=chatgpt.com) for setup instructions.

### If Rust is already fast, why does switching to TypeScript and WebAssembly make Prisma faster?

Rust is a very fast systems language, but in the old architecture Prisma had to serialize and deserialize data between Rust and JavaScript.

That cross-language communication added overhead, especially for large queries.

The new Query Compiler runs in TypeScript and WebAssembly, which removes the need for this serialization step and results in faster query execution.

You can learn more about the change in [From Rust to TypeScript: A New Chapter for Prisma ORM](https://www.prisma.io/blog/from-rust-to-typescript-a-new-chapter-for-prisma-orm?utm_source=chatgpt.com).

### What changes are needed to use the Rust binary-free Prisma ORM?

To migrate to the new version:

1. Use the new `prisma-client` generator and set `engineType = "client"` in your `schema.prisma` file
2. Remove the `binaryTargets` configuration (it is no longer required)
3. Install the appropriate driver adapter for your database, such as `@prisma/adapter-pg` for PostgreSQL or `@prisma/adapter-sqlite` for SQLite
4. Run `npx prisma generate` to regenerate your Prisma Client

You can follow the full usage guide in the [Prisma documentation for the Rust binary-free ORM](https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/no-rust-engine?utm_source=chatgpt.com).

### Can I switch back to the Rust engine if needed?

Yes. If you encounter compatibility issues, you can temporarily revert to the legacy Rust engine by using an older Prisma ORM version before `6.16.0`.

However, the Rust binary-free engine is now the default moving forward and is recommended for all new projects.

Migration steps and fallback guidance are available in the [Rust-free Prisma ORM production release blog](https://www.prisma.io/blog/rust-free-prisma-orm-is-ready-for-production?utm_source=chatgpt.com).
