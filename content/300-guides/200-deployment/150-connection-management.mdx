---
title: Connection management
tocDepth: 2
---

<TopBlock>

Databases have a limit on the number of open connections they can handle. A higher connection limit allows more processes to connect. However, this comes with a significant performance cost on the database side. Moreover, many databases recommended not overpassing a certain connection number. Several approaches can be used to mitigate such problems. Choosing the right approach depends on the deployment paradigm.

</TopBlock>

## Long-running processes (PaaS)

Configure limit
SINGLE INSTANCE of `PrismaClient`

### Connection limits

## Serverless environments (FaaS)

### Connection limits

It's recommended to set the connection limit to 1 if you're not using an external connection pooler because each incoming request starts a short-lived Node.js process. This can cause the database connection pool to be quickly exhausted from a short spike in user traffic.

* 

### Connection pooling

### Scenario:


Connection management in serverless environments complicated. Consider following scenario:

1. You have a function that does one thing - gets the top `n` blog posts: `getDashboard`:

```ts
import { PrismaClient, Prisma } from '@prisma/client'

const client = new PrismaClient()

export async function handler() {

  const topBlogPosts = client.posts.findMany({
      take: 10,
      orderBy: {
          created: "desc"
      }
  })

  const topUsers = client.user.findMany({
      take: 10,
      orderBy: {
          posts: {
              count: "desc"
          }
      }
  })  

  let data = await Promise.all(topUsers, blogPosts);

  return {
    data
  }
}
```

Notice two things about this function:

* Instantiates `PrismaClient` outside scope of handler (default pool size is X) - as long as the handler remains 'warm' (in use), the connection is reusable:

  ```ts highlight=3;normal
    import { PrismaClient, Prisma } from '@prisma/client'

    const client = new PrismaClient()

    export async function handler() {
        /* ... */
    }
  ```
* Does not explicitly disconnect - we're expecting this function to run frequently and for the handler to remain 'warm', and don't want to use the resources connecting and disconnect each time we run the function.

1. Request comes in - one lambda spins up to handle the request: by default, pool size is 1 + CPU *2 - so five
1. Suddenly traffic spikes - 10x 

    
     
2. Suddenly you have a traffic spike - suddenly 40 lambdas, each opening 1 connection => 40 connections
3. Gets worse - 

Might solve this by:

* Implementing connection pooling (e.g. pgBouncer)

Depends on scenario.

This is a great place for
`PrismaClient` to call `connect` or at least call `PrismaClient` constructor so that subsequent invocations can share a connection. 

Typically, any piece of code [outside the handler](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-features.html#gettingstarted-features-programmingmodel) remains initialized. 

* Connection limit to `1`
* Use a connection pooler


### Option 1: Set connection limit to 1

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

  ```
  postgresql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=1
  ```

</tab>
<tab>

  ```
  mysql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=1
  ```

</tab>
</TabbedContent>

1. Serverless function receives request
1. Creates an instance of `PrismaClient`, which creates a pool with `1` connection
1. Does whatever it needs to do
1. Closes connection (`.$disconnect()`)

Scenario: I have 20 serverless functions that connect to the database a looooot

Goal: I don't want to exhaust the database, but I don't necessarily want to connect/disconnect from the database every single time either

Suggested steps:

* Initialize PrismaClient *outside the specific serverless function* because I want to keep the connection open - the handler is going run again and again and again
* No need to disconnect explicitly
* To make sure you don't exhaust the db connection pool, try: a) setting the connection limit to 1.

### Option 2: Use a connection pooler

### Special considerations

There are some implications though that are not directly related to Prisma Client JS but any system that would require a DB connection from serverless environment:

#### Container reuse

t is not guaranteed that subsequent nearby invocations of a function will hit the same container. AWS can choose to create a new container at any time. 

Code should assume the container to be stateless and create a connection only if it does not exist. Prisma Client JS already implements that logic.

#### Zombie connections

| Zombie connections                  | The containers that are marked to be removed and are not being reused still keep a connection open and can stay in that state for some time (unknown and not documented from AWS), this can lead to sub-optimal utilization of the DB connections | One potential solution is to use a lower idle connection timeout. Another solution can be to clean up the idle connections in a separate service<sup>1, 2</sup>.         |


#### Database connection pool exhaustion

| Database connection pool exhaustion | Concurrent requests create multiple new connections to the database thereby exhausting the database's connection limit.                                                                                                                            | Add a connection pooler, e.g. [PgBouncer](#pgbouncer) or limiting the serverless function concurrency to a number lower than the database's connection limit. |

<br />
<sup>
  1. Note that these are recommendations and not best practices. These would vary from system to
  system.
</sup>
<br />
<sup>
  2.{' '}
  <a href="https://github.com/jeremydaly/serverless-mysql">
    <inlineCode>serverless-mysql</inlineCode>
  </a>{' '}
  is a library that implements this idea.
</sup>

Note that depending on your serverless concurrency limit (the number of serverless functions running), you might still exhaust your database's connection limit. This can happen when too many functions are invoked concurrently (i.e. the number of concurrent Lambdas that each hold a DB connection exceeds the connection limit of your database). To prevent this, [set your serverless concurrency limit](https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html) to a number lower than the connection limit of your database (as you might want to be able to connect from another client for other purposes).


## Database connection limit

Databases have a limit on the number of open connections they can handle.
A higher connection limit allows more processes to connect. However, this comes with a significant performance cost on the database side. Moreover, many databases recommended not overpassing a certain connection number.
Several approaches can be used to mitigate such problems.
Choosing the right approach depends on the deployment paradigm.

From a high level, the following approaches can prevent database connection issues:

- Limiting the connection pool of the query engine with the database as described in [connection management](../../../concepts/components/prisma-client/working-with-prismaclient/connection-management#connection-pool)
- Using an external connection pooler like [PgBouncer](https://www.pgbouncer.org/).

Both approaches prevent exhausting the connection limit of the database.

### Setting the connection limit of the Prisma query engine

When the Prisma Client connects to the database, the [query engine](../../../concepts/components/prisma-client/query-engine) immediately creates a connection pool with the number of connections that were specified as the `connection_limit` parameter in your database connection URL.

For example, with the following `datasource` configuration in your Prisma schema the connection pool will have exactly five connections:

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5"
}
```

If the connection_limit argument is omitted, the default number of connections is calculated according to this formula: `num_physical_cpus * 2 + 1` where `num_physical_cpus` represents the number of physical CPUs on your machine.

```prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb"
}
```

If your machine has four physical CPUs, your connection pool will contain nine connections (4 \* 2 + 1 = 9).

### Recommended connection limit

#### Long running process (PaaS)

It's recommended to use the default of `num_physical_cpus * 2 + 1`. That number should be multiplied by the number of application instances to ensure it's under the database's limit. For example if your database's connection limit is _10_ and you have _two_ instances of your app, the connection limit should be no more than _5_.

#### Serverless (FaaS)



## Connectiong pooling

### PgBouncer

PostgreSQL supports only a certain amount of concurrent connections, and this limit can be reached quite fast when the service usage goes up – especially in serverless environments.

A connection pooler like PgBouncer prevents your application from exhausting the database's connection limit.

PgBouncer holds a connection pool to the database and proxies incoming client connections by sitting between Prisma Client and the database. This reduces the number of processes a database has to handle at any given time. PgBouncer passes on a limited number of connections to the database and queues additional connections for delivery when space becomes available.

To use Prisma Client with PgBouncer from a serverless function, add the `?pgbouncer=true` flag to the PostgreSQL connection string:

```
postgresql://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true
```

Additionally, for Prisma Client to work reliably, PgBouncer must run in [**Transaction mode**](https://www.pgbouncer.org/features.html).

_Transaction mode_ offers a connection for every transaction – a requirement for the Prisma query engine to work with PgBouncer.

<details>
  <summary>How `pgbouncer` mode works in Prisma</summary>

- Prisma cleans up already present prepared statements in the connection by running `DEALLOCATE ALL` before preparing and executing Prisma Client queries.
- Prisma opens a transaction for every query case – even when just reading data, allowing Prisma to use prepared statements.

</details>