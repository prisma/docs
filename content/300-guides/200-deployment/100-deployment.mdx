---
title: 'Deployment overview'
metaTitle: 'Deploying projects using Prisma to the cloud'
metaDescription: 'Learn more about the different deployment paradigms for Node.js and TypeScript applications and how they affect deploying an application using Prisma Client.'
tocDepth: 2
---

<TopBlock>

Projects using Prisma Client can be deployed to many different cloud platforms. Given the variety of cloud platforms and different names, it's noteworthy to mention the different deployment paradigms, as they affect the way you deploy an application using Prisma Client.

</TopBlock>

## Deployment paradigms

Each paradigm has different tradeoffs that affect the performance, scalability, and operational costs of your application.

Moreover, the user traffic pattern of your application is also an important factor to consider. For example, any application with consistent user traffic may be better suited for a continuously running paradigm, whereas an application with sudden spikes may be better suited for serverless.

Here are two common deployment paradigms for a Node.js based project:

### Long-running process (PaaS)

Your Node.js process is continuously running and handles multiple requests. Your application can be deployed to a Platform-as-a-Service like Heroku, as a Docker container to Kubernetes, or as a Node.js process on a virtual machine.

### Serverless (FaaS)

Node.js processes of your application (or subsets of it broken into functions) are started as requests come in.

Serverless environments have the concept of warm starts, which means that for subsequent invocations of the same function, it may use an already existing container that has the allocated processes, memory, file system (`/tmp` is writable on AWS Lambda), and even DB connection still available.

Typically, any piece of code [outside the handler](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-features.html#gettingstarted-features-programmingmodel) remains initialized.

```json
[]
```

## Deploying database changes with Prisma Migrate

To apply pending migrations to development, staging, or testing environments, run the `migrate deploy` command as part of your CI/CD pipeline:

```terminal
prisma migrate deploy
```

Exactly when to run `prisma migrate deploy` depends on your platform. For example, a simplified [Heroku](deploying-to-heroku) workflow includes:

1. Ensuring the `./prisma/migration` folder is in source control
2. Running `prisma migrate deploy` during the [release phase](https://devcenter.heroku.com/articles/release-phase)

Ideally, `migrate deploy` should be part of an automated CI/CD pipeline, and we do not generally recommend running this command locally to deploy changes to a production database (for example, by temporarily changing the `DATABASE_URL` environment variable). It is not genreally considered good practice to store the production database URL locally.

Beware that in order to run the `prisma migrate deploy` command, you need access the `prisma` dependency that is typically added to the `devDependencies`. Some platforms like Vercel, prune development dependencies during the build, thereby preventing you from calling the command. This can be worked around by making the `prisma` a production dependency, by moving it to `dependencies` in your `package.json`.
For more information about the `migrate deploy` command, see:

- [`migrate deploy` reference](../../../reference/api-reference/command-reference#migrate-deploy) <span class="api"></span>
- [How `migrate deploy` works](../../../concepts/components/prisma-migrate##production-and-testing-environments) <span class="concept"></span>
- [Production troubleshooting](production-troubleshooting)

## Query engine binary

Prisma Client depends on the [query engine](../../../concepts/components/prisma-client/query-engine) that is running as a binary on the same host as your application.

The query engine is implemented in Rust and is used by Prisma in the form of executable binary files. The binary is downloaded when `prisma generate` is called. If the call happens on a different environment when deploying your Prisma-based application to production, you need to ensure that the `binaryTarget` in the Prisma schema is compatible with your production environment as described in [binary targets](/reference/api-reference/prisma-schema-reference#binarytargets-options).

## AWS RDS Proxy

<!-- NOTE: Move to platform overview, link to connection management -->

Prisma is compatible with AWS RDS Proxy. However, there is no benefit in using it for connection pooling with Prisma due to the way RDS Proxy pins connections:

> "Your connections to the proxy can enter a state known as pinning. When a connection is pinned, each later transaction uses the same underlying database connection until the session ends. Other client connections also can't reuse that database connection until the session ends. The session ends when the client connection is dropped." - <a href="https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/rds-proxy.html">AWS RDS Proxy Docs</a>

Prepared statements (of any size) or query statements greater than 16 KB cause RDS Proxy to pin the session. Because Prisma uses prepared statements for all queries, you won't see any benefit when using RDS Proxy with Prisma.

## AWS Elastic Beanstalk

<!-- NOTE: Move to platform overview -->

AWS Elastic Beanstalk is a PaaS-like deployment service that abstracts away infrastructure and allows you to deploy applications to AWS quickly.

When deploying an app using Prisma Client to AWS Elastic Beanstalk, Prisma generates the Prisma Client code into `node_modules`. This is typically done in the `postinstall` hook.

Because Beanstalk limits the ability to write to the filesystem in the `postinstall` hook, you need to create an [`.npmrc`](https://docs.npmjs.com/cli/v6/configuring-npm/npmrc) file in the root of your project and add the following configuration:

```config file=.npmrc
unsafe-perm=true
```

Enabling `unsafe-perm` forces _npm_ to run as _root_, avoiding the filesystem access problem, thereby allowing the `prisma generate` command in the `postinstall` hook to generate code into `node_modules`.
