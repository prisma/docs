---
title: 'Metrics'
metaTitle: 'Metrics'
metaDescription: 'Diagnose application performance with insights into Prisma Client database activity'
tocDepth: 3
---

<TopBlock>

Prisma metrics give you a detailed insight into how Prisma Client interacts with your database. You can use this insight to help diagnose performance issues with your application. If you send the data to an external metrics system, then you can view the data over time. For example, you might visualize how your application's number of idle and active connections change.

</TopBlock>

## About metrics

Metrics provide information on the following aspects of Prisma Client:

- The number of Prisma operations

  A Prisma operation is a statement like `let user = prisma.user(include: {posts: true}})`, which Prisma Client translates into one or more SQL queries.

- Query response times
- Active transactions
- Connection pool information

You can export metrics in JSON or Prometheus formats and view them in a console log, or integrate them into an external metrics system, such as StatsD or Prometheus. If you integrate them into an external metrics system, then you can view the metrics data over time, for example to help diagnose changes in your application's performance.

We provide the following metrics:

- Counters (always increase):

  - `query_total_queries`: The total number of database queries executed.
  - `query_total_operations`: The total number of operations executed.

    This can be less than `query_total_queries`, because some operations create multiple queries.

- Gauges (can increase or decrease):
  - `pool_active_connections`: The number of active connections in use.
  - `pool_idle_connections`: The number of connections that are not being used.
  - `pool_wait_count`: The number of workers waiting for a connection.
  - `query_active_transactions`: The number of active transactions.
- Histograms (distributions of values categorized into "buckets"):
  - `pool_wait_duration_ms`: The wait time for a worker to get a connection.
  - `query_total_elapsed_time_ms`: The execution time for all database queries executed.
  - `query_operation_total_elapsed_time_ms`: The execution time for all operations.

You can group your metrics data with [global labels](#global-labels).

## Get metrics in JSON format

When you get metrics in JSON format, you can use them as returned, or [send them to StatSD](#use-prisma-metrics-with-statsd).

To get metrics in JSON format, add the following lines to your application code:

```ts
let metrics = await prisma.$metrics.json()
console.log(metrics)
```

This returns metrics as follows:

```json
{
  "counters": [
    {
      "key": "query_total_operations",
      "labels": {},
      "value": 0,
      "description": "The total number of operations executed"
    },
    {
      "key": "query_total_queries",
      "labels": {},
      "value": 0,
      "description": "The total number of queries executed"
    }
  ],
  "gauges": [
    {
      "key": "pool_active_connections",
      "labels": {},
      "value": 0,
      "description": "The number of active connections in use"
    },
    {
      "key": "pool_idle_connections",
      "labels": {},
      "value": 21,
      "description": "The number of connections that are not being used"
    },
    {
      "key": "pool_wait_count",
      "labels": {},
      "value": 0,
      "description": "The number of workers waiting for a connection"
    },
    {
      "key": "query_active_transactions",
      "labels": {},
      "value": 0,
      "description": "The number of active transactions"
    }
  ],
  "histograms": [
    {
      "key": "pool_wait_duration_ms",
      "labels": {},
      "value": {
        "buckets": [
          [0, 0],
          [1, 0],
          [5, 0],
          [10, 0],
          [50, 0],
          [100, 0],
          [500, 0],
          [1000, 0],
          [5000, 0],
          [50000, 0]
        ],
        "sum": 0,
        "count": 0
      },
      "description": "The wait time for a worker to get a connection."
    }
  ]
}
```

### Use Prisma metrics with StatsD

You can send JSON-formatted metrics to StatsD to visualize your metrics data over time.

<Admonition type="info">
  Note: When you send data to StatsD, you must send Prisma counter and gauge
  metrics as gauge data. This is because StatsD expects counter metrics to be a
  series of incremented or decremented values, but Prisma counter metrics return
  actual values.
</Admonition>

In the following example, we send metrics to StatsD every 10 seconds. This is aligned with the default 10s flush rate of StatsD.

**!!!code needed**

## Get metrics in Prometheus format

When you get Prisma metrics in Prometheus format, you can use them as returned, or [send them to the Prometheus metrics system](#use-prisma-metrics-with-the-prometheus-metrics-system).

To get Metrics in a Prometheus format, add the following lines to your application code:

```ts
let metrics = prisma.$metrics.prometheus()
console.log(metrics)
```

This returns metrics as follows:

```c
# HELP query_total_operations The total number of operations executed

# TYPE query_total_operations counter

query_total_operations 0

# HELP query_total_queries The total number of queries executed

# TYPE query_total_queries counter

query_total_queries 0

# HELP pool_active_connections The number of active connections in use

# TYPE pool_active_connections gauge

pool_active_connections 0

# HELP pool_idle_connections The number of connections that are not being used

# TYPE pool_idle_connections gauge

pool_idle_connections 21

# HELP pool_wait_count The number of workers waiting for a connection

# TYPE pool_wait_count gauge

pool_wait_count

# HELP query_active_transactions The number of active transactions

# TYPE query_active_transactions gauge

query_active_transactions

# HELP pool_wait_duration_ms The wait time for a worker to get a connection.

# TYPE pool_wait_duration_ms histogram

pool_wait_duration_ms_bucket{le="0"} 0
pool_wait_duration_ms_bucket{le="1"} 1
pool_wait_duration_ms_bucket{le="5"} 1
pool_wait_duration_ms_bucket{le="10"} 1
pool_wait_duration_ms_bucket{le="50"} 1
pool_wait_duration_ms_bucket{le="100"} 1
pool_wait_duration_ms_bucket{le="500"} 1
pool_wait_duration_ms_bucket{le="1000"} 1
pool_wait_duration_ms_bucket{le="5000"} 1
pool_wait_duration_ms_bucket{le="50000"} 1
pool_wait_duration_ms_bucket{le="+Inf"} 1
pool_wait_duration_ms_sum 0.050875000000000004
pool_wait_duration_ms_count 1
```

### Use Prisma metrics with the Prometheus metrics system

In the majority of cases, Prometheus must scrape an endpoint to get metrics. Example with `Express.js`:

```javascript
import { PrismaClient } from "@prisma/client";
import express, { Request, Response } from "express";

const app = express();
const port = 4000;
const prisma = new PrismaClient();

app.get("/metrics", async (\_req, res: Response) => {
let metrics = await prisma.$metrics.prometheus();
res.end(metrics);
});

app.listen(port, () => {
console.log(`Example app listening on port ${port}`);
})

Combining it with another Prometheus client library:
import { PrismaClient } from "@prisma/client";
import express, { Request, Response } from "express";
import prom from "prom-client";

let registry = new prom.Registry();
const app = express();
const port = 4000;
const prisma = new PrismaClient();

app.get("/metrics", async (\_req, res: Response) => {
let prismaMetrics = await prisma.$metrics.prometheus();
let appMetrics = await registry.metrics();
res.end(prismaMetrics + appMetrics);
});

app.listen(port, () => {
console.log(`Example app listening on port ${port}`);
});
```

## Global labels

You can group your metrics data with global labels. For example, if you have multiple servers running Prisma Client, you can use labels like `{server: "us-server1", "app_version": "1"}` to view metrics at a server level. Global labels work with JSON and Prometheus-formatted metrics.

For example:

```ts
let metrics = prisma.$metrics.json({ global: 'label', app: 'one' })
console.log(metrics)
```

This returns information in the following format:

```json
{
  "counters": [
    {
      "key": "query_total_operations",
      "labels": { "global": "label", "app": "one" },
      "value": 0,
      "description": "The total number of operations executed"
    },
    {
      "key": "query_total_queries",
      "labels": { "global": "label", "app": "one" },
      "value": 0,
      "description": "The total number of queries executed"
    }
  ],
  "gauges": [
    {
      "key": "pool_active_connections",
      "labels": { "global": "label", "app": "one" },
      "value": 0,
      "description": "The number of active connections in use"
    },
    {
      "key": "pool_idle_connections",
      "labels": { "global": "label", "app": "one" },
      "value": 21,
      "description": "The number of connections that are not being used"
    },
    {
      "key": "pool_wait_count",
      "labels": { "global": "label", "app": "one" },
      "value": 0,
      "description": "The number of workers waiting for a connection"
    },
    {
      "key": "query_active_transactions",
      "labels": { "global": "label", "app": "one" },
      "value": 0,
      "description": "The number of active transactions"
    }
  ],
  "histograms": [
    {
      "key": "pool_wait_duration_ms",
      "labels": { "global": "label", "app": "one" },
      "value": {
        "buckets": [
          [0, 0],
          [1, 0],
          [5, 0],
          [10, 0],
          [50, 0],
          [100, 0],
          [500, 0],
          [1000, 0],
          [5000, 0],
          [50000, 0]
        ],
        "sum": 0,
        "count": 0
      },
      "description": "The wait time for a worker to get a connection."
    }
  ]
}
```
