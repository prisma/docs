---
title: 'Upgrade to Prisma 4'
metaTitle: 'Upgrade to Prisma 4'
metaDescription: 'Guides on how to upgrade to Prisma 4'
tocDepth: 2
toc: true
---

<TopBlock>

Prisma 4 introduces a number of **breaking changes** when you upgrade from any Prisma 3 version (`3.x.x`). This guide explains how this upgrade might affect your application and gives instructions on how to handle any changes.

</TopBlock>

## Breaking changes

This section gives an overview of breaking changes in Prisma 4.

### Node.js minimum version change

From v4.0.0, the minimum version of Node.js that we support is 14.x. If you use an earlier version of Node.js, you will need to update it.

See our [system requirements](/reference/system-requirements) for all minimum version requirements.

### Raw query type mapping: scalar values are now deserialized as their correct JavaScript types

In v3.14.x and v.3.15.x, [raw query type mapping](/concepts/components/prisma-client/raw-database-access#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In v4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in v4.0.0 or later.

Raw queries now deserialize scalar values to their corresponding JavaScript types. Note that Prisma infers types from the values themselves and not from the Prisma Schema types.

Example query and response:

```ts
const res =
  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM "Table";`
console.log(res) // [{ bigint: BigInt("123"), bytes: Buffer.from([1, 2]), decimal: new Prisma.Decimal("12.34"), date: Date("<some_date>") }]
```

#### Upgrade path

From v4.0.0, some data types returned by `queryRaw` or `queryRawUnsafe` are different, as follows:

| Data type  | Before v4.0.0         | From v4.0.0           |
| ---------- | --------------------- | --------------------- |
| `DateTime` | Returned as `String`  | Returned as `Date`    |
| `Numeric`  | Returned as `Float`   | Returned as `Decimal` |
| `Bytes`    | Returned as `String`  | Returned as `Buffer`  |
| `Int64`    | Returned as `Integer` | Returned as `BigInt`  |

If you use `queryRaw` or `queryRawUnsafe` to return any of the above data types, then you must change your code to handle the new types.

For example, if you return `DateTime` data, then you need to take into account the following:

- You no longer need to manually instantiate a `DateTime` object for the returned data.
- If your code currently uses the returned `String` data, then you now need to convert the `DateTime` object to a `String`.

You must make equivalent code changes for the other data types in the table above.

#### Raw query mapping: PostgreSQL type-casts

In v3.14.x and v.3.15.x, [raw query type mapping](/concepts/components/prisma-client/raw-database-access#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In v4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in v4.0.0 or later.

Before v4.0.0, many PostgreSQL type-casts did not work. We have tightened the type coercion rules so that all type-casts now work. As a result, some implicit casts now fail.

#### Upgrade path

We recommend that you re-test your use of `$queryRaw` to ensure that the types you pass into your raw queries match the types that PostgreSQL expects.

For example, in v4.0.0, the following query fails:

```js
await prisma.$queryRaw`select length(${42});
  // ERROR: function length(integer) does not exist
  // HINT: No function matches the given name and argument types. You might need to add explicit type casts.
```

This is because PostgreSQLâ€™s `length` function expects `text` as input. Prisma used to silently coerce `42` to `text`, but does not do this in v4.0.0. To fix this, explicitly cast `42`to `text` as follows:

```js
await prisma.$queryRaw`select length(${42}::text);
```

### <inlineCode>DbNull</inlineCode>, <inlineCode>JsonNull</inlineCode> and <inlineCode>AnyNull</inlineCode> are now objects

JavaScript `null` is ambiguous for JSON columns, so Prisma uses `DbNull`, `JsonNull`, and `AnyNull` to distinguish between the database `NULL` value and the JSON `null` value. Before v4.0.0, `DbNull`, `JsonNull`, and `AnyNull` were string constants. From v4.0.0, they are objects.

See [Filtering by null values](/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values) for more information.

#### Upgrade path

1. If you use literal strings to address these values, then you must replace them with the following named constants:

   - `DbNull`: replace with `Prisma.DbNull`
   - `JsonNull`: replace with `Prisma.JsonNull`
   - `AnyNull`: replace with `Prisma.AnyNull`

   If you already use these named constants, then you do not need to take any action.

1. If you now get a type error when you pass `Prisma.DbNull` as the value of a JSON field, then this probably indicates a bug in your code that our types did not catch before v4.0.0. The field where you tried to store `DbNull` is probably not nullable in your schema. As a result, a literal `DbNull` string was stored in the database instead of `NULL`.
1. You might now encounter a type error or runtime validation error when you use `Prisma.DbNull`, `Prisma.JsonNull`, or `Prisma.AnyNull` with MongoDB. This was never valid, but was silently accepted prior to Prisma 4. You need to review your data and change these fields to `null`.
1. If you pass in dynamic JSON to a JSON column in Prisma Client (for example `prisma.findMany({where: { jsonColumn: someJson } })`), then you must check that `someJson`cannot be the string "DBNull", "JsonNull", or "AnyNull". If it is any of these values, then the query will return different results in v4.0.0.

### Default composite types in MongoDB

From v4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.

Conditions:

- The composite type is required, and
- The composite type has a default value, and
- The composite type is not present in the returned document or documents.

This behavior is now consistent with the behavior for model fields.

To learn more, see [Default values on required composite types](/concepts/components/prisma-client/composite-types#default-values-on-required-composite-types).

#### Upgrade path

If you currently rely on a return value of `undefined`, then you need to refactor your code to handle the default value that is now returned in Prisma 4.

### Rounding errors on big numbers in SQLite

SQLite is a loosely-typed database. If your schema has a field with type `Int`, then Prisma prevents you from inserting a value larger than an integer. However, nothing prevents the database from directly accepting a bigger number. These manually-inserted big numbers cause rounding errors when queried.

To avoid this problem, Prisma v4.0.0 and later checks numbers on the way out of the database to verify that they fit within the boundaries of an integer. If a number does not fit, then Prisma throws a P2023 error, such as:

```
Inconsistent column data: Conversion failed:
Value 9223372036854775807 does not fit in an INT column,
try migrating the 'int' column type to BIGINT
```

#### Upgrade path

If you use Prisma in conjunction with SQLite, then you need to find any code that queries `Int` fields and ensure that it handles any P2023 errors that might be returned.

### Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client

From v4.0.0, Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client. This makes the generated Prisma Client much more efficient, and also avoids some memory leaks if you use Jest to carry out tests.

Note:

- This change does not affect the DMMF that Prisma passes to the generators.
- You can use `getDmmf()`from `@prisma/internals`to access the schema property.
- We still export `Prisma.dmmf.datamodel` into the generated Prisma Client.

### Index configuration

In Prisma 4, the `extendedIndexes` Preview feature will now become generally available. This includes the following index configuration options:

- Length configuration of indexes, unique constraints and primary key constraints for MySQL (in Preview in versions `3.5.0` and later)
- Sort order configuration of indexes, unique constraints and primary key constraints (in Preview in versions `3.5.0` and later)
- New index types for PostgreSQL: Hash (in Preview in versions `3.6.0` and later) and GIN, GiST, SP-GiST and BRIN (in Preview in versions `3.14.0` and later)
- Index clustering for SQL Server (in Preview in versions `3.13.0` and later)

See our documentation on [Index configuration](/concepts/components/prisma-schema/indexes#index-configuration) for more details of these features.

#### Upgrade path

These can all be breaking changes if you were previously configuring these properties at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you may lose any configuration that was defined in the database but not previously represented in the Prisma schema.

For more details, see the [Upgrading from previous versions](/concepts/components/prisma-schema/indexes#upgrading-from-previous-versions) section of our index configuration documentation.

### Scalar list defaults

For database connectors that support scalar lists (PostgreSQL, CockroachDB and MongoDB), Prisma 4 introduces the ability to set a default value in your Prisma schema file with the `@default` attribute:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma highlight=4;normal
model User {
  id             Int      @id @default(autoincrement())
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
<tab>

```prisma highlight=4;normal
model User {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
</TabbedContent>

#### Upgrade path

This is a breaking change if you previously had defaults defined for scalar lists at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you will lose any defaults that are defined in the database but not previously represented in the Prisma schema.

### Explicit <inlineCode>@unique</inlineCode> constraints on one-to-one relations

When using one-to-one relations in Prisma 4, you will need to explicitly add the `@unique` attribute to the relation scalar field. For example, for this one-to-one relation between a `User` and a `Profile` model, you will need to add the `@unique` attribute to the `profileId` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId Int?     @unique // <-- include this explicitly
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}
```

</tab>
<tab>

```prisma
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId String?  @unique @db.ObjectId // <-- include this explicitly
}

model Profile {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  user User?
}
```

</tab>
</TabbedContent>

#### Upgrade path

After you upgrade to Prisma 4, any one-to-one relations without a `@unique` attribute on the relation scalar will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will add the `@unique` attributes automatically.

### Enforced use of <inlineCode>@unique</inlineCode> or <inlineCode>@id</inlineCode> attribute for one-to-one and one-to-many relations (MySQL and MongoDB)

When you use one-to-one and one-to-many relations in Prisma 4, you will need to use a `@unique` attribute on the relation field to guarantee that the singular side(s) of the relation has only one record. This is now enforced for MySQL and MongoDB, bringing them into line with other connectors. Missing `@unique` attributes will now trigger a validation error.

In the following example of a one-to-many relation between a `User` and `Post` model, the `@unique` attribute must be added to the `email` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id    Int    @id @default(autoincrement())
  email String @unique // <-- we enforce this attribute
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  authorId Int
  author   User @relation(fields: [authorId], references: [email])
}
```

</tab>
<tab>

```prisma
model User {
  id    Int    @id @default(auto()) @map("_id") @db.ObjectId
  email String @unique // <-- we enforce this attribute
  posts Post[]
}

model Post {
  id       Int  @id @default(auto()) @map("_id") @db.ObjectId
  authorId Int
  author   User @relation(fields: [authorId], references: [email])
}
```

</tab>
</TabbedContent>

In the following example of a one-to-one relation between a `User` and `Profile` model, the `@unique` attribute must be added to the `email` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id      Int     @id @default(autoincrement())
  email   String  @unique // <- we enforce this unique attribute
  profile Profile
}

model Profile {
  id     Int   @id @default(autoincrement())
  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [email])
}
```

</tab>
<tab>

```prisma
model User {
  id      Int     @id @default(auto()) @map("_id") @db.ObjectId
  email   String  @unique // <- we enforce this unique attribute
  profile Profile
}

model Profile {
  id     Int   @id @default(auto()) @map("_id") @db.ObjectId
  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [email])
}
```

</tab>
</TabbedContent>

#### Upgrade path

After you upgrade to Prisma 4, any one-to-one or one-to-many relations without a `@unique` or `@id` attribute on the relation field will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will add the `@unique` attributes automatically.

### Remove `references` syntax for implicit many-to-many relations

When using [implicit many-to-many relations](/concepts/components/prisma-schema/relations/many-to-many-relations#implicit-many-to-many-relations) in Prisma 4, you will no longer be able to use the `references` argument, which was previously optional. For example, the following relation would now trigger a validation error:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation", references: [id]) // <-- validation error
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation", references: [id]) // <-- validation error
}
```

Instead, you can write:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation")
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation")
}
```

This is because the only valid value for `references` was `id`, so removing this argument makes it clearer what can and cannot be changed.

#### Upgrade path

After you upgrade to Prisma 4, any implicit many-to-many relations with a `references` argument will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will remove the `references` arguments automatically.

### Better grammar for string literals

String literals in your Prisma Schema now need to follow the same rules as strings in JSON. This mostly changes the escaping of some special characters. More details can be found in [the JSON specification](https://www.ietf.org/rfc/rfc4627.txt) or on the [JSON website](https://www.json.org/json-en.html).

#### Upgrade path

This is a breaking change for some existing schemas. After you upgrade to Prisma 4, incorrectly escaped characters will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema.

## Upgrade the <inlinecode>prisma</inlinecode> and <inlinecode>@prisma/client</inlinecode> packages to Prisma 4

To upgrade to Prisma 4 from a `3.x.x` version, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number. This allows upgrades to new minor versions, but not major versions, to safeguard against breaking changes.

To ignore the caret `^` and upgrade across major versions, you can use the `@4` tag when you upgrade with `npm`, or `yarn`:

<Admonition type="alert">

Before you upgrade, check each **breaking change** to see how the upgrade might affect your application.

</Admonition>

<TabbedContent tabs={[<FileWithIcon text="npm" icon="file"/>, <FileWithIcon text="yarn" icon="file"/>]}>

<tab>

```terminal
npm install prisma@4 @prisma/client@4
```

</tab>

<tab>

```terminal
yarn upgrade prisma@4 @prisma/client@4
```

</tab>

</TabbedContent>
