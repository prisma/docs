---
title: 'Upgrade to Prisma 4'
metaTitle: 'Upgrade to Prisma 4'
metaDescription: 'Guides on how to upgrade to Prisma 4'
tocDepth: 2
toc: true
---

<TopBlock>

Prisma 4 introduces a number of **breaking changes** when you upgrade from an Prisma 3 version (`3.x.x`). This guide explains how this upgrade might affect your application and gives instructions on how to handle any changes.

</TopBlock>

## Breaking changes

This section gives an overview of breaking changes in Prisma 4.

### Node.js minimum version change

From v4.0.0, the minimum version of Node.js that we support is 14.x. If you use an earlier version of Node.js, you will need to update it.

See our [system requirements](/reference/system-requirements) for all minimum version requirements.

### Raw query type mapping: scalar values are now deserialized as their correct JavaScript types

In v3.14.x and v.3.15.x, [raw query type mapping](/concepts/components/prisma-client/raw-database-access#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In v4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in v4.0.0 or later.

Raw queries now deserialize scalar values to their corresponding JavaScript types.

Note: Prisma infers types from the values themselves and not from the Prisma Schema types.

Example query and response:

```ts
const res =
  await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM "Table";`
console.log(res) // [{ bigint: BigInt("123"), bytes: Buffer.from([1, 2]), decimal: new Prisma.Decimal("12.34"), date: Date("<some_date>") }]
```

#### Upgrade path

From v4.0.0, some data types returned by `queryRaw` or `queryRawUnsafe` are different, as follows:

| Data type  | Before v4.0.0         | From v4.0.0           |
| ---------- | --------------------- | --------------------- |
| `DateTime` | Returned as `String`  | Returned as `Date`    |
| `Numeric`  | Returned as `Float`   | Returned as `Decimal` |
| `Bytes`    | Returned as `String`  | Returned as `Buffer`  |
| `Int64`    | Returned as `Integer` | Returned as `BigInt`  |

If you use `queryRaw` or `queryRawUnsafe` to return any of the above data types, then you must change your code to handle the new types.

For example, if you return `DateTime` data, then you need to take into account the following:

- You no longer need to manually instantiate a `DateTime` object for the returned data.
- If your code currently uses the returned `String` data, then you now need to convert the `DateTime` object to a `String`.

You must make equivalent code changes for the other data types in the table above.

#### Raw query mapping: PostgreSQL type-casts

In v3.14.x and v.3.15.x, [raw query type mapping](/concepts/components/prisma-client/raw-database-access#raw-query-type-mapping) was available with the Preview feature `improvedQueryRaw`. In v4.0.0, we have made raw query type mapping Generally Available. You do not need to use `improvedQueryRaw` to get this functionality in v4.0.0 or later.

If you use Postgres, as a result of tightened type coercion rules, you might need to update certain queries that worked in 3.x.

#### Upgrade path

We recommend you re-test your usage of `$queryRaw` and double-check that the types you pass into your raw queries match the types that PostgreSQL expects.

For example, in v4.0.0, the following fails:

```js
await prisma.$queryRaw`select length(${42});
```

This is because PostgreSQLâ€™s length(string) function expects a string. To fix this, explicitly coerce the incoming number into a string with the following:

```js
await prisma.$queryRaw`select length(${42}::text);`
```

### <inlineCode>DbNull</inlineCode>, <inlineCode>JsonNull</inlineCode> and <inlineCode>AnyNull</inlineCode> are now objects

JavaScript `null` is ambiguous for JSON columns, so Prisma uses `DbNull`, `JsonNull`, and `AnyNull` to distinguish between the database `NULL` value and the JSON `null` value. From v4.0.0, `DbNull`, `JsonNull`, and `AnyNull` are objects, instead of string constants.

See [Filtering by null values](/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values) for more information.

#### Upgrade path

If you use literal strings to address these values, then you must update your code to use the following named constants instead:

- For `DbNull` use `Prisma.DbNull`
- For `JsonNull` use `Prisma.JsonNull`
- For `AnyNull`: use `Prisma.AnyNull`

If you already use these named constants, then you do not need to take any action. If you now get a type error when you pass `Prisma.DbNull` as the value of a JSON field, then this probably indicates a bug in your code that our types did not catch before v4.0.0. The field where you tried to store `DbNull` is probably not nullable in your schema. As a result, a literal "DbNull" string was stored in the database instead of NULL.

### Default composite types in MongoDB

From v4.0.0, if you carry out a database read on a composite type when all of the following conditions are true, then Prisma Client inserts the default value into the result.

Conditions:

- The composite type is required, and
- The composite type has a default value, and
- The composite type is not present in the returned document or documents.

This behavior is now consistent with the behavior for model fields.

To learn more, see [Default values on required composite types](/concepts/components/prisma-client/composite-types#default-values-on-required-composite-types).

#### Upgrade path

If you currently rely on a return value of `undefined`, then you need to refactor your code to handle the default value that is now returned in Prisma 4.

### Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client

From v4.0.0, Prisma no longer exports `Prisma.dmmf.schema` into the generated Prisma Client. This makes the generated Prisma Client much more efficient, and also avoids some memory leaks if you use Jest to carry out tests.

Note:

- This change does not affect the DMMF that Prisma passes to the generators.
- You can retrieve the full DMMF at runtime dynamically.
- We still export `Prisma.dmmf.datamodel` into the generated Prisma Client.

### Index configuration

In Prisma 4, the `extendedIndexes` Preview feature will now become generally available. This includes the following index configuration options:

- Length configuration of indexes, unique constraints and primary key constraints for MySQL (in Preview in versions `3.5.0` and later)
- Sort order configuration of indexes, unique constraints and primary key constraints (in Preview in versions `3.5.0` and later)
- New index types for PostgreSQL: Hash (in Preview in versions `3.6.0` and later) and GIN, GiST, SP-GiST and BRIN (in Preview in versions `3.14.0` and later)
- Index clustering for SQL Server (in Preview in versions `3.13.0` and later)

See our documentation on [Index configuration](/concepts/components/prisma-schema/indexes#index-configuration) for more details of these features.

#### Upgrade path

These can all be breaking changes if you were previously configuring these properties at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you may lose any configuration that was defined in the database but not previously represented in the Prisma schema.

For more details, see the [Upgrading from previous versions](/concepts/components/prisma-schema/indexes#upgrading-from-previous-versions) section of our index configuration documentation.

### Scalar list defaults

For database connectors that support scalar lists (PostgreSQL, CockroachDB and MongoDB), Prisma 4 introduces the ability to set a default value in your Prisma schema file with the `@default` attribute:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id             Int      @id @default(autoincrement())
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
<tab>

```prisma
model User {
  id             String   @id @default(auto()) @map("_id") @db.ObjectId
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}
```

</tab>
</TabbedContent>

#### Upgrade path

This is a breaking change if you previously had defaults defined for scalar lists at the database level. In this case, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- run `prisma db pull` afterwards to retrieve any existing configuration of indexes and constraints. This needs to be done before running any `prisma db push` or `prisma migrate dev` command, or you will lose any defaults that are defined in the database but not previously represented in the Prisma schema.

### Explicit <inlineCode>@unique</inlineCode> constraints on one-to-one relations

When using one-to-one relations in Prisma 4, you will need to explicitly add the `@unique` attribute to the relation scalar field. For example, for this one-to-one relation between a `User` and a `Profile` model, you will need to add the `@unique` attribute to the `profileId` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId Int?     @unique // <-- include this explicitly
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}
```

</tab>
<tab>

```prisma
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId String?  @unique @db.ObjectId // <-- include this explicitly
}

model Profile {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  user User?
}
```

</tab>
</TabbedContent>

#### Upgrade path

After you upgrade to Prisma 4, any one-to-one relations without a `@unique` attribute on the relation scalar will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will add the `@unique` attributes automatically.

### Enforced use of <inlineCode>@unique</inlineCode> or <inlineCode>@id</inlineCode> attribute for one-to-one and one-to-many relations (MySQL and MongoDB)

When you use one-to-one and one-to-many relations in Prisma 4, you will need to use a `@unique` attribute on the relation field to guarantee that the singular side(s) of the relation has only one record. This is now enforced for MySQL and MongoDB, bringing them into line with other connectors. Missing `@unique` attributes will now trigger a validation error.

In the following example of a one-to-many relation between a `User` and `Post` model, the `@unique` attribute must be added to the `email` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id    Int    @id @default(autoincrement())
  email String @unique // <-- we enforce this attribute
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  authorId Int
  author   User @relation(fields: [authorId], references: [email])
}
```

</tab>
<tab>

```prisma
model User {
  id    Int    @id @default(auto()) @map("_id") @db.ObjectId
  email String @unique // <-- we enforce this attribute
  posts Post[]
}

model Post {
  id       Int  @id @default(auto()) @map("_id") @db.ObjectId
  authorId Int
  author   User @relation(fields: [authorId], references: [email])
}
```

</tab>
</TabbedContent>

In the following example of a one-to-one relation between a `User` and `Profile` model, the `@unique` attribute must be added to the `email` field:

<TabbedContent tabs={[<FileWithIcon text="Relational databases" icon="database"/>, <FileWithIcon text="MongoDB" icon="database"/>]}>
<tab>

```prisma
model User {
  id      Int     @id @default(autoincrement())
  email   String  @unique // <- we enforce this unique attribute
  profile Profile
}

model Profile {
  id     Int   @id @default(autoincrement())
  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [email])
}
```

</tab>
<tab>

```prisma
model User {
  id      Int     @id @default(auto()) @map("_id") @db.ObjectId
  email   String  @unique // <- we enforce this unique attribute
  profile Profile
}

model Profile {
  id     Int   @id @default(auto()) @map("_id") @db.ObjectId
  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [email])
}
```

</tab>
</TabbedContent>

#### Upgrade path

After you upgrade to Prisma 4, any one-to-one or one-to-many relations without a `@unique` or `@id` attribute on the relation field will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will add the `@unique` attributes automatically.

### Remove `references` syntax for implicit many-to-many relations

When using [implicit many-to-many relations](/concepts/components/prisma-schema/relations/many-to-many-relations#implicit-many-to-many-relations) in Prisma 4, you will no longer be able to use the `references` argument, which was previously optional. For example, the following relation would now trigger a validation error:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation", references: [id]) // <-- validation error
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation", references: [id]) // <-- validation error
}
```

Instead, you can write:

```prisma file=schema.prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[] @relation("my-relation")
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[] @relation("my-relation")
}
```

This is because the only valid value for `references` was `id`, so removing this argument makes it clearer what can and cannot be changed.

#### Upgrade path

After you upgrade to Prisma 4, any implicit many-to-many relations with a `references` argument will trigger a validation error. To upgrade, you will need to:

- upgrade to the new Prisma 4 packages following [these instructions](#upgrade-the-prisma-and-prismaclient-packages-to-prisma-4)
- manually fix the validation errors in your Prisma schema. Alternatively, if you have an up-to-date live database, running `prisma db pull` will remove the `references` arguments automatically.

## Upgrade the <inlinecode>prisma</inlinecode> and <inlinecode>@prisma/client</inlinecode> packages to Prisma 4

To upgrade to Prisma 4 from a `3.x.x` version, you need to update both the `prisma` and `@prisma/client` packages. Both the `prisma` and `@prisma/client` packages install with a caret `^` in their version number. This allows upgrades to new minor versions, but not major versions, to safeguard against breaking changes.

To ignore the caret `^` and upgrade across major versions, you can use the `@4` tag when you upgrade with `npm`, or `yarn`:

<Admonition type="alert">

Before you upgrade, check each **breaking change** to see how the upgrade might affect your application.

</Admonition>

<TabbedContent tabs={[<FileWithIcon text="npm" icon="file"/>, <FileWithIcon text="yarn" icon="file"/>]}>

<tab>

```terminal
npm install prisma@4 @prisma/client@4
```

</tab>

<tab>

```terminal
yarn upgrade prisma@4 @prisma/client@4
```

</tab>

</TabbedContent>
