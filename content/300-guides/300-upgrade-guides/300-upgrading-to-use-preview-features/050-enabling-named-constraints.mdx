---
title: 'Enabling `namedConstraints`'
metaTitle: 'Enabling the `namedConstraints` preview feature'
metaDescription: 'How to use the Preview feature `namedConstraints`.'
---

<TopBlock>

This page describes manual upgrade steps that you need to perform after upgrading to Prisma 2.29.0 (or newer) and you want to use the `namedConstraints` Preview feature.

After you enable the `namedConstraints` Preview feature, choose a workflow (Prisma Migrate or Introspection) and upgrade path that suits your requirements:

</TopBlock>

<!-- general problem statement -->
<!--
- db names passed directly to client -> special character in db names could break the client generation (.,- etc...)
- no names possible in schema for pks and fks
- means environments could get out of sync when introspecting legacy and creating dev locally for example
- this can result in migrations failing on prod that succeeded on dev
- here is how to detect (link) and fix being out of sync (link to extra doc or section at the bottom)
-->

<!-- detecting being out of sync -->
<!--
- introspect dev w. flag to extra file
- introspect prod w. flag to extra file
- diff files
-->

<!-- fixing being out of sync -->

<!-- 
- assumes you want to keep the prod names
- introspect prod
- switch to dev, migrate dev `new-migration-to-sync-names`
- switch to prod, migrate resolve --applied `new-migration-to-sync-names`
- history now contains step to align sync names and prod won't try to reapply it again
-->

<!-- general solution once envs are in sync -->
<!--
- names possible but suppressed if matching (now changed) convention (link)
- just enabling flag will change meaning of schema
- when using migrate dev / db push this would result in a change of constraint names
- when using db pull this would mean existing db names are pulled into the datamodel (making it noisier)
- you should consciously decide whether there is a need to keep existing names unchanged and pick a path
- reasons (conventions you have to follow for other tools, manual indexhints in custom sql, personal preference etc..)
-->

<!-- keep names -->
<!--
- set flag and introspect your target env
-->

<!-- switch to default names / keep schema clean -->
<!--
- use clean schema, call migrate dev
- apply to other envs
-->

## Upgrade paths for Prisma Migrate users

Use the following guide if your project uses Prisma Migrate. Choose the upgrade path that matches your requirements:

- [I want to maintain my existing constraint and index names](#upgrade-path-1-i-want-to-maintain-my-existing-constraint-and-index-names)
- [I want to use Prisma's default constraint and index names](#upgrade-path-2-i-want-to-use-prismas-default-constraint-and-index-names)

### Upgrade path 1: I want to maintain my existing constraint and index names

1.  Enable the `namedConstraints` Preview:

    ```prisma highlight=3;normal
    generator client {
      provider        = "prisma-client-js"
      previewFeatures = ["namedConstraints"]
    }

    datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
    }

    model User {
      id    Int    @id() @default(autoincrement())
      name  String @unique
      posts Post[]
    }

    model Post {
      id          Int     @id @default(autoincrement())
      title       String
      authorName  String  @default("Anonymous")
      author      User?   @relation(fields: [authorName], references: [name])
    }
    ```

1.  Introspect your **development database** to populate the Prisma schema with constraint and index names in your underlying database _that do not match Prisma's naming convention_:

    ```terminal
    npx prisma migrate introspect
    ```

    In this example, the highlighted constraints did not conform to Prisma's default naming convention and now include the `map` attribute field:

    ```prisma highlight=11;normal
    model User {
      id    Int    @id(map: "Custom_Constraint_Name") @default(autoincrement())
      name  String @unique
      posts Post[]
    }

    model Post {
      id    Int @id @default(autoincrement())
      title String
      authorName String @default("Anonymous")
      author User? @relation(fields: [authorName], references: [name], map: "Custom_Foreign_Key_Constraint")
    }
    ```

1.  Optionally introspect your **production database** and double-check that constraint names in production and development are in sync. If you have external applications or scripts that rely on a specific constraint name in production, make sure that these constraint names are represented in the Prisma schema.

    In the following example, the `Post` model has a foreign key constraint with a custom name in production that does not match development:

      <TabbedContent tabs={[<FileWithIcon text="Development environment" icon="prisma"/>, <FileWithIcon text="Production environment" icon="prisma"/>]}>

      <tab>

    ```prisma highlight=5;normal
    model Post {
      id    Int @id @default(autoincrement())
      title String
      authorName String @default("Anonymous")
      author User? @relation(fields: [authorName], references: [name], map: "Custom_Foreign_Key_Constraint")
    }
    ```

      </tab>

      <tab>

    ```prisma highlight=5;normal
    model Post {
      id    Int @id @default(autoincrement())
      title String
      authorName String @default("Anonymous")
      author User? @relation(fields: [authorName], references: [name], map: "Custom_Production_Name")
    }
    ```

      </tab>

      </TabbedContent>

    To synchronize constraint names between development and production, make sure that the constraint name in your Prisma schema is `map: "Custom_Production_Name"`.

1.  Optionally rename any explicitly defined constraint names where you do not want to use Prisma's naming convention, but do want to use a different constraint name:

    ```prisma highlight=2;delete|3;add
    model User {
      id    Int    @id(map: "Custom_Constraint_Name") @default(autoincrement())
      id    Int    @id(map: "User_ID_Primary_Key") @default(autoincrement())
      name  String @unique
      posts Post[]
    }
    ```

1.  Optionally _remove_ the `map` field from any constraint or index attribute where you want to use the Prisma default:

    ```prisma highlight=5;delete|6;add
    model Post {
      id    Int @id @default(autoincrement())
      title String
      authorName String @default("Anonymous")
      author User? @relation(fields: [authorName], references: [name], map: "Custom_Foreign_Key_Constraint")
      author User? @relation(fields: [authorName], references: [name])
    }
    ```

1.  Run the `prisma migrate dev` command to apply the changes to the database and generate a new migration:

    ```terminal
    npx prisma migrate dev
    ```

1.  Deploy the migration to production and test environments.

    ```terminal
    npx prisma migrate deploy
    ```

### Upgrade path 2: I want to use Prismas default constraint and index names

1. Enable the `namedConstraints` Preview:

   ```prisma highlight=3;normal
   generator client {
     provider        = "prisma-client-js"
     previewFeatures = ["namedConstraints"]
   }
   ```

1. Run the `prisma migrate dev` command to generate a new migration:

   ```terminal
   npx prisma migrate dev
   ```

   This migration renames any constraints that do not currently follow Prisma's naming convention.

## Upgrade path for introspection only users

Use the following guide if you use introspection only.

1. Enable the `namedConstraints` Preview:

   ```prisma highlight=3;normal
   generator client {
     provider        = "prisma-client-js"
     previewFeatures = ["namedConstraints"]
   }
   ```

1. Introspect to populate your Prisma schema with any constraint names that do not follow Prisma's naming convention:

   ```terminal
   npx prisma introspect
   ```

   For example, in the following model, the `@id` primary key constraint does not follow Prisma's convention (the conventional name would be `User_pk`):

   ```prisma
   model User {
     id    Int    @id(map: "user_id_primary_key") @default(autoincrement())
     name  String @unique
     posts Post[]
   }
   ```
