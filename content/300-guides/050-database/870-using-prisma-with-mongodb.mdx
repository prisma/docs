---
title: 'Using Prisma with MongoDB'
metaTitle: 'Using Prisma with MongoDB'
metaDescription: 'Guide to using Prisma with MongoDB'
tocDepth: 2
toc: true
---

<TopBlock>

This guide discusses the concepts behind using Prisma and MongoDB, explains the commonalities and differences between MongoDB and other database providers, and leads you through the process for configuring your application to integrate with MongoDB.

</TopBlock>

## What is MongoDB?

MongoDB is a NoSQL database that stores data (formatted as key-value pairs) in BSON files, a JSON-like document. Commonly used for Node.js projects because of its native support for all-things Javascript, MongoDB handles high-volume data storage with rapid queries and data updates, so it is a popular database choice for JS-based application development.

Features include:

- **Flexible schemas**
- **Support for horizontal scale-out with auto-sharding**
- **Support for new data types**
- **Fast query response**
- **Fast data updates**

## Commonalities with other database providers

Some aspects of using Prisma with MongoDB are the same as when using Prisma with a relational database. You can still:

- model your database with the [Prisma Schema Language](/concepts/components/prisma-schema)
- connect to your database, using the [`mongodb` database connector](/concepts/database-connectors/mongodb)
- use [Introspection](/concepts/components/introspection) for existing projects if you already have a MongoDB database
- use [`db push`](/concepts/components/prisma-migrate/db-push) to push changes in your schema to the database
- use [Prisma Client](/concepts/components/prisma-client) in your application to query your database

## Differences to consider

MongoDB's document-based structure and flexible schemas means that using Prisma with MongoDB differs from using it with a relational database in a number of ways. These are some areas where there are differences that you need to be aware of:

**Defining IDs.** MongoDB documents have an `_id` field that contain an [ObjectID](https://www.mongodb.com/docs/manual/reference/bson-types/#std-label-objectid). This needs to be mapped to a Prisma field. For more information, see [Defining IDs in MongoDB](/concepts/components/prisma-schema/data-model#defining-ids-in-mongodb).

**Migrating old data to new schemas.** In relational databases, all your data must match your schema. If you change the type of a particular field in your schema when you migrate, all the data must also be updated to match. In contrast, MongoDB does not enforce
For more information, see [How to migrate old data to new schemas](#how-to-migrate-old-data-to-new-schemas).

**Introspection.** When you introspect an existing database, you will get a schema with no relations and will need to add the missing relations in manually. For more information, see [How to add in missing relations after Introspection](#how-to-add-in-missing-relations-after-introspection).

**Filtering for `null` and undefined fields.** MongoDB makes a distinction between setting a field to `null` and not setting it at all, which is not present in relational databases. Prisma currently does not express this distinction, which means that you need to be careful when filtering for `null` and undefined fields. For more information, see [How to filter for `null` and undefined fields](#how-to-filter-for-null-and-undefined-fields).

**Using a replica set.** Prisma uses [MongoDB transactions](https://www.mongodb.com/docs/manual/core/transactions/) internally to avoid partial writes on nested queries. When using transactions, MongoDB requires you to have a [replica set](https://www.mongodb.com/docs/manual/replication/) configured — this is a group of MongoDB processes that maintain the same data set, providing redundancy and high availability. If you use MongoDB's [Atlas](https://www.mongodb.com/atlas/database) hosting service, the replica set is configured for you, but if you are running MongoDB locally you will need to set this up yourself. For more information, see MongoDB's [guide to deploying a replica set](https://www.mongodb.com/docs/manual/tutorial/deploy-replica-set/).

## How to implement Prisma with MongoDB

This section provides instructions for how to carry out tasks that require steps specific to MongoDB.

### How to migrate old data to new schemas

Migrating your database over time is an important part of the development cycle. During development, you will need to update your schema file (for example, toads new fields), then update the data in your your development environment’s database, and eventually push both the updated schema and the new data to the production database.

<Admonition type="info">

When using MongoDB, be aware that the “coupling” between your schema and the database is purposefully designed to be less rigid than with with SQL databases; MongoDB will not enforce the schema, so you have to verify data integrity.

</Admonition>

These iterative tasks of updating the schema and the database can result in inconsistencies between your schema and the actual data in the database. Let’s look at one scenario where this can happen, and then examine several strategies for you and your team to consider for handling these inconsistencies.

**Scenario**: you need to add a new field to your schema, to accommodate a billing address that is separate from the currently stored delivery address. Your data in the production database currently has no such concept; there is no table or column that reflects this new field.

**Strategy #1, “on demand” updates**: with this strategy, you and your team have agreed that updates can be made to the schema as needed. However, in order to avoid migration failures due to inconsistencies between the data and schema, there is agreement in the team that any new fields added are explicitly defined as `optional`.

So in our scenario above, you can go ahead and add the new `billing address` field to the User model in your Prisma schema, define it as optional, and regenerate your Prisma Client using the `npx prisma generate` command. Next, update your application to reflect the new field, and redeploy your app. The records in the database will be updated as the application’s end-users begin to enter their billing address in the new field.

**Strategy #2, “no breaking changes” updates**: this strategy builds on the first one, with further consensus amongst your team that you don't rename or delete fields, only add new fields, and always define the new fields as optional. This policy can be reenforced by adding checks in the CI/CD process to verify that there are no backwards-incompatible changes to the schema.

**Strategy #3, “all at once” updates**: this strategy uses a script and is similar to traditional migration systems, where all changes to the data is made immediately, so that the schema and data are in synch immediately afterwards. So in the scenario above, you create a script to add billing addresses to all old users, then you can make the field a required field in the app right away because the schema and the data are consistent.

### How to add in missing relations after Introspection

After Introspection of a MongoDB database, you will need to manually add in relations between databases. As an example, take a MongoDB database with two collections, `User` and `Post`. The data in these collections has the following format, with a `userId` field linking users to posts:

`User` collection:

- `_id` field with a type of `ObjectID`
- `email` field with a type of `String`

`Post` collection:

- `_id` field with a type of `ObjectID`
- `name` field with a type of `String`
- `userId` with a type of `ObjectID`

On introspection with `db pull`, this is pulled in to the Prisma schema file as follows:

```prisma file=prisma/schema.prisma
model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
}
```

This is missing the relation between the `User` and `Post` models. To fix this, manually add a `user` field to the `Post` model with a `@relation` attribute linking it to the `User` model, and a `posts` field to the `User` model:

```prisma file=prisma/schema.prisma highlight=5;add|11;add
model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id])
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
  posts Post[]
}
```

For more information on how to use relations in Prisma, see [our documentation](/concepts/components/prisma-schema/relations).

### How to filter for <inlinecode>null</inlinecode> and undefined fields

To understand how MongoDB distinguishes between `null` and undefined fields, consider the example of a `User` model with an optional `name` field:

```ts
model User {
  id    String  @id @default(auto()) @map("_id") @db.ObjectId
  email String
  name  String?
}
```

First, try creating a record with the `name` field explicitly set to `null`. Prisma will return `name: null` as expected:

<CodeWithResult expanded={true}>

<cmd>

```ts
const createNull = await prisma.user.create({
  data: {
    email: 'user1@prisma.io',
    name: null,
  },
})
console.log(createNull)
```

</cmd>

<cmdResult>

```
{
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
}
```

</cmdResult>

</CodeWithResult>

If you check your MongoDB database directly, you will also see a new record with `name` set to `null`:

```terminal
_id: 6242c4af032bc76da250b207
email: "user1@prisma.io"
name: null
```

Next, try creating a record without explicitly setting the `name` field:

<CodeWithResult expanded={true}>

<cmd>

```ts
  const createUndefined = await prisma.user.create({
    data: {
       email: "user2@prisma.io",
     }
   })
   console.log(createUndefined)
}
```

</cmd>

<cmdResult>

```
{
    id: '6242c4ae032bc76da250b208',
    email: 'user2@prisma.io',
    name: null
},

```

</cmdResult>

</CodeWithResult>

Prisma still returns `name: null`, but if you look in the database directly you will see that the record has no `name` field defined at all:

```terminal
_id: 6242c4af032bc76da250b208
email: "user2@prisma.io"
```

Prisma returns the same result in both cases, because we currently don't have a way to specify this difference in MongoDB between fields that are `null` in the underlying database, and fields that are not defined at all — see [this Github issue](https://github.com/prisma/prisma/issues/12555) for more information.

This means that you currently have to be careful when filtering for `null` and undefined fields. Filtering for records with `name: null` will only return the first record, with the `name` explicitly set to `null`:

<CodeWithResult expanded={true}>

<cmd>

```ts
const findNulls = await prisma.user.findMany({
  where: {
    name: null,
  },
})
console.log(findNulls)
```

</cmd>

<cmdResult>

```terminal
[
  {
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
  }
]
```

</cmdResult>

</CodeWithResult>

To include undefined fields as well, use the [`isSet` filter](/reference/api-reference/prisma-client-reference#isset) to explicitly search for fields which are either `null` or not set. This will return both records:

<CodeWithResult expanded={true}>

<cmd>

```ts
const findNullOrUndefined = await prisma.user.findMany({
  where: {
    OR: [
      {
        name: null,
      },
      {
        name: {
          isSet: false,
        },
      },
    ],
  },
})

console.log(findNullOrUndefined)
```

</cmd>

<cmdResult>

```terminal
[
  {
    id: '6242c4ae032bc76da250b207',
    email: 'user1@prisma.io',
    name: null
  },
  {
    id: '6242c4ae032bc76da250b208',
    email: 'user2@prisma.io',
    name: null
  }
]
```

</cmdResult>

</CodeWithResult>

## More on using MongoDB with Prisma

The fastest way to start using MongoDB with Prisma is to refer to our Getting Started documentation:

- [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/mongodb-typescript-mongodb)
- [Add to existing project](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/mongodb-typescript-mongodb)

These tutorials will take you through the process of connecting to MongoDB, pushing schema changes, and using the Prisma Client.

For more information on how to set up and manage a MongoDB database, see the [Prisma Data Guide](https://www.prisma.io/dataguide/#mongodb).
