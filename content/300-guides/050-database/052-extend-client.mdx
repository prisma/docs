---
title: 'Extending the Prisma Client'
metaTitle: 'Extend the Prisma Client with Validation, Computed Fields, Excluding Keys, and Custom Methods'
metaDescription: 'How to add validation, computed fields, and custom logic to applications using the Prisma Client'
tocDepth: 2
---

<TopBlock>

A common request we get is that while Prisma is great for working with the database, your data needs are far more complex. You need to be able to:

- **Validate** that the data that my user sent me is complete and valid
- Derive **computed fields** based on existing data
- **Exclude sensitive** **fields** that shouldn't be accessible to your users
- **Wrap the Prisma Client** to organize and group complex business logic.

Today you'll learn how to implement these patterns in your own application in a type-safe way.

We'll use the following schema to model a simplified SaaS app like Slack or Notion where each Team has many Users. We'll focus on an initial signup flow to illustrate these patterns.

```jsx
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int    @id @default(dbgenerated())
  email     String @unique
  password  String
  firstName String
  lastName  String
  Team      Team?  @relation(fields: [teamId], references: [id])
  teamId    Int?
}

model Team {
  id    Int    @id @default(dbgenerated())
  name  String @unique
  users User[]
}
```

</TopBlock>

## Creating a Helper Function

To kick things off, let's discuss how to abstract Prisma Client queries into functions. This will be used in the examples that follow.

Let's build a signup function below that requires userÂ and team information to create rows in your database.

To make this type-safe, we'll utilize the exported types in `@prisma/client` along with some built-in types that TypeScript provides.

This example also demonstrates how you can use the built-in `Omit` type to exclude fields from the input, further restraining what the signup function will accept.

<TabbedContent tabs={[<FileWithIcon text="TypeScript" icon="code"/>, <FileWithIcon text="JavaScript (Node.js)" icon="code"/>]}>

<tab>

```tsx highlight=5-9;normal
import { PrismaClient, Prisma, User, Team } from '@prisma/client'

const prisma = new PrismaClient()

type Signup = {
  // accept all team and user fields except id
  team: Omit<Prisma.TeamCreateArgs['data'], 'id'>
  user: Omit<Prisma.UserCreateArgs['data'], 'id'>
}

async function signup(input: Signup): Promise<User> {
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}

// Run the signup function
async function main() {
  const { team, user } = await signup({
    team: {
      name: 'Super Coffee',
    },
    user: {
      firstName: 'Alice',
      lastName: 'Wonderland',
      email: 'alice@prisma.io',
      password: 'everything is awesome',
    },
  })
}
```

</tab>

<tab>

```tsx
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// When you first signup, you create an initial user and a team of one
// with you as the first user.
async function signup(input) {
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}

// Run the signup function
async function main() {
  const { team, user } = await signup({
    team: {
      name: 'Super Coffee',
    },
    user: {
      firstName: 'Alice',
      lastName: 'Wonderland',
      email: 'alice@prisma.io',
      password: 'everything is awesome',
    },
  })
}
```

</tab>

</TabbedContent>

## Validating User Input

Some data must be validated at runtime. For example, there's no way to type-check that your user's email contains an `@` symbol at build time. To ensure that the data you get is the data you expect, you can use runtime validation.

The Node.js ecosystem provides a number of high-quality, easy-to-use validation libraries you can choose from including: [joi](https://github.com/sideway/joi), [validator.js,](https://github.com/validatorjs/validator.js) [yup](https://github.com/jquense/yup), [zod](https://github.com/colinhacks/zod) and [superstruct](https://github.com/ianstormtaylor/superstruct).

Let's go with superstruct for the example below and extend the signup helper function to ensure that the data you get meets your expectation.

### Adding Validation to Your Signup Function

```tsx file=index.ts highlight=2,3,7-20,29-31;normal
import { PrismaClient, Prisma, User, Team } from '@prisma/client'
import { assert, object, string, size, refine } from 'superstruct'
import isEmail from 'isemail'

const prisma = new PrismaClient()

// Runtime validation
const Signup = object({
  team: object({
    name: size(string(), 2, 30),
  }),
  user: object({
    // string and an email
    email: refine(string(), 'email', (v) => isEmail.validate(v)),
    // password is between 7 and 30 characters long
    password: size(string(), 7, 30),
    firstName: size(string(), 2, 50),
    lastName: size(string(), 2, 50),
  }),
})

type Signup = {
  team: Omit<Prisma.TeamCreateArgs['data'], 'id'>
  user: Omit<Prisma.UserCreateArgs['data'], 'id'>
}

// Signup function
async function signup(input: Signup): Promise<User> {
  // Assert that input conforms to Signup, throwing with a helpful
  // error message if input is invalid.
  assert(input, Signup)
  const team = await prisma.team.create({
    data: {
      ...input.team,
      users: {
        create: input.user,
      },
    },
    include: {
      users: true,
    },
  })
  return team.users[0]
}
```

The example aboves shows how you can easily add runtime validation to provide additionally check that the data we receive is the data we expect.

## Computed Fields

Another common pattern is computing a field that's derived from other data.

With TypeScript's rich type system, you can define a function that accepts a generic as an input then extend that generic to ensure it conforms to a specific structure. Finally you can return that generic with additional computed fields. Let's see how that might look:

Let's say we also want to derive the user's full name from their first and last name. In the example below, you'll create a helper function to compute a full name from the first and last name stored in the database.

### Computing a Full Name

The code below can look overwhelming. Keep in mind that at its core, `computeFullName`
is simply tacking on a `fullName` attribute to a user that's passed in. If the following code is confusing, we recommend looking at the JavaScript example to get a better sense of the logic before trying to make sense of the types.

<TabbedContent tabs={[<FileWithIcon text="TypeScript" icon="code"/>, <FileWithIcon text="JavaScript (Node.js)" icon="code"/>]}>

<tab>

```tsx highlight=1-5,7-10m,13-15;normal
// Define a type that needs a first and last name
type FirstLastName = {
  firstName: string
  lastName: string
}

// Extend the T generic with the fullName attribute
type WithFullName<T> = T & {
  fullName: string
}

// Take objects that satisfy FirstLastName and computes a full name
function computeFullName<User extends FirstLastName>(
  user: User
): WithFullName<User> {
  return {
    ...user,
    fullName: user.firstName + ' ' + user.lastName,
  }
}

async function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithFullName = computeFullName(user)
}
```

</tab>

<tab>

```js
function computeFullName(user) {
  return {
    ...user,
    fullName: user.firstName + ' ' + user.lastName,
  }
}

async function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithFullName = computeFullName(user)
}
```

</tab>

</TabbedContent>

In the TypeScript example above, a `User` generic has been defined that extends the `FirstLastName` type. This means that whatever you pass into `computeFullName` must contain `firstName` and `lastName` keys.

A `WithFullName<User>` return type has also been defined, which takes whatever `User` is and tacks on a `fullName` string attribute.

With this function, any object that contains `firstName` and `lastName` keys can compute a `fullName`. Pretty neat, right?

## Excluding **Sensitive** Fields

Very often, you don't want to include the **whole response** back from the database. In the signup function above, we've included the `password` in the response. Let's exclude this sensitive piece of data from the response.

### Excluding the Password Field

Let's create an `exclude` helper function that takes a user and returns that user without some keys.

<TabbedContent tabs={[<FileWithIcon text="TypeScript" icon="code"/>, <FileWithIcon text="JavaScript (Node.js)" icon="code"/>]}>

<tab>

```tsx highlight=1-4;normal
function exclude<User, Key extends keyof User>(
  user: User,
  ...keys: Key[]
): Omit<User, Key> {
  for (let key of keys) {
    delete user[key]
  }
  return user
}

function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithoutPassword = exclude(user, 'password')
}
```

</tab>

<tab>

```js
// Remove keys from user
function exclude(user, ...keys) {
  for (let key of keys) {
    delete user[key]
  }
  return user
}

function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithoutPassword = exclude(user, 'password')
}
```

</tab>

</TabbedContent>

In the TypeScript example, we've provided two generics: `User` and `Key`. The `Key` generic is defined as the keys of a `User` (e.g. email, password, firstName, etc.). These generics flow through the logic, returning a `User` that omits the list of `Key`s provided.

## Organizing the Prisma Client **into Models**

In the examples above, you've created helper functions that weave the type-safety deeper through your application. Creating helper functions works well when your application is small, but as your application grows, you may find an inconsistent use of these helper functions strewn across your codebase.

One technique for consistently applying and organizing these helper functions is to group them in a class.

### Wrapping the Model in a Class

The most obvious way to wrap the Prisma Client is by wrapping it in a `Model` class:

```tsx highlight=4,23,28-30;normal
import { PrismaClient } from '@prisma/client'
import { assert } from 'superstruct'

// ... previously defined Signup validation and helper functions ...

class Users {
  constructor(private readonly prisma: PrismaClient['user']) {}

  /**
   * Signup the first user and create a new team of one. Return the User with
   * a full name and without a password
   */
  async signup(input: Signup) {
    assert(input, Signup)
    const team = await this.prisma.team.create({
      data: {
        ...input.team,
        users: {
          create: input.user,
        },
      },
      include: {
        users: true,
      },
    })
    return exclude(computeFullName(team.users[0]), 'password')
  }
}

async function main() {
  const prisma = new PrismaClient()
  const model = new Users(prisma.user)
  const user = await users.signup(/* { ... } */)
  console.log(user)
}
```

Here we're only exposing a `signup` method from the Prisma Client. With this approach, you'll no longer be able to call Prisma Client methods like findMany or upsert. This approach works well when you have a large application and you want to intentionally limit what your models can do.

### Extending the Prisma Client

But what if you don't want to hide existing functionality? In this case, you can use `Object.assign` to extend the Prisma Client without limiting it's functionality:

```tsx highlight=2,27-29;normal
import { PrismaClient } from '@prisma/client'
import { assert } from 'superstruct'

// ... previously defined Signup validation and helper functions ...

function Users(prisma: PrismaClient) {
  return Object.assign(prisma, {
    /**
     * Signup the first user and create a new team of one. Return the User with
     * a full name and without a password
     */
    async signup(input: Signup) {
      assert(input, Signup)
      const team = await prisma.team.create({
        data: {
          ...input.team,
          users: {
            create: input.user,
          },
        },
        include: {
          users: true,
        },
      })
      return exclude(computeFullName(team.users[0]), 'password')
    },
  })
}

async function main() {
  const prisma = new PrismaClient()
  const users = Users(prisma)
  const user = await users.signup(/* { ... } */)
  const numUsers = await users.count()
  console.log(user, numUsers)
}
```

Now you can use your custom `signup` method alongside `count`, `updateMany`, `groupBy` and all of the other wonderful methods that the Prisma Client provides. Best of all, it's all type-safe!

Keep in mind that the other methods like `findMany` or `findUnique`, will return users with a `password` and without a `fullName`. If you do go with this approach, you may want to override those functions to modify the results before returning them.

## Conclusion

Today we've shown how you can implement some patterns on top of the Prisma Client to extend functionality and cover your data needs.

Prisma does eventually plan to bake some of these features in but that shouldn't stop you from taking advantage of these patterns today. To see where we're headed with these features, follow along with these feature requests to learn more:

- [Exclude support](https://github.com/prisma/prisma/issues/5042)
- [Computed Fields](https://github.com/prisma/prisma/issues/3394)
- [Runtime Validation](https://github.com/prisma/prisma/issues/3528)

If you have further questions or concerns, please reach out to us either on [this Github Issue](https://github.com/prisma/prisma/issues/7161), a [Github discussion](https://github.com/prisma/prisma/discussions) or on [Slack](https://slack.prisma.io/).
