---
title: 'Prisma Client API Reference'
metaTitle: 'Prisma Client API (Reference)'
metaDescription: 'API reference documentation for Prisma Client.'
tocDepth: 2
toc: true
---

<TopBlock>

The Prisma Client API reference documentation is based on the following schema:

```prisma
model User {
  id           Int       @id @default(autoincrement())
  name         String?
  email        String    @unique
  profileViews Int       @default(0)
  role         Role      @default(USER)
  coinflips    Boolean[]
  posts        Post[]
  city         String
  country      String
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String
  published  Boolean @default(true)
  author     User    @relation(fields:  [authorId], references: [id])
  authorId   Int
  comments   Json
  views      Int     @default(0)
  likes      Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

All example generated types (such as `UserSelect` and `UserWhereUniqueInput`) are based on the `User` model.

</TopBlock>

## <inlinecode>PrismaClient</inlinecode>

The Prisma Client object. Parameters are validated at runtime.

### <inlinecode>datasources</inlinecode>

Programmatically overrides properties of the `datasource` block in the `schema.prisma` file - for example, as part of an integration test.

#### Options

| Example option | Example value                 | Description |
| -------------- | ----------------------------- | ----------- |
| `db`           | `{ url: 'file:./dev_qa.db }'` |             |

#### Remarks

- You must re-generate the Prisma Client each time you add or rename a datasource. Datasource names are included in the generated client.

#### Examples

```ts file=script.ts
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: 'file:./dev_qa.db',
    },
  },
})
```

Based on the following `datasource` block:

```prisma file=schema.prisma
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

### <inlinecode>log</inlinecode>

Determines the type and level of logging.

#### Options

| Option                   | Example                                                                  | Description |
| ------------------------ | ------------------------------------------------------------------------ | ----------- |
| Array of log levels      | `[ "info", "query" ]`                                                    |             |
| Array of log definitions | `[ { level: "info", emit: "event" }, { level: "warn", emit: "stdout" }]` |             |

Available log levels:

| Name    | Description                                    |
| ------- | ---------------------------------------------- |
| `query` | If it's not defined, the default is colorless. |
| `info`  | Enables pretty error formatting.               |
| `warn`  | Enables colorless error formatting.            |
| `error` | Enables colorless error formatting.            |

Available emit formats:

| Name     | Description                                    |
| -------- | ---------------------------------------------- |
| `stdout` | If it's not defined, the default is colorless. |
| `event`  | Enables pretty error formatting.               |

#### Reference

```ts file=index.d.ts
log?: Array<LogLevel | LogDefinition>
```

```ts file=index.d.ts
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}
```

```ts file=index.d.ts
export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
```

#### Examples

##### Log `query` and `info` to `stdout`

<CodeWithResult>

<Cmd>

```ts file=script.ts
import { PrismaClient } from '@prisma/client'

| const prisma = new PrismaClient({ log: ['query', 'info'] })

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>

<CmdResult>

```
prisma:info  Starting a postgresql pool with 13 connections.
prisma:info  Started http server
prisma:query SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 ORDER BY "public"."User"."coinflips" ASC OFFSET $1) AS "sub"
```

</CmdResult>

</CodeWithResult>

##### Log a `query` event to console

<CodeWithResult>
<Cmd>

```ts file=script.ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: [{ level: 'query', emit: 'event' }] })

prisma.$on('query', e => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>

<CmdResult>

```js
{
  timestamp: 2020-11-17T10:32:10.898Z,
  query: 'SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 OFFSET $1) AS "sub"',
  params: '[0]',
  duration: 5,
  target: 'quaint::connector::metrics'
}
```

</CmdResult>

</CodeWithResult>

##### Log `info`, `warn`, and `error` events to console

<CodeWithResult>
<Cmd>

```ts file=script.ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'warn', emit: 'event' },
    { level: 'info', emit: 'event' },
    { level: 'error', emit: 'event' },
  ],
})

prisma.$on('warn', e => {
  console.log(e)
})

prisma.$on('info', e => {
  console.log(e)
})

prisma.$on('error', e => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>
<CmdResult>

```js
{
  timestamp: 2020-11-17T10:33:24.592Z,
  message: 'Starting a postgresql pool with 13 connections.',
  target: 'quaint::pooled'
}
{
  timestamp: 2020-11-17T10:33:24.637Z,
  message: 'Started http server',
  target: 'query_engine::server'
}
```

</CmdResult>
</CodeWithResult>

### <inlinecode>errorFormat</inlinecode>

Determines the level and formatting of errors returned by Prisma.

#### Options

| Name                  | Description                                    |
| --------------------- | ---------------------------------------------- |
| `undefined`           | If it's not defined, the default is colorless. |
| `pretty`              | Enables pretty error formatting.               |
| `colorless` (default) | Enables colorless error formatting.            |
| `minimal`             | Enables minimal error formatting.              |

#### Reference

```ts file=index.d.ts
errorFormat?: ErrorFormat
```

```ts file=index.d.ts
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
```

#### Examples

##### No error formatting

```ts file=script.ts
const prisma = new PrismaClient({
  // Defaults to colorless
})
```

##### `pretty` error formatting

```ts file=script.ts
const prisma = new PrismaClient({
  errorFormat: 'pretty',
})
```

##### `colorless` error formatting

```ts file=script.ts
const prisma = new PrismaClient({
  errorFormat: 'colorless',
})
```

##### `minimal` error formatting

```ts file=script.ts
const prisma = new PrismaClient({
  errorFormat: 'minimal',
})
```

## Model queries

### <inlinecode>findOne</inlinecode>

`findUnique` query lets you retrieve a single database record:

- By _ID_
- By a _unique_ attribute

#### Options

| Name      | Example type (`User`)                   | Required | Description                                                                      |
| --------- | --------------------------------------- | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput`                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | [`XOR<UserSelect, null>`](#reference-1) | No       | Specifies which properties to include on the returned object.                    |
| `include` | `XOR<UserInclude, null>`                | No       | Specifies which relations should be eagerly loaded on the returned object.       |

#### Return type

| Return type               | Example                    | Description                                                     |
| ------------------------- | -------------------------- | --------------------------------------------------------------- |
| Javascript object (typed) | `User`                     |                                                                 |
| Javascript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return. |
| `null`                    | `null`                     | Record not found                                                |

#### Reference

`findUnique` accepts the following input type:

```ts file=index.d.ts
export type FindUniqueUserArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### Examples

##### Retrieve the `User` record with an `id` of `42`

```ts file=script.ts
const result = await prisma.user.findUnique({
  where: {
    id: 42,
  },
})
```

##### Retrieve the `User` record with an `email` of `alice@prisma.io`

```ts file=script.ts
const result = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@unique`)

<details><summary>Expand for example User model with a @@unique block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts file=script.ts
const result = await prisma.user.findUnique({
  where: {
    fullname: {
      // name property of @@unique attribute - default is firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@id`)

<details><summary>Expand for example User model with an @@id block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts file=script.ts
const result = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findFirst</inlinecode>

`findFirst` returns the first record in a list that matches your criteria.

#### Options

| Name       | Example type (`User`)                                        | Required | Description                                                                                                                                                                                                                                |
| ---------- | ------------------------------------------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `distinct` | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                                                  |
| `where`    | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                                                       |
| `cursor`   | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                                                       |
| `orderBy`  | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                                                          |
| `include`  | `XOR<UserInclude, null>`                                     | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                 |
| `select`   | `XOR<UserSelect, null>`                                      | No       | Specifies which properties to include on the returned object.                                                                                                                                                                              |
| `skip`     | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                                                  |
| `take`     | `number`                                                     | No       | Specifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list. |

#### Return type

| Return type               | Example                    | Description                                                     |
| ------------------------- | -------------------------- | --------------------------------------------------------------- |
| Javascript object (typed) | `User`                     | Specifies which properties to include on the returned object.   |
| Javascript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return. |
| `null`                    | `null`                     | Record not found                                                |

#### Reference

`findFirst` accepts the following input type:

```ts file=index.d.ts
export type FindFirstUserArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Remarks

- `findFirst` calls `findMany` behind the scenes and accepts the same query options.
- Passing in a negative `take` value when you use a `findFirst` query reverses the order of the list.

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Retrieve the first `User` record where the `name` is `Alice`

```ts file=script.ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### Retrieve the first `Post` record where the `title` starts with `A test`, reverse the list with `take`

```ts file="script.ts"
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function mainAsync() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // Reverse the list
  })

  console.log(c)
}

mainAsync()
```

### <inlinecode>findMany</inlinecode>

`findMany` returns a list of records.

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                     |
| ---------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                            |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                               |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                       |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                            |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (+ve value) or _end_ (-ve value) **either** of the list **or** from the `cursor` position if mentioned) |
| `select`   | `XOR<PostSelect, null>`                                       | No       | Specifies which properties to include on the returned object.                                                                                                                                   |
| `include`  | `XOR<PostInclude, null>`                                      | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                      |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                       |

#### Return type

| Return type                     | Example                      | Description                                                     |
| ------------------------------- | ---------------------------- | --------------------------------------------------------------- |
| Javascript array object (typed) | `User[]`                     |                                                                 |
| Javascript array object (plain) | `[{ title: "Hello world" }]` | Use `select` and `include` to determine which fields to return. |
| Empty array                     | `[]`                         | No matching records found.                                      |

#### Reference

`findMany` accepts the following input type:

```ts file=index.d.ts
export type FindManyUserArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Retrieve all `User` records where the `name` is `Alice`

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>create</inlinecode>

`create` creates a new database record.

#### Options

| Name      | Type                                                     | Required | Description                                                                                                                                                                                                                                                                   |
| --------- | -------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `select`  | `XOR<UserSelect, null>`                                  | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                                 |
| `include` | `XOR<UserInclude, null>`                                 | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                                    |

#### Return type

| Return type                     | Example                        | Description                                                     |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                 |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Remarks

#### Reference

`create` accepts the following input type:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### Examples

##### Create a single new record with the only required field `email`

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### Create multiple new records

Prisma Client does not yet support batch inserts at a database level. Follow [issue #332 on GitHub](https://github.com/prisma/prisma-client-js/issues/332) for updates.

The following example results in **two** `INSERT` statements:

<CodeWithResult expanded={true}>

<Cmd>

```ts
import { PrismaClient, UserCreateInput } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async user => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>

<CmdResult>

```sql
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</CmdResult>

</CodeWithResult>

> **Tip**: Consider using the raw for bulk inserting large numbers of records.

##### Create multiple new records in a transaction

TODO

```ts
transaction
```

##### Nested `create` queries

You can also perform nested writes, such as:

- Create a `User` and one or more connected `Post` records at the same time (see [example](relation-queries#create-a-new-user-record-with-two-new-post-records))
- Create a `Post` and connect it to an existing user, or create a new `User` record (see [example](relation-queries#create-a-new-post-record-and-connect-it-to-an-existing-user-record-or-create-a-new-user))

### <inlinecode>update</inlinecode>

`update` updates an existing database record.

#### Options

| Name      | Type                                                   | Required | Description                                                                                                                                                                               |
| --------- | ------------------------------------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional. |
| `where`   | `UserWhereUniqueInput`                                 | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                          |
| `select`  | `XOR<UserSelect, null>`                                | No       | Specifies which properties to include on the returned object.                                                                                                                             |
| `include` | `XOR<UserInclude, null>`                               | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                |

#### Return type

| Return type                     | Example                        | Description                                                     |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                 |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception      |                                |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

#### Reference

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

##### Nested `update` queries

You can also perform nested writes during an update, such as:

- Update a `User` and update one or more connected `Post` records at the same time (see [example](relation-queries#update-an-existing-user-record-by-updating-two-post-records-its-connected-to))
- Update a `User` and connect it to one or more existing `Post` records, or add new `Post` records (see [example](relation-queries#update-an-existing-user-record-by-connect-it-to-two-existing-post-records-or-creating-two-new-post-records))

### <inlinecode>upsert</inlinecode>

`upsert` updates an existing _or_ creates a new database record.

#### Options

| Name      | Type                                                    | Required | Description                                                                                                                                                                                                                                                                |
| --------- | ------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`  | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `update`  | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                                                                  |
| `where`   | `UserWhereUniqueInput`                                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                                                                                                           |
| `select`  | `XOR<UserSelect, null>`                                 | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                              |
| `include` | `XOR<UserInclude, null>`                                | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                                 |

#### Return type

| Return type                     | Example                        | Description                                                     |
| ------------------------------- | ------------------------------ | --------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         |                                                                 |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Reference

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

#### Examples

##### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

### <inlinecode>delete</inlinecode>

`delete` deletes an existing database record. Even though the record is being deleted, `delete` still returns the object that was deleted.

#### Options

| Name      | Type                     | Required | Description                                                                      |
| --------- | ------------------------ | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | `XOR<UserSelect, null>`  | No       | Specifies which properties to include on the returned object.                    |
| `include` | `XOR<UserInclude, null>` | No       | Specifies which relations should be eagerly loaded on the returned object.       |

#### Reference

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### Return type

| Return type                     | Example                        | Description                                                                                                   |
| ------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| Javascript array object (typed) | `User`                         | The `User` record that was deleted.                                                                           |
| Javascript array object (plain) | `{ name: "Alice Wonderland" }` | Data from the `User` record that was deleted. Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception      |                                | Returned if record does not exist.                                                                            |

#### Remarks

- To delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

#### Examples

##### Delete the `User` record with an `id` of `1`

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### Delete the `User` record where `email` equals `else@prisma.io`

<CodeWithResult expanded="{true}">

<Cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</Cmd>

<CmdResult>

```json
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</CmdResult>

</CodeWithResult>

### <inlinecode>updateMany</inlinecode>

`updateMany` updates a batch of existing database records in bulk and returns the number of updated records.

#### Options

| Name    | Type                                                                    | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`                                                        | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                         |

#### Reference

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Examples

##### Update all `User` records where the `name` is `Alice` to `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### Update all `User` records where the `email` contains `prisma.io` and at least one related `Post` has more than 10 likes

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

#### Options

| Name    | Type             | Required | Description                                                                  |
| ------- | ---------------- | -------- | ---------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

```ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter the records to delete.

##### Delete all `User` records where the `name` is `Alice`

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>count</inlinecode>

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                     |
| ---------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                            |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                            |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                       |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (+ve value) or _end_ (-ve value) **either** of the list **or** from the `cursor` position if mentioned) |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                               |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                       |

#### Return type

| Return type | Example | Description           |
| ----------- | ------- | --------------------- |
| `number`    | `29`    | The count of records. |

#### Reference

```ts file=index.d.ts
export type FindManyUserArgs = {
  // select and include are excludeld
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

##### Count all `User` records:

```ts
const result = await prisma.user.count()
```

##### Count all `User` records with at least one published `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

### <inlinecode>aggregate</inlinecode>

#### Reference

`aggregate` accepts the following input type:

```ts
export type AggregateUserArgs = {
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  count?: true
  avg?: UserAvgAggregateInputType
  sum?: UserSumAggregateInputType
  min?: UserMinAggregateInputType
  max?: UserMaxAggregateInputType
}
```

#### Examples

##### Return `min` and `max` `profileViews` of all `User` records

<CodeWithResult>
<Cmd>

```ts file=script.ts
const minMaxAge = await prisma.user.aggregate({
  max: {
    profileViews: true,
  },
  min: {
    profileViews: true,
  },
});
```

</Cmd>
<CmdResult>


```js
{
    "max": {
        "profileViews": 440
    },
    "min": {
        "profileViews": 93
    }
}
```

</CmdResult>
</CodeWithResult>

### Return `sum` of all `profileViews` for all `User` records

<CodeWithResult>
<Cmd>

```ts file=script.ts
const setValue = await prisma.user.aggregate({
  sum: {
    profileViews: true,
  },
});
```

</Cmd>
<CmdResult>

```js
{
  "sum": {
    "profileViews": 9493
  }
}
```


</CmdResult>
</CodeWithResult>


## Model query options

### <inlinecode>select</inlinecode>

`select` defines which fields are included in the selection set that Prisma Client returns. For example, when you `create` new record, you can choose to return the entire record (the default selection set) or a subset of fields.

#### Remarks

- You cannot combine `select` and `include` on the same level.

#### Reference

```ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | FindManyPostArgs
}
```

#### Examples

##### Select the `name` and `profileViews` fields of a single `User` record

<CodeWithResult>
<Cmd>

```ts
const result = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    profileViews: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{
  name: "Alice",
  profileViews: 0
}
```

</CmdResult>
</CodeWithResult>

##### Select the `name` and `profileViews` fields of a multiple `User` records

<CodeWithResult>
<Cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
})
```

</Cmd>
<CmdResult>

```js
;[
  {
    email: 'alice@prisma.io',
    role: 'ADMIN',
  },
  {
    email: 'bob@prisma.io',
    role: 'USER',
  },
]
```

</CmdResult>
</CodeWithResult>

Here's how you can include additional fields of a relation:

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
      },
    },
  },
})
```

In this case, the result might look as follow:

```ts
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      { id: 1, title: 'Hello World' },
      { id: 2, title: 'Bye bye' },
    ],
  },
  {
    id: 2,
    name: 'Bob',
    posts: [],
  },
]
```

You can also nest the `include` option inside of the `select` option:

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      include: {
        author: true,
      },
    },
  },
})
```

This would result in the following structure for the `result` object:

```js
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      {
        id: 1,
        title: 'Hello World',
        published: true,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'ADMIN',
          coinflips: [true, false],
          profileViews: 0,
        },
      },
      {
        id: 2,
        title: 'Bye bye',
        published: false,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'USER',
          coinflips: [],
          profileViews: 0,
        },
      },
    ],
  },
]
```

### <inlinecode>include</inlinecode>

#### Examples

##### Include the `posts` and `profile` relation when loading `User` records

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true, // Returns all fields for all posts
    profile: true, // Returns all Profile fields
  },
})
```

##### Include the `posts` relation on the returned objects when creating a new `User` record with two `Post` records

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [{ title: 'This is my first post' }, { title: 'Here comes a second post' }],
    },
  },
  include: { posts: true }, // Returns all fields for all posts
})
```

### <inlinecode>where</inlinecode>

### <inlinecode>orderBy</inlinecode>

#### Inputs

| Name   | Description                  |
| ------ | ---------------------------- |
| `asc`  | Sort ascending (A &rarr; Z)  |
| `desc` | Sort descending (Z &rarr; A) |

#### Reference

```ts
orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
```

```ts
export type UserOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  email?: SortOrder
  profileViews?: SortOrder
  role?: SortOrder
  coinflips?: SortOrder
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```

#### Examples

##### Sort `User` by `email` field

The following example returns all `User` records sorted by `email` ascending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
})
```

The following example returns all `User` records sorted by `email` descending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'desc',
  },
})
```

##### Sort `User` by multiple fields - `email` _and_ `role`

The following example sorts users by two fields - first `email`, then `role`:

<CodeWithResult>

<Cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      email: 'desc',
    },
    {
      role: 'desc',
    },
  ],
})
```

</Cmd>

<CmdResult>

```json
[
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  }
]
```

</CmdResult>

</CodeWithResult>

The order of sorting parameters matters - the following query sorts by `role`, then `email`. Not the difference in the results:

<CodeWithResult>

<Cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      role: 'desc',
    },
    {
      email: 'desc',
    },
  ],
})
```

</Cmd>

<CmdResult>

```json
[
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  }
]
```

</CmdResult>

</CodeWithResult>

##### Sort `User` by `email`, select `name` and `email`

The following example returns all the `name` and `email` fields of all `User` records, sorted by `email`:

<CodeWithResult>

<Cmd>

```ts
const users3 = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  select: {
    name: true,
    email: true,
  },
})
```

</Cmd>

<CmdResult>

```js
;[
  {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
  {
    name: 'Ariadne',
    email: 'ariadne@prisma.io',
  },
  {
    name: 'Bob',
    email: 'bob@prisma.io',
  },
]
```

</CmdResult>

</CodeWithResult>

##### Sort `User` records by `email` and sort nested `Post` records by `title`

The following example:

- Returns all `User` records sorted by `email`
- For each `User` record, returns the `title` field of all nested `Post` records sorted by `title`

<CodeWithResult>

<Cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

</Cmd>

<CmdResult>

```json
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

</CmdResult>

</CodeWithResult>

##### Sort one user's nested list of `Post` records

The following example retrieves a single `User` record by ID, as well as a list of nested `Post` records sorted by `title`:

<CodeWithResult>

<Cmd>

```ts
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
        published: true,
      },
    },
  },
})
```

</Cmd>

<CmdResult>

```json
{
  "email": "sarah@prisma.io",
  "id": 1,
  "name": "Sarah",
  "extendedProfile": null,
  "role": "USER",
  "posts": [
    {
      "title": "Prisma Day 2020",
      "published": false
    },
    {
      "title": "My first post",
      "published": false
    },
    {
      "title": "All about databases",
      "published": true
    }
  ]
}
```

</CmdResult>

</CodeWithResult>

##### Sort by `enum`

The following sorts all `User` records by `role` (an `enum`):

<CodeWithResult>

<Cmd>

```ts
const sort = await prisma.user.findMany({
  orderBy: {
    role: 'desc',
  },
  select: {
    email: true,
    role: true,
  },
})
```

</Cmd>

<CmdResult>

```json
[
  {
    "email": "emma@prisma.io",

    "role": "USER"
  },
  {
    "email": "suma@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "kwame@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "pearl@prisma.io",
    "role": "ADMIN"
  }
]
```

</CmdResult>

</CodeWithResult>

### <inlinecode>distinct</inlinecode>

#### Reference

```ts
  distinct?: Enumerable<UserDistinctFieldEnum>
```

```ts
export declare const UserDistinctFieldEnum: {
  id: 'id'
  name: 'name'
  email: 'email'
  profileViews: 'profileViews'
  role: 'role'
  coinflips: 'coinflips'
}
```

#### Examples

##### Select distinct on a single field

The following example returns all distinct `city` fields, and selects only the `city` and `country` fields:

<CodeWithResult  expanded={true}>

<Cmd>

```ts
const distinctCities = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city'],
})
```

</Cmd>

<CmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Lyon', country: 'France' },
]
```

</CmdResult>

</CodeWithResult>

##### Select distinct on multiple fields

The following example returns all distinct `city` _and_ `country` field combinations, and selects only the `city` and `country` fields:

<CodeWithResult expanded={true}>

<Cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</Cmd>

<CmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</CmdResult>

</CodeWithResult>

Note that there is now a "Paris, Denmark" in addition to "Paris, France":

##### Select distinct in combination with a filter

The following example returns all distinct `city` _and_ `country` field combinations where the user's email contains `"prisma.io"`, and selects only the `city` and `country` fields:

<CodeWithResult>

<Cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</Cmd>

<CmdResult>

```js
;[
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</CmdResult>

</CodeWithResult>

## Nested queries

### <inlinecode>create</inlinecode>

A nested `create` query adds a new related record or set of records to a parent record.

#### Remarks

- `create` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.

#### Examples

##### Create a new `User` record with a new `Profile` record

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    profile: {
|     create: { bio: 'Hello World' },
    },
  },
})
```

##### Create a new `Profile` record with a new `User` record

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
|     create: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `User` record with a new `Post` record

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
|     create: { title: 'Hello World' },
    },
  },
})
```

##### Create a new `User` record with two new `Post` records

Because it's a one-to-many relation, you can also create several `Post` records at once by passing an array to `create`:

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
|     create: [{ title: 'This is my first post' }, { title: 'Here comes a second post' }],
    },
  },
})
```

##### Update an existing `User` record by creating a new `Profile` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
|     create: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by creating a new `Post` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
|      create: { title: 'Hello World' },
    },
  },
})
```

### <inlinecode>set</inlinecode>

#### Examples

##### Update an existing `User` record by disconnecting any previous `Post` records and connecting two other exiting ones

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      set: [{ id: 32 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connect</inlinecode>

A nested `connect` query connects a record to an existing related record by specifying an ID or unique identifier.

#### Remarks

- `connect` is available as a nested query when you create a new parent record or update an existing parent record.
- If the related record does not exist, Prisma Client throws an exception:

  ```
  The required connected records were not found. Expected 1 records to be connected, found 0.
  ```

#### Examples

##### Create a new `Profile` record and connect it to an existing `User` record via unique field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `Profile` record and connect it to an existing `User` record via an ID field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { id: 42 }, // sets userId of Profile record
    },
  },
})
```

In [2.11.0](https://github.com/prisma/prisma/releases/2.11.0) and later, you can set the foreign key directly:

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    userId: 42,
  },
})
```

To use this feature, enable the `uncheckedScalarInputs` in your schema file as shown:

```prisma file=schema.prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["uncheckedScalarInputs"]
}
```

##### Create a new `Post` record and connect it to an existing `User` record

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connect: { id: 24 },
    },
  },
})
```

##### Update an existing `User` record by connecting it to two existing `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connect: [{ id: 24 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connectOrCreate</inlinecode>

`connectOrCreate` _either_ connects a record to an existing related record by ID or unique identifier _or_ creates a new related record if the record does not exist.

#### Examples

##### Create a new `Profile` record, then connect it to an existing `User` record _or_ create a new `User`

The following example:

1. Creates a `Profile`
2. Attempts to connect the profile to a `User` where the email address is `alice@prisma.io`
3. Creates a new user if a user if a matching user does not exist

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'The coolest Alice on the planet',
    user: {
      connectOrCreate: {
        where:  { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io'}
    },
  },
})
```

##### Create a new `Post` record and connect it to an existing `User` record, _or_ create a new `User`

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connectOrCreate: {
        where: { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io' },
      },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record, _or_ creating a new `Profile` record

The following example:

2. Attempts to connect the user to a `Profile` with an `id` of `20`
3. Creates a new profile if a matching profile does not exist

```ts
const updateUser = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connectOrCreate: {
        where: { id: 20 },
        create: {
          bio: 'The coolest Alice in town',
        },
      },
    },
  },
})
```

##### Update an existing `User` record by connect it to two existing `Post` records, or creating two new `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connectOrCreate: [
        {
          where: { id: 32 },
          create: { title: 'This is my first post' },
        },
        {
          where: { id: 19 },
          create: { title: 'This is my second post' },
        },
      ],
    },
  },
})
```

### <inlinecode>disconnect</inlinecode>

A nested `disconnect` query breaks the connection between a parent record and a related record, but does not delete either record.

#### Remarks

- `disconnect` is only available if the relation is optional.
- Prisma Client throws an exception if the provided ID or unique identifier is not connected:

  ```
  The records for relation `PostToUser` between the `User` and `Post` models are not connected.
  ```

#### Examples

##### Update an existing `User` record by disconnecting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'bob  @prisma.io' },
  data: {
    profile: {
      disconnect: true,
    },
  },
})
```

##### Update an existing `User` record by disconnecting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      disconnect: [{ id: 44 }, { id: 46 }],
    },
  },
})
```

### <inlinecode>update</inlinecode>

A nested `update` query updates one or more related records where the parent record's ID is `n`.

#### Remarks

- Nested `update` queries are only available in the context of a top-level `update` query (for example, `prisma.user.update(...)`).
- If the parent record does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

- If the related record that you want to update does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

#### Examples

##### Update an existing `User` record by updating the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      update: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      update: [
        {
          data: { published: true },
          where: { id: 32 },
        },
        {
          data: { published: true },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>upsert</inlinecode>

A nested `upsert` query updates a related record if it exists, or creates a new related record.

#### Examples

##### Update an existing `User` record by updating the `Profile` record it's connected to or creating a new one (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      upsert: {
        create: { bio: 'Hello World' },
        update: { bio: 'Hello World' },
      },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` record it's connected to or creating new ones (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      upsert: [
        {
          create: { title: 'This is my first post' },
          update: { title: 'This is my first post' },
          where: { id: 32 },
        },
        {
          create: { title: 'This is mt second post' },
          update: { title: 'This is mt second post' },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>delete</inlinecode>

A nested `delete` query deletes a related record. The parent record is not deleted.

#### Remarks

- `delete` is only available if the relation is optional.

#### Examples

##### Update an existing `User` record by deleting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      delete: true,
    },
  },
})
```

##### Update an existing `User` record by deleting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      delete: [{ id: 34 }, { id: 36 }],
    },
  },
})
```

### <inlinecode>updateMany</inlinecode>

#### Options

#### Remarks

#### Reference

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

### <inlinecode>deleteMany</inlinecode>

#### Options

#### Remarks

#### Reference

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

## Filter conditions and operators

`where`

### <inlinecode>equals</inlinecode>

Value equals `n`.

#### Examples

### <inlinecode>not</inlinecode>

Vaulue does not equal `n`.

### <inlinecode>in</inlinecode>

Value `n` exists in list.

#### Examples

##### Get `User` records where the `id` can be found in the following list: `[22, 91, 14, 2, 5]`

```ts file=script.ts
const getUser = await prisma.user.findMany({
  where: {
    id: { in: [22, 91, 14, 2, 5] },
  },
})
```

##### Get `User` records where the `name` can be found in the following list: `['Saqui', 'Clementine', 'Bob']`

```ts file=script.ts
const getUser = await prisma.user.findMany({
  where: {
    name: { in: ['Saqui', 'Clementine', 'Bob'] },
  },
})
```

###### Get a `User` record where at least one `Post` has at least one specified `Category`

```ts file=script.ts
const getUser = await prisma.user.findMany({
  where: { // Find users where..
    posts: {
      some: { // ..at least one (some) posts..
        categories: {
          some: { // .. have at least one category ..
            name: {
              in: ['Food', 'Introductions'], // .. with a name that matches one of the following.
            },
          },
        },
      },
    },
  },
})
```

### <inlinecode>notIn</inlinecode>

Value `n` does not exist in list.

#### Examples

##### Get `User` records where the `id` can **not** be found in the following list: `[22, 91, 14, 2, 5]`

```ts file=script.ts
const getUser = await prisma.user.findMany({
  where: {
    id: { notIn: [22, 91, 14, 2, 5] },
  },
})
```

### <inlinecode>lt</inlinecode>

Value `n` is less than `x`.

### <inlinecode>lte</inlinecode>

Value `n` is less than _or_ equal to `x`.

### <inlinecode>gt</inlinecode>

Value `n` is greater than `x`.

### <inlinecode>gte</inlinecode>

Value `n` is greater than _or_ equal to `x`.

#### Examples

##### Retrieve all `Post` records where `date_created` is greater than March 19th, 2020

```js
const result = await prisma.post.findMany({
  where: {
    date_created: {
      gte: new Date('2020-03-19T14:21:00+0200') /* Includes time offset for UTC */,
    },
  },
})
```

### <inlinecode>contains</inlinecode>

Value `n` contains `x`.

#### Examples

##### Count all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.count({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

### <inlinecode>mode</inlinecode>

#### Examples

##### Retrieve all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

### <inlinecode>startsWith</inlinecode>

#### Examples

##### Retrieve all `Post` records where `title` starts with `Pr` (such as `Prisma`)

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      startsWith: 'Pr',
    },
  },
})
```

### <inlinecode>endsWith</inlinecode>

#### Retrieve all `User` records where `email` ends with `prisma.io`

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

### <inlinecode>AND</inlinecode>

All conditions must return`true`. Alternatively, pass a list of objects into the `where` clause - the `AND` operator is [not required](filtering#no-and).

#### Examples

##### Retrieve all `Post` records where the `content` field contains `Prisma` and `published` is `false`

```js
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
})
```

The following format returns the same results as above **without** the `AND` operator:

<a id="#no-and"></a>

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'Prisma',
    },
    published: {
      equals: false,
    },
  },
})
```

##### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>OR</inlinecode>

One or more conditions must return `true`.

#### Examples

##### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
})
```

##### Retrieve all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

The following example combines `OR` and `NOT`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>NOT</inlinecode>

All conditions must return `false`.

#### Examples

##### Retrieve all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Retrieve all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`, and the related `User` record' email address does not contain `sarah`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
    user: {
      NOT: {
        email: {
          contains: 'sarah',
        },
      },
    },
  },
  include: {
    user: true,
  },
})
```

### <inlinecode>some</inlinecode>

Returns all records where **one or more** ("some") _related_ records match filtering criteria.

#### Reference

```ts
export type PostFilter = {
  every?: PostWhereInput | null
|  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### Examples

##### Retrieve all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```ts
  const result = await prisma.user.findMany({
    where: {
      post: {
          every: {
            published: true
          }
        some: {
          content: {
            contains: "Prisma"
          }
        }
      }
    }
  }
```

### <inlinecode>every</inlinecode>

Returns all records where **all** ("every") _related_ records match filtering criteria.

#### Reference

```ts
export type PostFilter = {
|  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### Examples

##### Retrieve all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```ts
  const result = await prisma.user.findMany({
    where: {
      post: {
          every: {
            published: true
          }
        some: {
          content: {
            contains: "Prisma"
          }
        }
      }
    }
  }
```

### <inlinecode>none</inlinecode>

Returns all records where **zero** _related_ records match filtering criteria.

#### Reference

```ts
export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
|  none?: PostWhereInput | null
}
```

#### Examples

## Atomic number operations

Atomic operations on update is available for number field types (`Float` and `Int`). This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client   | Operation           | Value  |
| :------- | :------------------ | :----- |
| Client 1 | **Get** field value | `21`   |
| Client 2 | **Get** field value | `21`   |
| Client 2 | **Set** field value | `22`   |
| Client 1 | **Set** field value | `22` ✘ |

The value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client   | Operation                   | Value              |
| :------- | :-------------------------- | :----------------- |
| Client 1 | **Get and set** field value | `21` &rarr; `22`   |
| Client 2 | **Get and set** field value | `22` &rarr; `23` ✔ |

</details>

### Options

| Option      | Description                                                   |
| :---------- | :------------------------------------------------------------ |
| `increment` | Adds `n` to the current value.                                |
| `decrement` | Subtacts `n` from the current value.                          |
| `multiply`  | Multiplies the current value by `n`.                          |
| `divide`    | Divides the current value by `n`.                             |
| `set`       | Sets the current field value. Identical to `{ myField : n }`. |

### Reference

```ts file=index.d.ts
export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

### Remarks

- You can only perform **one** atomic update per field, per query.

### Examples

#### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

#### Set all `count` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```

## Client methods

- All client-level methods are prefixed by `$`

### <inlinecode>\$disconnect()</inlinecode>

### <inlinecode>\$connect()</inlinecode>

### <inlinecode>\$on()</inlinecode>

### <inlinecode>\$use()</inlinecode>

### <inlinecode>\$executeRaw()</inlinecode>

### <inlinecode>\$queryRaw()</inlinecode>

### <inlinecode>\$transaction()</inlinecode>
