---
title: 'Prisma Client API reference'
metaTitle: 'Prisma Client API (Reference)'
metaDescription: 'API reference documentation for Prisma Client.'
tocDepth: 2
toc: true
---

<TopBlock>

The Prisma Client API reference documentation is based on the following schema:

```prisma
model User {
  id           Int              @id @default(autoincrement())
  name         String?
  email        String           @unique
  profileViews Int              @default(0)
  role         Role             @default(USER)
  coinflips    Boolean[]
  posts        Post[]
  city         String
  country      String
  profile      ExtendedProfile?
  pets         Json
}

model ExtendedProfile {
  id     Int     @id @default(autoincrement())
  userId Int?    @unique
  bio    String?
  User   User?   @relation(fields: [userId], references: [id])
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
  comments  Json
  views     Int     @default(0)
  likes     Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

All example generated types (such as `UserSelect` and `UserWhereUniqueInput`) are based on the `User` model.

</TopBlock>

## <inlinecode>PrismaClient</inlinecode>

This section describes the `PrismaClient` constructor and its parameters.

### Remarks

- Parameters are validated at runtime.

### <inlinecode>datasources</inlinecode>

Programmatically overrides properties of the `datasource` block in the `schema.prisma` file - for example, as part of an integration test. See also: [Data sources](/concepts/components/prisma-schema/data-sources) <span class="concept"></span>

#### Properties

| Example property | Example value                 | Description                                                                   |
| ---------------- | ----------------------------- | ----------------------------------------------------------------------------- |
| `db`             | `{ url: 'file:./dev_qa.db' }` | The database [connection URL](/reference/database-reference/connection-urls). |

#### Remarks

- You must re-generate the Prisma Client each time you add or rename a data source. Datasource names are included in the generated client.
- If you named your `datasource` block something else in the schema, replace `db` with the name of your `datasource` block.

#### Examples

##### Programmatically override a datasource `url`

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: 'file:./dev_qa.db',
    },
  },
})
```

Based on the following `datasource` block:

```prisma
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

### <inlinecode>log</inlinecode>

Determines the type and level of logging. See also: [Logging](/concepts/components/prisma-client/working-with-prismaclient/logging) <span class="concept"></span>

#### Options

| Option                   | Example                                                                  | Description |
| ------------------------ | ------------------------------------------------------------------------ | ----------- |
| Array of log levels      | `[ "info", "query" ]`                                                    |             |
| Array of log definitions | `[ { level: "info", emit: "event" }, { level: "warn", emit: "stdout" }]` |             |

##### Log levels

| Name    | Example                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `query` | Logs all queries run by Prisma. <br /><br /> For relational databases this logs all SQL queries. Example: <br />`prisma:query SELECT "public"."User"."id", "public"."User"."email" FROM "public"."User" WHERE ("public"."User"."id") IN (SELECT "t0"."id" FROM "public"."User" AS "t0" INNER JOIN "public"."Post" AS "j0" ON ("j0"."authorId") = ("t0"."id") WHERE ("j0"."views" > $1 AND "t0"."id" IS NOT NULL)) OFFSET $2` <br /> For MongoDB this logs queries using the [`mongosh` shell](https://docs.mongodb.com/mongodb-shell/#mongodb-binary-bin.mongosh) format. Example: <br /> `prisma:query db.User.deleteMany({ _id: ( $in: [ “6221ce49f756b0721fc00542”, ], }, })` |
| `info`  | Example: <br />`prisma:info Started http server on http://127.0.0.1:58471`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `warn`  | Warnings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `error` | Errors.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

##### Emit formats

| Name     | Description                                                   |
| -------- | ------------------------------------------------------------- |
| `stdout` | See: [stdout](https://en.wikipedia.org/wiki/Standard_streams) |
| `event`  | Raises an event that you can subscribe to.                    |

#### Reference

```ts file=index.d.ts
log?: Array<LogLevel | LogDefinition>
```

```ts file=index.d.ts
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}
```

##### Event types

The `query` event type:

```ts file=index.d.ts
export type QueryEvent = {
  timestamp: Date
  query: string // Query sent to the database
  params: string // Query parameters
  duration: number // Time elapsed (in milliseconds) between client issuing query and database responding - not only time taken to run query
  target: string
}
```

Note that for MongoDB, the `params` and `duration` fields will be undefined.

All other log level event types:

```ts file=index.d.ts
export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
```

#### Examples

##### Log `query` and `info` to `stdout`

<CodeWithResult>

<cmd>

```ts highlight=3;normal;
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query', 'info'] })

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

</cmd>

<cmdResult>

```code no-copy
prisma:info  Starting a postgresql pool with 13 connections.
prisma:info  Started http server
prisma:query SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 ORDER BY "public"."User"."coinflips" ASC OFFSET $1) AS "sub"
```

</cmdResult>

</CodeWithResult>

##### Log a `query` event to console

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [{ level: 'query', emit: 'event' }],
})

prisma.$on('query', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

</cmd>

<cmdResult>

```js no-copy
{
  timestamp: 2020-11-17T10:32:10.898Z,
  query: 'SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 OFFSET $1) AS "sub"',
  params: '[0]',
  duration: 5,
  target: 'quaint::connector::metrics'
}
```

</cmdResult>

</CodeWithResult>

##### Log `info`, `warn`, and `error` events to console

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'warn', emit: 'event' },
    { level: 'info', emit: 'event' },
    { level: 'error', emit: 'event' },
  ],
})

prisma.$on('warn', (e) => {
  console.log(e)
})

prisma.$on('info', (e) => {
  console.log(e)
})

prisma.$on('error', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

</cmd>
<cmdResult>

```js no-copy
{
  timestamp: 2020-11-17T10:33:24.592Z,
  message: 'Starting a postgresql pool with 13 connections.',
  target: 'quaint::pooled'
}
{
  timestamp: 2020-11-17T10:33:24.637Z,
  message: 'Started http server',
  target: 'query_engine::server'
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>errorFormat</inlinecode>

Determines the level and formatting of errors returned by Prisma.

#### Error formats

| Name                  | Description                                    |
| --------------------- | ---------------------------------------------- |
| `undefined`           | If it's not defined, the default is colorless. |
| `pretty`              | Enables pretty error formatting.               |
| `colorless` (default) | Enables colorless error formatting.            |
| `minimal`             | Enables minimal error formatting.              |

#### Reference

```ts file=index.d.ts
errorFormat?: ErrorFormat
```

```ts file=index.d.ts
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
```

#### Examples

##### No error formatting

```ts
const prisma = new PrismaClient({
  // Defaults to colorless
})
```

##### `pretty` error formatting

```ts
const prisma = new PrismaClient({
  errorFormat: 'pretty',
})
```

##### `colorless` error formatting

```ts
const prisma = new PrismaClient({
  errorFormat: 'colorless',
})
```

##### `minimal` error formatting

```ts
const prisma = new PrismaClient({
  errorFormat: 'minimal',
})
```

### <inlinecode>rejectOnNotFound</inlinecode>

<Admonition type="info">

**Deprecated:** `rejectOnNotFound` is deprecated in v4.0.0. From v4.0.0, use the queries [`findUniqueOrThrow`](#finduniqueorthrow) or [`findFirstOrThrow`](#findfirstorthrow).

</Admonition>

Use the `rejectOnNotFound` parameter to configure `findUnique` and/or `findFirst` to throw an error if the record was not found. By default, both operations return `null` if the record is not found.

### Remarks

- You can configure `rejectOnNotFound` on a per-request level for both [`findUnique`](#findunique) and [`findFirst`](#findfirst)

#### Options

| Option               | Description                                                                                 |
| -------------------- | ------------------------------------------------------------------------------------------- |
| `RejectOnNotFound`   | Enable globally (`true` / `false`) _or_ throw a custom error.                               |
| `RejectPerOperation` | Enable per operation (`true` / `false`) _or_ throw a custom error per operation, per model. |

#### Reference

```ts file=index.d.ts
rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
```

#### Examples

##### Enable globally for `findUnique` and `findFirst`

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: true,
})
```

##### Enable globally for a specific operation

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findUnique: true,
  },
})
```

##### Throw a custom error per model and operation if record is not found

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findFirst: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
    findUnique: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
  },
})
```

## Model queries

Use model queries to perform CRUD operations on your models. See also: [CRUD](/concepts/components/prisma-client/crud) <span class="concept"></span>

### <inlinecode>findUnique</inlinecode>

`findUnique` query lets you retrieve a single database record:

- By _ID_
- By a _unique_ attribute

`findUnique` replaced `findOne` in version [2.12.0](https://github.com/prisma/prisma/releases/tag/2.12.0).

#### Remarks

- Prisma's dataloader [automatically batches `findUnique` queries](/guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader) with the same `select` and `where` parameters.
- If you want the query to throw an error if the record is not found, then consider using [`findUniqueOrThrow`](#finduniqueorthrow) instead.

#### Options

| Name                            | Example type (`User`)    | Required | Description                                                                                                                                                                                                                                                       |
| ------------------------------- | ------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`                         | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput)                                         |
| `select`                        | `XOR<UserSelect, null>`  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                 |
| `include`                       | `XOR<UserInclude, null>` | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                 |
| `rejectOnNotFound` (deprecated) | `RejectOnNotFound`       | No       | If true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](#rejectonnotfound). <br></br>**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findUniqueOrThrow`](#finduniqueorthrow) instead. |

#### Return type

| Return type               | Example                    | Description                                                                                                                                                       |
| ------------------------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     |                                                                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return.                                                                                                   |
| `null`                    | `null`                     | Record not found                                                                                                                                                  |
| Error                     |                            | If `rejectOnNotFound` is true, `findUnique` throws an error (`NotFoundError` by default, [customizable globally](#rejectonnotfound)) instead of returning `null`. |

#### Reference

`findUnique` accepts the following input type:

```ts file=index.d.ts
export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### Examples

##### Get the `User` record with an `id` of `42`

```ts
const result = await prisma.user.findUnique({
  where: {
    id: 42,
  },
})
```

##### Get the `User` record with an `email` of `alice@prisma.io`

```ts
const result = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@unique`)

<details><summary>Expand for example User model with a @@unique block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    fullname: {
      // name property of @@unique attribute - default is firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@id`)

<details><summary>Expand for example User model with an @@id block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findUniqueOrThrow</inlinecode>

<Admonition type="info">

We introduced `findUniqueOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.

</Admonition>

`findUniqueOrThrow` retrieves a single data record in the same way as [`findUnique`](#findunique). However, if the query does not find a record, it returns `NotFoundError: No User found error`.

`findUniqueOrThrow` differs from `findUnique` as follows:

- Its return type is non-nullable. For example, `post.findUnique()` can return `post` or `null`, but `post.findUniqueOrThrow()` always returns `post`.
- It is not compatible with sequential operations in the [`$transaction` API](/concepts/components/prisma-client/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:

  ```ts
   $transaction(async (prisma) => {
     await prisma.model.create({ data: { ... });
     await prisma.model.findUniqueOrThrow();
   })
  ```

### <inlinecode>findFirst</inlinecode>

`findFirst` returns the first record in a list that matches your criteria.

#### Remarks

- If you want the query to throw an error if the record is not found, then consider using [`findFirstOrThrow`](#findfirstorthrow) instead.

#### Options

| Name                            | Example type (`User`)                                        | Required | Description                                                                                                                                                                                                                                                     |
| ------------------------------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `distinct`                      | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                                                                       |
| `where`                         | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                                                                            |
| `cursor`                        | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                                                                            |
| `orderBy`                       | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                                                                               |
| `include`                       | `XOR<UserInclude, null>`                                     | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                               |
| `select`                        | `XOR<UserSelect, null>`                                      | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                               |
| `skip`                          | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                                                                       |
| `take`                          | `number`                                                     | No       | Specifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list.                      |
| `rejectOnNotFound` (deprecated) | `RejectOnNotFound`                                           | No       | If true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](#rejectonnotfound). <br></br>**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findFirstOrThrow`](#findfirstorthrow) instead. |

#### Return type

| Return type               | Example                    | Description                                                                                                                                                       |
| ------------------------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     | Specifies which properties to include on the returned object.                                                                                                     |
| JavaScript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return.                                                                                                   |
| `null`                    | `null`                     | Record not found                                                                                                                                                  |
| Error                     |                            | If `rejectOnNotFound` is true, `findUnique` throws an error (`NotFoundError` by default, [customizable globally](#rejectonnotfound)) instead of returning `null`. |

#### Remarks

- `findFirst` calls `findMany` behind the scenes and accepts the same query options.
- Passing in a negative `take` value when you use a `findFirst` query reverses the order of the list.

#### Reference

`findFirst` accepts the following input type:

```ts file=index.d.ts
export type UserFindFirstArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Get the first `User` record where the `name` is `Alice`

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### Get the first `Post` record where the `title` starts with `A test`, reverse the list with `take`

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function main() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // Reverse the list
  })
}

main()
```

### <inlinecode>findFirstOrThrow</inlinecode>

<Admonition type="info">

We introduced `findFirstOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.

</Admonition>

`findFirstOrThrow` retrieves the first record in a list in the same way as [`findFirst`](#findfirst). However, if the query does not find a record, it returns `NotFoundError: No User found error`.

`findFirstOrThrow` differs from `findFirst` as follows:

- Its return type is non-nullable. For example, `post.findFirst()` can return `post` or `null`, but `post.findFirstOrThrow` always returns `post`.
- It is not compatible with sequential operations in the [`$transaction` API](/concepts/components/prisma-client/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:

```ts
prisma.$transaction(async (tx) => {
  await tx.model.create({ data: { ... });
  await tx.model.findFirstOrThrow();
})
```

### <inlinecode>findMany</inlinecode>

<AlgoliaTerm name="apiReference" value="findMany" />

`findMany` returns a list of records.

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                               |
| ---------- | ------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `select`   | `XOR<PostSelect, null>`                                       | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                         |
| `include`  | `XOR<PostInclude, null>`                                      | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                         |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                 |

#### Return type

| Return type                     | Example                      | Description                                                     |
| ------------------------------- | ---------------------------- | --------------------------------------------------------------- |
| JavaScript array object (typed) | `User[]`                     |                                                                 |
| JavaScript array object (plain) | `[{ title: "Hello world" }]` | Use `select` and `include` to determine which fields to return. |
| Empty array                     | `[]`                         | No matching records found.                                      |

#### Reference

`findMany` accepts the following input type:

```ts file=index.d.ts
export type UserFindManyArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Get all `User` records where the `name` is `Alice`

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>create</inlinecode>

`create` creates a new database record.

#### Options

| Name                  | Type                                                     | Required | Description                                                                                                                                                                                                                                                                   |
| --------------------- | -------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| [`select`](#select)   | `XOR<UserSelect, null>`                                  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                             |
| [`include`](#include) | `XOR<UserInclude, null>`                                 | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                             |

#### Return type

| Return type               | Example                        | Description                                                     |
| ------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Remarks

- You can also perform a nested [`create`](#create-1) - for example, add a `User` and two `Post` records at the same time.

#### Reference

`create` accepts the following input type:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### Examples

##### Create a single new record with the only required field `email`

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### Create multiple new records

Prisma Client does not yet support batch inserts at a database level. Follow [issue #332 on GitHub](https://github.com/prisma/prisma-client-js/issues/332) for updates.

The following example results in **two** `INSERT` statements:

<CodeWithResult expanded={true}>

<cmd>

```ts
import { Prisma, PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: Prisma.UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async (user) => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

</cmd>

<cmdResult>

```sql no-copy
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</cmdResult>

</CodeWithResult>

### <inlinecode>update</inlinecode>

`update` updates an existing database record.

#### Options

| Name                  | Type                                                   | Required | Description                                                                                                                                                                                                               |
| --------------------- | ------------------------------------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                 |
| `where`               | `UserWhereUniqueInput`                                 | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput) |
| [`select`](#select)   | `XOR<UserSelect, null>`                                | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                         |
| [`include`](#include) | `XOR<UserInclude, null>`                               | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                         |

#### Return type

| Return type                | Example                        | Description                                                     |
| -------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed)  | `User`                         |                                                                 |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception |                                | Exception is thrown if record does not exist.                   |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-number-operations) to prevent race conditions.
- You can also perform a nested [`update`](#update-1) - for example, update a user and that user's posts at the same time.

#### Reference

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

### <inlinecode>upsert</inlinecode>

`upsert` updates an existing _or_ creates a new database record.

#### Options

| Name                  | Type                                                    | Required | Description                                                                                                                                                                                                                                                                |
| --------------------- | ------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`              | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `update`              | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                                                                  |
| `where`               | `UserWhereUniqueInput`                                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput)                                                  |
| [`select`](#select)   | `XOR<UserSelect, null>`                                 | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                          |
| [`include`](#include) | `XOR<UserInclude, null>`                                | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                          |

#### Return type

| Return type               | Example                        | Description                                                     |
| ------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-number-operations) to prevent race conditions.
- If two or more upsert operations happen at the same time and the record doesn't already exist, then a race condition might happen. As a result, one or more of the upsert operations might throw a unique key constraint error. Your application code can catch this error and retry the operation. [Learn more](#unique-key-constraint-errors-on-upserts).

#### Reference

`upsert` accepts the following input type:

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### Examples

##### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

#### Unique key constraint errors on upserts

##### Problem

If multiple upsert operations happen at the same time and the record doesn't already exist, then one or more of the operations might return a [unique key constraint error](/reference/api-reference/error-reference#p2002).

##### Cause

When Prisma does an upsert, it first checks whether that record already exists in the database. To make this check, Prisma performs a read operation with the `where` clause from the upsert operation. This has two possible outcomes, as follows:

- If the record does not exist, then Prisma creates that record.
- If the record exists, then Prisma updates it.

When your application tries to perform two or more concurrent upsert operations, then a race condition might happen where two or more operations do not find the record and therefore try to create that record. In this situation, one of the operations succesfully creates the new record but the other operations fail and return a unique key constraint error.

##### Solution

Handle the P2002 error in your application code. When it occurs, retry the upsert operation to update the row.

### <inlinecode>delete</inlinecode>

`delete` deletes an existing database record. You can delete a record:

- By _ID_
- By a _unique_ attribute

To delete records that match a certain criteria, use [`deleteMany`](#deletemany) with a filter.

#### Options

| Name                  | Type                     | Required | Description                                                                                                                                                                                                               |
| --------------------- | ------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`               | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput) |
| [`select`](#select)   | `XOR<UserSelect, null>`  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                         |
| [`include`](#include) | `XOR<UserInclude, null>` | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                         |

#### Return type

| Return type                | Example                        | Description                                                                                                   |
| -------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed)  | `User`                         | The `User` record that was deleted.                                                                           |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | Data from the `User` record that was deleted. Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception |                                | Throws an exception if record does not exist.                                                                 |

#### Remarks

- To delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

#### Reference

`delete` accepts the following input type:

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Delete the `User` record with an `id` of `1`

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### Delete the `User` record where `email` equals `else@prisma.io`

The following query deletes a specific user record and uses `select` to return the `name` and `email` of the deleted user:

<CodeWithResult expanded="{true}">

<cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</cmd>

<cmdResult>

```json no-copy
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</cmdResult>

</CodeWithResult>

### <inlinecode>createMany</inlinecode>

`createMany` creates multiple records in a transaction.

#### Options

| Name              | Type                              | Required | Description                                                                                                                                                                                                                                                                   |
| ----------------- | --------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`            | `Enumerable<UserCreateManyInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `skipDuplicates?` | `boolean`                         | No       | Do not insert records with unique fields or ID fields that already exist. Only supported by databases that support [`ON CONFLICT DO NOTHING`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT).                                                           |

#### Return type

| Return type    | Example        | Description                               |
| -------------- | -------------- | ----------------------------------------- |
| `BatchPayload` | `{ count: 3 }` | A count of the number of records created. |

#### Remarks

- `createMany` is not supported by SQLite.
- You **cannot** create or connect relations - you cannot nest `create`, `createMany`, `connect`, `connectOrCreate` inside a top-level `createMany`
- You can nest a [`createMany`](#createmany-1) inside an `update` or `create` query - for example, add a `User` and two `Post` records at the same time.

#### Reference

`createMany` accepts the following input type:

```ts file=index.d.ts
export type UserCreateManyArgs = {
  data: Enumerable<UserCreateManyInput>
  skipDuplicates?: boolean
}
```

#### Examples

##### Create several new users

```ts
const users = await prisma.user.createMany({
  data: [
    { name: 'Sonali', email: 'sonali@prisma.io' },
    { name: 'Alex', email: 'alex@prisma.io' },
  ],
})
```

### <inlinecode>updateMany</inlinecode>

`updateMany` updates a batch of existing database records in bulk and returns the number of updated records.

#### Options

| Name    | Type                                                                    | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`                                                        | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                         |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

`updateMany` accepts the following input type:

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### Examples

##### Update all `User` records where the `name` is `Alice` to `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### Update all `User` records where the `email` contains `prisma.io` and at least one related `Post` has more than 10 likes

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

`deleteMany` deletes multiple records in a transaction.

#### Options

| Name    | Type             | Required | Description                                                                  |
| ------- | ---------------- | -------- | ---------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

`deleteMany` accepts the following input type:

```ts file=index.d.ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### Examples

##### Delete all `User` records

```ts
const deletedUserCount = await prisma.user.deleteMany({})
```

##### Delete all `User` records where the `name` is `Alice`

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter the records to delete.

### <inlinecode>count</inlinecode>

#### Options

| Name      | Type                                                          | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `cursor`  | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `skip`    | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `orderBy` | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `select`  | `UserCountAggregateInputType`                                 | No       | Select which fields to count (non-`null` values) - you can also count `_all`.                                                                                                                             |

#### Return type

| Return type                    | Example                  | Description                   |
| ------------------------------ | ------------------------ | ----------------------------- |
| `number`                       | `29`                     | The count of records.         |
| `UserCountAggregateOutputType` | `{ _all: 27, name: 10 }` | Returned if `select` is used. |

#### Reference

`count` accepts the following input type:

```ts file=index.d.ts
export type UserFindManyArgs = {
  // select and include are excluded
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}

export type UserCountAggregateOutputType = {
  id: number
  name: number | null
  email: number | null
  profileViews: number
  role: number | null
  coinflips: number | null
  testing: number | null
  city: number | null
  country: number | null
  _all: number
}
```

#### Examples

##### Count all `User` records

```ts
const result = await prisma.user.count()
```

##### Count all `User` records with at least one published `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

##### Use `select` to perform three separate counts

The following query returns:

- A count of all records (`_all`)
- A count of all records with non-`null` `name` fields
- A count of all records with non-`null` `city` fields

```ts
const c = await prisma.user.count({
  select: {
    _all: true,
    city: true,
    name: true,
  },
})
```

### <inlinecode>aggregate</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#aggregate) <span class="concept"></span>

#### Options

| Name      | Type                                                         | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `cursor`  | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `skip`    | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `_count`  | `true`                                                       | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`    | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`    | `UserSumAggregateInputType`                                  | No       | Returns the sume of all values of the specified field.                                                                                                                                                    |
| `_min`    | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`    | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### Reference

`aggregate` accepts the following input type:

```ts file=index.d.ts
export type UserAggregateArgs = {
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### Examples

##### Return `_min`, `_max`, and `_count` of `profileViews` of all `User` records

<CodeWithResult>
<cmd>

```ts
const minMaxAge = await prisma.user.aggregate({
  _count: {
    _all: true,
  },
  _max: {
    profileViews: true,
  },
  _min: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  _count: { _all: 29 },
  _max: { profileViews: 90 },
  _min: { profileViews: 0 }
}
```

</cmdResult>
</CodeWithResult>

##### Return `_sum` of all `profileViews` for all `User` records

<CodeWithResult>
<cmd>

```ts
const setValue = await prisma.user.aggregate({
  _sum: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  "_sum": {
    "profileViews": 9493
  }
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>groupBy</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#group-by) <span class="concept"></span>

#### Options

| Name      | Type                                                         | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property that is also present in `by`.                                                                                                                            |
| `by`      | `Array<UserScalarFieldEnum>`                                 | No       | Specifies the field or combination of fields to group records by.                                                                                                                                         |
| `having`  | `UserScalarWhereWithAggregatesInput`                         | No       | Allows you to filter groups by an aggregate value - for example, only return groups _having_ an average age less than 50.                                                                                 |
| `skip`    | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `_count`  | `true` \| `UserCountAggregateInputType`                      | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`    | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`    | `UserSumAggregateInputType`                                  | No       | Returns the sume of all values of the specified field.                                                                                                                                                    |
| `_min`    | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`    | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### Reference

`groupBy` accepts the following input type:

```ts file=index.d.ts
export type UserGroupByArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput>
  by: Array<UserScalarFieldEnum>
  having?: UserScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### Examples

##### Group by `country`/`city` where the average `profileViews` is greater than `200`, and return the `_sum` of `profileViews` for each group

The query also returns a count of `_all` records in each group, and all records with non-`null` `city` field values in each group.

<CodeWithResult expanded="{true}">
<cmd>

```ts
const groupUsers = await prisma.user.groupBy({
  by: ['country', 'city'],
  _count: {
    _all: true,
    city: true,
  },
  _sum: {
    profileViews: true,
  },
  orderBy: {
    country: 'desc',
  },
  having: {
    profileViews: {
      _avg: {
        gt: 200,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    country: 'Denmark',
    city: 'Copenhagen',
    _sum: { profileViews: 490 },
    _count: {
      _all: 70,
      city: 8,
    },
  },
  {
    country: 'Sweden',
    city: 'Stockholm',
    _sum: { profileViews: 500 },
    _count: {
      _all: 50,
      city: 3,
    },
  },
]
```

</cmdResult>
</CodeWithResult>

## Model query options

### <inlinecode>select</inlinecode>

`select` defines which fields are included in the object that Prisma Client returns. See: [Select fields and include relations](/concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- You cannot combine `select` and `include` on the same level.
- In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [select a `_count` of relations](#select-a-_count-of-relations).

#### Reference

```ts file=index.d.ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### Examples

##### Select the `name` and `profileViews` fields of a single `User` record

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  name: "Alice",
  profileViews: 0
}
```

</cmdResult>
</CodeWithResult>

##### Select the `name` and `profileViews` fields of a multiple `User` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    email: 'alice@prisma.io',
    role: 'ADMIN',
  },
  {
    email: 'bob@prisma.io',
    role: 'USER',
  },
]
```

</cmdResult>
</CodeWithResult>

##### Select a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  select: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  _count: {
    posts: 3
  }
}
```

</cmdResult>
</CodeWithResult>

##### Select the 'id' and 'title' fields of related `Post` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```ts no-copy
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      { id: 1, title: 'Hello World' },
      { id: 2, title: 'Bye bye' },
    ],
  },
  {
    id: 2,
    name: 'Bob',
    posts: [],
  },
]
```

</cmdResult>
</CodeWithResult>

##### `include` inside `select`

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      include: {
        author: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      {
        id: 1,
        title: 'Hello World',
        published: true,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'ADMIN',
          coinflips: [true, false],
          profileViews: 0,
        },
      },
      {
        id: 2,
        title: 'Bye bye',
        published: false,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'USER',
          coinflips: [],
          profileViews: 0,
        },
      },
    ],
  },
]
```

</cmdResult>
</CodeWithResult>

#### Generated types for `select`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `select`:

- `SelectAndInclude`
- `UserSelect`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserSelect
const selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({
  name: true,
  email: true,
  posts: false,
})
```

### <inlinecode>include</inlinecode>

`include` defines which relations are included in the result that the Prisma Client returns. See: [Select fields and include relations](/concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` a `_count` of relations](#include-a-_count-of-relations)

#### Reference

```ts
export type UserInclude = {
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### Examples

##### Include the `posts` and `profile` relation when loading `User` records

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true, // Returns all fields for all posts
    profile: true, // Returns all Profile fields
  },
})
```

##### Include the `posts` relation on the returned objects when creating a new `User` record with two `Post` records

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'This is my first post' },
        { title: 'Here comes a second post' },
      ],
    },
  },
  include: { posts: true }, // Returns all fields for all posts
})
```

#### Generated types for `include`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `include`:

- `SelectAndInclude`
- `UserInclude`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserInclude
const includePosts = Prisma.validator<Prisma.UserInclude>()({
  posts: true,
})
```

##### Include a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{ id: 1, name: "Bob", email: "bob@prisma.io", _count: { posts: 3 } },
{ id: 2,  name: "Enya", email: "enya@prisma.io", _count: { posts: 2 } }
```

</cmdResult>
</CodeWithResult>

### <inlinecode>where</inlinecode>

`where` defines one or more [filters](#filter-conditions-and-operators), and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).

#### Reference

For queries like `findMany` and `updateMany` that return multiple records, `where` accepts the following input type:

```ts file=index.d.ts
export type UserWhereInput = {
  AND?: Enumerable<UserWhereInput>
  OR?: Enumerable<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  id?: IntFilter | number
  name?: StringNullableFilter | string | null
  email?: StringFilter | string
  profileViews?: IntFilter | number
  role?: EnumRoleFilter | Role
  coinflips?: BoolNullableListFilter
  posts?: PostListRelationFilter
}
```

> `findFirst` is a `findMany` query with a `take: 1`, and also accepts `UserWhereInput`.

For queries like `findUnique`, which returns a single record by ID or unique identifier, `where` accepts the following input type:

```ts file=index.d.ts
export type UserWhereUniqueInput = {
  id?: number
  email?: string
}
```

#### Examples

```ts
const results = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

#### Generated types for `where`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `where`:

- `UserWhereInput`

  ```ts
  // UserWhereInput
  const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
    name: 'Rich',
  })

  // It can be combined with conditional operators too
  const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
    name: 'Rich',
    AND: [
      {
        email: {
          contains: 'rich@boop.com',
        },
      },
    ],
  })
  ```

- `UserWhereUniqueInput` This type works by exposing any unique fields on the model. A field assigned `@id` is considered unique,
  as is one assigned `@unique`.

  From version 4.5.0, this type exposes all fields on the model. This means that when you filter for a single record based on a unique field, you can check additional non-unique and unique fields at the same time. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput).

```ts
// UserWhereUniqueInput
const whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({
  email: 'rich@boop.com',
})
```

- `PostScalarWhereInput`

  ```ts
  const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({
    title: 'boop',
  })
  ```

- `PostUpdateWithWhereUniqueWithoutAuthorInput` - This type accepts a unique `where` field (an `@id` or another assigned `@unique`)
  and updates any field on the `Post` model except the `Author`. The `Author` is the scalar field on the `Post` model.

  ```ts
  const updatePostByIdWithoutAuthor =
    Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1,
      },
      data: {
        content: 'This is some updated content',
        published: true,
        title: 'This is a new title',
      },
    })
  ```

- `PostUpsertWithWhereUniqueWithoutAuthorInput` - This type will update the `Post` records title field where the id matches, if it doesn't exist it will create it instead.

  ```ts
  const updatePostTitleOrCreateIfNotExist =
    Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1,
      },
      update: {
        title: 'This is a new title',
      },
      create: {
        id: 1,
        title: 'If the title doesnt exist, then create one with this text',
      },
    })
  ```

- `PostUpdateManyWithWhereWithoutAuthorInput` - This type will update all `Post` records where published is set to false.

  ```ts
  const publishAllPosts =
    Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({
      where: {
        published: {
          equals: false,
        },
      },
      data: {
        published: true,
      },
    })
  ```

### <inlinecode>orderBy</inlinecode>

Sorts a list of records. See also: [Sorting](/concepts/components/prisma-client/filtering-and-sorting) <span class="concept"></span>

#### Remarks

- In [2.16.0](https://github.com/prisma/prisma/releases/2.16.0) and later, you can [order by relation fields](#sort-post-by-the-related-user-records-name) - for example, order posts by the author's name.

- In [3.5.0](https://github.com/prisma/prisma/releases/3.5.0) and later, in PostgreSQL you can [order by relevance](#sort-post-by-relevance-of-the-title). For details, see [Sort by relevance](/concepts/components/prisma-client/filtering-and-sorting#sort-by-relevance-postgresql).

- In [4.1.0](https://github.com/prisma/prisma/releases/4.1.0) and later, you can [sort `null` records first or last](#sort-post-by-the-related-user-records-name-with-null-records-first). For details, see [Sort with nulls first or last](/concepts/components/prisma-client/filtering-and-sorting#sort-with-null-records-first-or-last).

#### Inputs for <inlinecode>sort</inlinecode> argument

| Name   | Description                  |
| ------ | ---------------------------- |
| `asc`  | Sort ascending (A &rarr; Z)  |
| `desc` | Sort descending (Z &rarr; A) |

#### Inputs for <inlinecode>nulls</inlinecode> argument

Note:

- This argument is optional.
- It is for use on optional [scalar](/concepts/components/prisma-schema/data-model#scalar-fields) fields only. If you try to sort by nulls on a required or [relation](/concepts/components/prisma-schema/data-model#relation-fields) field, Prisma Client throws a [P2009 error](/reference/api-reference/error-reference#p2009).
- It is available in version 4.1.0 and later, as a preview feature. See [sort with nulls first or last](/concepts/components/prisma-client/filtering-and-sorting#sort-with-null-records-first-or-last) for details of how to enable the feature.

| Name    | Description                    |
| ------- | ------------------------------ |
| `first` | Sort with `null` values first. |
| `last`  | Sort with `null` values last.  |

#### Reference

`orderBy` accepts the following input type:

```ts file=index.d.ts
export type UserOrderByInput = {
  id?: SortOrder
  name?: SortOrder | SortOrderInput
  email?: SortOrder
  profileViews?: SortOrder
  role?: SortOrder
  coinflips?: SortOrder
  posts?: PostOrderByRelationAggregateInput
  city?: SortOrder
  country?: SortOrder
  profile?: ExtendedProfileOrderByWithRelationAndSearchRelevanceInput
  pets?: SortOrder
  _relevance?: UserOrderByRelevanceInput
}

export type SortOrderInput = {
  sort: SortOrder
  nulls?: NullsOrder
}
```

Related types:

```ts
export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}

export declare const NullsOrder: {
  first: 'first'
  last: 'last'
}

export type PostOrderByRelationAggregateInput = {
  _count?: SortOrder
}

export type ExtendedProfileOrderByWithRelationAndSearchRelevanceInput = {
  id?: SortOrder
  userId?: SortOrder
  bio?: SortOrder
  User?: UserOrderByWithRelationAndSearchRelevanceInput
  _relevance?: ExtendedProfileOrderByRelevanceInput
}

export type UserOrderByRelevanceInput = {
  fields: Enumerable<UserOrderByRelevanceFieldEnum>
  sort: SortOrder
  search: string
}
```

#### Examples

##### Sort `User` by `email` field

The following example returns all `User` records sorted by `email` ascending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
})
```

The following example returns all `User` records sorted by `email` descending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'desc',
  },
})
```

#### Sort `Post` by the related `User` record's `name`

The following query orders posts by user name:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: 'asc',
    },
  },
})
```

#### Sort `Post` by the related `User` record's `name`, with `null` records first

The following query orders posts by user name, with `null` records first:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: { sort: 'asc', nulls: 'first' },
    },
  },
})
```

#### Sort `Post` by relevance of the title

<Admonition type="warning">

This feature is available from version 3.5.0 onwards in PostgreSQL only. You'll need to use the `fullTextSearch` preview flag to enable this feature.

</Admonition>

The following query orders posts by relevance of the search term `'database'` to the title:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    _relevance: {
      fields: ['title'],
      search: 'database',
      sort: 'asc'
    },
})
```

#### Sort `User` by the `posts` count

The following query orders users by post count:

```ts
const getActiveusers = await prisma.user.findMany({
  orderBy: {
    posts: {
      count: 'desc',
    },
  },
})
```

##### Sort `User` by multiple fields - `email` _and_ `role`

The following example sorts users by two fields - first `email`, then `role`:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      email: 'desc',
    },
    {
      role: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  }
]
```

</cmdResult>

</CodeWithResult>

The order of sorting parameters matters - the following query sorts by `role`, then `email`. Not the difference in the results:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      role: 'desc',
    },
    {
      email: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` by `email`, select `name` and `email`

The following example returns all the `name` and `email` fields of all `User` records, sorted by `email`:

<CodeWithResult>

<cmd>

```ts
const users3 = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  select: {
    name: true,
    email: true,
  },
})
```

</cmd>

<cmdResult>

```js no-copy
;[
  {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
  {
    name: 'Ariadne',
    email: 'ariadne@prisma.io',
  },
  {
    name: 'Bob',
    email: 'bob@prisma.io',
  },
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` records by `email` and sort nested `Post` records by `title`

The following example:

- Returns all `User` records sorted by `email`
- For each `User` record, returns the `title` field of all nested `Post` records sorted by `title`

<CodeWithResult>

<cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort one user's nested list of `Post` records

The following example retrieves a single `User` record by ID, as well as a list of nested `Post` records sorted by `title`:

<CodeWithResult>

<cmd>

```ts
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
        published: true,
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json no-copy
{
  "email": "sarah@prisma.io",
  "id": 1,
  "name": "Sarah",
  "extendedProfile": null,
  "role": "USER",
  "posts": [
    {
      "title": "Prisma Day 2020",
      "published": false
    },
    {
      "title": "My first post",
      "published": false
    },
    {
      "title": "All about databases",
      "published": true
    }
  ]
}
```

</cmdResult>

</CodeWithResult>

##### Sort by `enum`

The following sorts all `User` records by `role` (an `enum`):

<CodeWithResult>

<cmd>

```ts
const sort = await prisma.user.findMany({
  orderBy: {
    role: 'desc',
  },
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "emma@prisma.io",

    "role": "USER"
  },
  {
    "email": "suma@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "kwame@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "pearl@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

#### Generated types for `orderBy`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `orderBy`:

- `UserOrderByInput`
  ```ts
  const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({
    email: 'desc',
  })
  ```

### <inlinecode>distinct</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#select-distinct) <span class="concept"></span>

#### Reference

```ts file=index.d.ts
distinct?: Enumerable<UserDistinctFieldEnum>
```

```ts
export declare const UserDistinctFieldEnum: {
  id: 'id'
  name: 'name'
  email: 'email'
  profileViews: 'profileViews'
  role: 'role'
  coinflips: 'coinflips'
}
```

#### Examples

##### Select distinct on a single field

The following example returns all distinct `city` fields, and selects only the `city` and `country` fields:

<CodeWithResult  expanded={true}>

<cmd>

```ts
const distinctCities = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city'],
})
```

</cmd>

<cmdResult>

```js no-lines no-copy
;[
  { city: 'Paris', country: 'France' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

##### Select distinct on multiple fields

The following example returns all distinct `city` _and_ `country` field combinations, and selects only the `city` and `country` fields:

<CodeWithResult expanded={true}>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-lines no-copy
;[
  { city: 'Paris', country: 'France' },
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

Note that there is now a "Paris, Denmark" in addition to "Paris, France":

##### Select distinct in combination with a filter

The following example returns all distinct `city` _and_ `country` field combinations where the user's email contains `"prisma.io"`, and selects only the `city` and `country` fields:

<CodeWithResult>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-copy
;[
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

## Nested queries

### <inlinecode>create</inlinecode>

A nested `create` query adds a new related record or set of records to a parent record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

#### Remarks

- `create` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](/concepts/components/prisma-client/relation-queries#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

#### Examples

##### Create a new `User` record with a new `Profile` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### Create a new `Profile` record with a new `User` record

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
|     create: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `User` record with a new `Post` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
  },
})
```

##### Create a new `User` record with two new `Post` records

Because it's a one-to-many relation, you can also create several `Post` records at once by passing an array to `create`:

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        {
          title: 'This is my first post',
        },
        {
          title: 'Here comes a second post',
        },
      ],
    },
  },
})
```

You can also use a nested [`createMany`](#createmany-1) to achieve the same result.

##### Update an existing `User` record by creating a new `Profile` record

```ts highlight=5;normal;
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by creating a new `Post` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
|      create: { title: 'Hello World' },
    },
  },
})
```

### <inlinecode>createMany</inlinecode>

A nested `createMany` query adds a new set of records to a parent record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

#### Remarks

- `createMany` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.
- Available in the context of a has-many relation - for example, you can `prisma.user.create(...)` a user and use a nested `createMany` to create multiple posts (posts have one user).
- **Not** available in the context of a many-to-many relation - for example, you **cannot** `prisma.post.create(...)` a post and use a nested `createMany` to create categories (many posts have many categories).
- Does not support nesting additional relations - you cannot nest an additional `create` or `createMany`.
- Allows setting foreign keys directly - for example, setting the `categoryId` on a post.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](/concepts/components/prisma-client/relation-queries#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

#### Examples

##### Update a `User` and multiple new related `Post` records

```ts
const user = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    name: 'Elliott',
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```

### <inlinecode>set</inlinecode>

`set` overwrites the value of a relation - for example, replacing a list of `Post` records with a different list. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Examples

##### Update an existing `User` record by disconnecting any previous `Post` records and connecting two other existing ones

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      set: [{ id: 32 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connect</inlinecode>

<AlgoliaTerm name="apiReference" value="connect" />

A nested `connect` query connects a record to an existing related record by specifying an ID or unique identifier. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

- `connect` is available as a nested query when you create a new parent record or update an existing parent record.
- If the related record does not exist, Prisma Client throws an exception:

  ```
  The required connected records were not found. Expected 1 records to be connected, found 0.
  ```

#### Examples

##### Create a new `Profile` record and connect it to an existing `User` record via unique field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Create a new `Profile` record and connect it to an existing `User` record via an ID field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { id: 42 }, // sets userId of Profile record
    },
  },
})
```

In [2.11.0](https://github.com/prisma/prisma/releases/2.11.0) and later, you can set the foreign key directly:

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    userId: 42,
  },
})
```

##### Create a new `Post` record and connect it to an existing `User` record

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connect: { id: 24 },
    },
  },
})
```

##### Update an existing `User` record by connecting it to two existing `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connect: [{ id: 24 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connectOrCreate</inlinecode>

<AlgoliaTerm name="apiReference" value="connectOrCreate" />

`connectOrCreate` _either_ connects a record to an existing related record by ID or unique identifier _or_ creates a new related record if the record does not exist. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

<!-- prettier-ignore-start -->

- Multiple `connectOrCreate` queries that run _as concurrent transactions_ can result in a **race condition**. Consider the following example, where two queries attempt to `connectOrCreate` a blog post tag named `computing` at the same time (tag names must be unique):

  <TabbedContent tabs={[<FileWithIcon text="Query A" icon="code"/>, <FileWithIcon text="Query B" icon="code"/>]}>
  <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to create a compiler',
      content: '...',
      author: {
        connect: {
          id: 9,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
    <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to handle schema drift in production',
      content: '...',
      author: {
        connect: {
          id: 15,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
  </TabbedContent>

  If query A and query B overlap in the following way, query A results in an exception:

  | Query A (Fail ❌)                                                | Query B (Success ✅)                                             |
  | :--------------------------------------------------------------- | :--------------------------------------------------------------- |
  | Query hits server, starts transaction A                          | Query hits server, starts transaction B                          |
  |                                                                  | Find record where `tagName` equals `computing`, record not found |
  | Find record where `tagName` equals `computing`, record not found |                                                                  |
  |                                                                  | Create record where `tagName` equals `computing` and connect     |
  | Create record where `tagName` equals `computing`                 |                                                                  |
  | Unique violation, record already created by transaction B        |                                                                  |

  To work around this scenario, we recommend catching the unique violation exception (`PrismaClientKnownRequestError`, error `P2002`) and retrying failed queries.

<!-- prettier-ignore-end -->

#### Examples

##### Create a new `Profile` record, then connect it to an existing `User` record _or_ create a new `User`

The following example:

1. Creates a `Profile`
2. Attempts to connect the profile to a `User` where the email address is `alice@prisma.io`
3. Creates a new user if a user if a matching user does not exist

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'The coolest Alice on the planet',
    user: {
      connectOrCreate: {
        where:  { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io'}
    },
  },
})
```

##### Create a new `Post` record and connect it to an existing `User` record, _or_ create a new `User`

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connectOrCreate: {
        where: { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io' },
      },
    },
  },
})
```

##### Update an existing `User` record by connecting it to an existing `Profile` record, _or_ creating a new `Profile` record

The following example:

1. Attempts to connect the user to a `Profile` with an `id` of `20`
2. Creates a new profile if a matching profile does not exist

```ts
const updateUser = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connectOrCreate: {
        where: { id: 20 },
        create: {
          bio: 'The coolest Alice in town',
        },
      },
    },
  },
})
```

##### Update an existing `User` record by connect it to two existing `Post` records, or creating two new `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connectOrCreate: [
        {
          where: { id: 32 },
          create: { title: 'This is my first post' },
        },
        {
          where: { id: 19 },
          create: { title: 'This is my second post' },
        },
      ],
    },
  },
})
```

### <inlinecode>disconnect</inlinecode>

<AlgoliaTerm name="apiReference" value="disconnect" />

A nested `disconnect` query breaks the connection between a parent record and a related record, but does not delete either record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### Remarks

- `disconnect` is only available if the relation is optional.
- If the relationship you are attempting to disconnect does not exist:

  - ([In 2.21.0 and later](https://github.com/prisma/prisma/releases/tag/2.21.0)), the operation does nothing
  - (Before [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0)) Prisma Client throws an exception if the provided ID or unique identifier is not connected:

    ```
    The records for relation `PostToUser` between the `User` and `Post` models are not connected.
    ```

#### Examples

##### Update an existing `User` record by disconnecting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'bob@prisma.io' },
  data: {
    profile: {
      disconnect: true,
    },
  },
})
```

##### Update an existing `User` record by disconnecting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      disconnect: [{ id: 44 }, { id: 46 }],
    },
  },
})
```

### <inlinecode>update</inlinecode>

<AlgoliaTerm name="apiReference" value="update" />

A nested `update` query updates one or more related records where the parent record's ID is `n`. See: [Working with relations](/concepts/components/prisma-client/relation-queries#update-a-specific-related-record) <span class="concept"></span>

#### Remarks

- Nested `update` queries are only available in the context of a top-level `update` query (for example, `prisma.user.update(...)`).
- If the parent record does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

- If the related record that you want to update does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

#### Examples

##### Update an existing `User` record by updating the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      update: { bio: 'Hello World' },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      update: [
        {
          data: { published: true },
          where: { id: 32 },
        },
        {
          data: { published: true },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>upsert</inlinecode>

<AlgoliaTerm name="apiReference" value="upsert" />

A nested `upsert` query updates a related record if it exists, or creates a new related record.

#### Examples

##### Update an existing `User` record by updating the `Profile` record it's connected to or creating a new one (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      upsert: {
        create: { bio: 'Hello World' },
        update: { bio: 'Hello World' },
      },
    },
  },
})
```

##### Update an existing `User` record by updating two `Post` record it's connected to or creating new ones (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      upsert: [
        {
          create: { title: 'This is my first post' },
          update: { title: 'This is my first post' },
          where: { id: 32 },
        },
        {
          create: { title: 'This is mt second post' },
          update: { title: 'This is mt second post' },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>delete</inlinecode>

<AlgoliaTerm name="apiReference" value="delete" />

A nested `delete` query deletes a related record. The parent record is not deleted.

#### Remarks

- `delete` is only available if the relation is optional.

#### Examples

##### Update an existing `User` record by deleting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      delete: true,
    },
  },
})
```

##### Update an existing `User` record by deleting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      delete: [{ id: 34 }, { id: 36 }],
    },
  },
})
```

### <inlinecode>updateMany</inlinecode>

<AlgoliaTerm name="apiReference" value="updateMany" />

A nested `updateMany` updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.

#### Examples

##### Update all unpublished posts belonging to a specific user

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false,
        },
        data: {
          likes: 0,
        },
      },
    },
  },
})
```

### <inlinecode>deleteMany</inlinecode>

<AlgoliaTerm name="apiReference" value="deleteMany" />

A nested `deleteMany` deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.

#### Examples

##### Delete all posts belonging to a specific user as part of an update

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    name: 'Updated name',
    posts: {
      deleteMany: {},
    },
  },
})
```

## Filter conditions and operators

<Admonition type="info">

**Note:** The following examples show how to compare columns in separate tables.

- From version 4.3.0, you can also use these operators to [compare columns in the same table, with the `<model>.fields` property](#compare-columns-in-the-same-table).
- In versions before 4.3.0, you can [compare columns in the same table with raw queries](/guides/database/troubleshooting-orm/help-articles/comparing-columns-through-raw-queries).

</Admonition>

### <inlinecode>equals</inlinecode>

Value equals `n`.

#### Examples

##### Return all users where `name` equals `"Eleanor"`

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      equals: 'Eleanor',
    },
  },
})
```

You can also exclude the `equals`:

```ts
const result = await prisma.user.findMany({
  where: {
    name: 'Eleanor',
  },
})
```

### <inlinecode>not</inlinecode>

Value does not equal `n`.

#### Examples

##### Return all users where `name` does **not** equal `"Eleanor"`

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      not: 'Eleanor',
    },
  },
})
```

### <inlinecode>in</inlinecode>

Value `n` exists in list.

#### Remarks

- `null` values are not returned. For example, if you combine `in` and `NOT` to return user whose name is _not_ in the list, users with `null` value names are not returned.

#### Examples

##### Get `User` records where the `id` can be found in the following list: `[22, 91, 14, 2, 5]`

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { in: [22, 91, 14, 2, 5] },
  },
})
```

##### Get `User` records where the `name` can be found in the following list: `['Saqui', 'Clementine', 'Bob']`

```ts
const getUser = await prisma.user.findMany({
  where: {
    name: { in: ['Saqui', 'Clementine', 'Bob'] },
  },
})
```

##### Get `User` records where `name` is **not** present in the list

The following example combines `in` and [`NOT`](#not). You can also use [`notIn`](#notin).

```ts
const getUser = await prisma.user.findMany({
  where: {
    NOT: {
      name: { in: ['Saqui', 'Clementine', 'Bob'] },
    },
  },
})
```

##### Get a `User` record where at least one `Post` has at least one specified `Category`

```ts
const getUser = await prisma.user.findMany({
  where: {
    // Find users where..
    posts: {
      some: {
        // ..at least one (some) posts..
        categories: {
          some: {
            // .. have at least one category ..
            name: {
              in: ['Food', 'Introductions'], // .. with a name that matches one of the following.
            },
          },
        },
      },
    },
  },
})
```

### <inlinecode>notIn</inlinecode>

Value `n` does not exist in list.

#### Remarks

- `null` values are not returned.

#### Examples

##### Get `User` records where the `id` can **not** be found in the following list: `[22, 91, 14, 2, 5]`

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { notIn: [22, 91, 14, 2, 5] },
  },
})
```

### <inlinecode>lt</inlinecode>

Value `n` is less than `x`.

#### Examples

##### Get all `Post` records where `likes` is less than `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lt: 9,
    },
  },
})
```

### <inlinecode>lte</inlinecode>

Value `n` is less than _or_ equal to `x`.

#### Examples

##### Get all `Post` records where `likes` is less or equal to `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lte: 9,
    },
  },
})
```

### <inlinecode>gt</inlinecode>

Value `n` is greater than `x`.

#### Examples

##### Get all `Post` records where `likes` is greater than `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gt: 9,
    },
  },
})
```

### <inlinecode>gte</inlinecode>

Value `n` is greater than _or_ equal to `x`.

#### Examples

##### Get all `Post` records where `likes` is greater than or equal to `9`

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gte: 9,
    },
  },
})
```

#### Examples

##### Get all `Post` records where `date_created` is greater than March 19th, 2020

```js
const result = await prisma.post.findMany({
  where: {
    date_created: {
      gte: new Date(
        '2020-03-19T14:21:00+0200'
      ) /* Includes time offset for UTC */,
    },
  },
})
```

### <inlinecode>contains</inlinecode>

Value `n` contains `x`.

#### Examples

##### Count all `Post` records where `content` contains `databases`

```js
const result = await prisma.post.count({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

##### Count all `Post` records where `content` **does not** contain `databases`

```js
const result = await prisma.post.count({
  where: {
    NOT: {
      content: {
        contains: 'databases',
      },
    },
  },
})
```

### <inlinecode>search</inlinecode>

Use [Full-Text Search](/concepts/components/prisma-client/full-text-search) to search within a `String` field.

Full-Text Search is currently in **Preview** and only available for **PostgreSQL** and **MySQL**. To use `search`, you'll need to enable the `fullTextSearch`
preview feature.

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}
```

#### Examples

##### Find all posts with a title that contains `cat` or `dog`.

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      search: 'cat | dog',
    },
  },
})
```

##### Find all posts with a title that contains `cat` and `dog`.

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      search: 'cat & dog',
    },
  },
})
```

##### Find all posts with a title that doesn't contain `cat`.

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      search: '!cat',
    },
  },
})
```

### <inlinecode>mode</inlinecode>

#### Remarks

- Supported by the PostgreSQL and MongoDB connectors only

#### Examples

##### Get all `Post` records where `title` contains `prisma`, in a case insensitive way

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      contains: 'prisma',
      mode: 'insensitive',
    },
  },
})
```

### <inlinecode>startsWith</inlinecode>

#### Examples

##### Get all `Post` records where `title` starts with `Pr` (such as `Prisma`)

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      startsWith: 'Pr',
    },
  },
})
```

### <inlinecode>endsWith</inlinecode>

#### Get all `User` records where `email` ends with `prisma.io`

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

### <inlinecode>AND</inlinecode>

All conditions must return `true`. Alternatively, pass a list of objects into the `where` clause - the [`AND` operator is not required](#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and).

#### Examples

##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false`

```js
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
})
```

##### Get all `Post` records where the `content` field contains `Prisma` and `published` is `false` (no `AND`)

The following format returns the same results as the previous example **without** the `AND` operator:

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'Prisma',
    },
    published: {
      equals: false,
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>OR</inlinecode>

One or more conditions must return `true`.

#### Examples

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
})
```

##### Get all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

The following example combines `OR` and `NOT`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, and `published` is `false`

The following example combines `OR` and `AND`:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>NOT</inlinecode>

All conditions must return `false`.

#### Examples

##### Get all `Post` records where the `title` filed contains `Prisma` or `databases`, but not `SQL`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### Get all `Post` records where the `title` field contains `Prisma` or `databases`, but not `SQL`, and the related `User` record' email address does not contain `sarah`

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
    user: {
      NOT: {
        email: {
          contains: 'sarah',
        },
      },
    },
  },
  include: {
    user: true,
  },
})
```

## Relation filters

### <inlinecode>some</inlinecode>

Returns all records where **one or more** ("some") _related_ records match filtering criteria.

#### Remarks

- You can use `some` without parameters to return all records with at least one relation

#### Reference

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
|  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### Examples

##### Get all `User` records where _all_ posts are published and at least one related `Post` mentions `Prisma`

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>every</inlinecode>

Returns all records where **all** ("every") _related_ records match filtering criteria.

#### Reference

```ts file=index.d.ts
export type PostFilter = {
|  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### Examples

##### Get all `User` records where _all_ posts are published and a least one related `Post` mentions `Prisma`

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>none</inlinecode>

Returns all records where **zero** _related_ records match filtering criteria.

#### Remarks

- You can use `none` without parameters to [return all records with no relations](#get-all-user-records-with-zero-posts)

#### Reference

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
|  none?: PostWhereInput | null
}
```

#### Examples

##### Get all `User` records with zero posts

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {} // User has no posts
    }
  }
}
```

##### Get all `User` records with zero published posts

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {
          published: true
        }
    }
  }
}
```

### <inlinecode>is</inlinecode>

Returns all records where related record matches filtering criteria (for example, user's name `is` Bob).

#### Reference

```ts file=index.d.ts highlight=2;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### Examples

##### Get all `Post` records where user's name is `"Bob"`

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        is: {
          name: "Bob"
        },
    }
  }
}
```

### <inlinecode>isNot</inlinecode>

Returns all records where related record matches filtering criteria (for example, user's name `isNot` Bob).

#### Reference

```ts file=index.d.ts highlight=3;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### Examples

##### Get all `Post` records where user's name is NOT `"Bob"`

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        isNot: {
          name: "Bob"
        },
    }
  }
}
```

## Scalar list methods

### Reference

```ts
export type PostUpdatetagsInput = {
  set?: Enumerable<string>
  push?: string
}
```

### <inlinecode>set</inlinecode>

Use `set` to overwrite the value of a scalar list field.

#### Remarks

- `set` is optional - you can set the value directly:

  ```ts
  tags: ['computers', 'books']
  ```

#### Examples

##### Set the value of `tags` to a list of string values

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: {
        set: ["computing", "books"]
      }
    }
  })
}
```

##### Set `tags` to a list of values _without_ using the `set` keyword

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: ["computing", "books"]
    }
  })
}
```

#### Set the value of `tags` to a single string value

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      set: 'computing',
    },
  },
})
```

### <inlinecode>push</inlinecode>

`push` is available in version [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) and later. Use `push` to add _one_ value to a scalar list field.

#### Remarks

- Available for PostgreSQL and MongoDB only.
- You cannot push a list of values - only a single value.

#### Examples

##### Add a `computing` item to the `tags` list

```ts
const addTag = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      push: 'computing',
    },
  },
})
```

### <inlinecode>unset</inlinecode>

<Admonition type="warning">

This method is available on MongoDB only in versions
[3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.

</Admonition>

Use `unset` to unset the value of a scalar list. Unlike `set: null`, `unset` removes the list entirely.

#### Examples

##### Unset the value of `tags`

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: {
        unset: true,
      }
    }
  })
}
```

## Scalar list filters

Scalar list filters allow you to filter by the contents of a list / array field.

<Admonition type="warning">

Available for:

- PostgreSQL in versions [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) and later
- CockroachDB in versions [3.9.0](https://github.com/prisma/prisma/releases/tag/3.9.0) and later
- MongoDB in versions [3.11.0](https://github.com/prisma/prisma/releases/tag/3.11.0) and later

</Admonition>

### Remarks

- Scalar list / array filters [ignore `NULL` values](/concepts/components/prisma-client/working-with-fields/working-with-scalar-lists-arrays#null-values-in-arrays) <span class="concept"></span>. Using `isEmpty` or `NOT` does not return records with `NULL` value lists / arrays, and `{ equals: null }` results in an error.

### Reference

```ts file=index.d.ts
export type StringNullableListFilter = {
  equals?: Enumerable<string> | null
  has?: string | null
  hasEvery?: Enumerable<string>
  hasSome?: Enumerable<string>
  isEmpty?: boolean
}
```

```ts file=index.d.ts
export type BoolNullableListFilter = {
  equals?: Enumerable<boolean> | null
  has?: boolean | null
  hasEvery?: Enumerable<boolean>
  hasSome?: Enumerable<boolean>
  isEmpty?: boolean
}
```

### <inlinecode>has</inlinecode>

The given value exists in the list.

#### Examples

The following query returns all `Post` records where the `tags` list includes `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    tags: {
      has: 'databases',
    },
  },
})
```

The following query returns all `Post` records where the `tags` list **does not** include `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    NOT: {
      tags: {
        has: 'databases',
      },
    },
  },
})
```

### <inlinecode>hasEvery</inlinecode>

Every value exists in the list.

#### Examples

The following query returns all `Post` records where the `tags` list includes _at least_ `"database"` _and_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasEvery: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>hasSome</inlinecode>

At least one value exists in the list.

#### Examples

The following query returns all `Post` records where the `tags` list `"database"` _or_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasSome: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>isEmpty</inlinecode>

The list is empty.

#### Examples

The following query returns all `Post` records that have no tags:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      isEmpty: true,
    },
  },
})
```

### <inlinecode>isSet</inlinecode>

<Admonition type="warning">

This filter is available on MongoDB only in versions
[3.11.1](https://github.com/prisma/prisma/releases/tag/3.11.1) and later.

</Admonition>

Filter lists to include only results that have been set (either set to a value, or explicitly set to `null`). Setting this filter to `true` will exclude undefined results that are not set at all.

#### Examples

The following query returns all `Post` records where the `tags` have been set to either `null` or a value:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      isSet: true,
    },
  },
})
```

### <inlinecode>equals</inlinecode>

The list matches the given value exactly.

#### Examples

The following query returns all `Post` records where the `tags` list include `"database"` and `"typescript"` only:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      equals: ['databases', 'typescript'],
    },
  },
})
```

## Composite type methods

<Admonition type="warning">

Available for MongoDB only in Prisma `3.10.0` and later.

</Admonition>

Composite type methods allow you to create, update and delete [composite types](/concepts/components/prisma-client/composite-types).

### <inlinecode>set</inlinecode>

Use `set` to overwrite the value of a composite type.

#### Remarks

- The `set` keyword is optional - you can set the value directly:

```ts
photos: [
  { height: 100, width: 200, url: '1.jpg' },
  { height: 100, width: 200, url: '2.jpg' },
]
```

#### Examples

##### Set the <inlinecode>shippingAddress</inlinecode> composite type within a new <inlinecode>order</inlinecode>

```ts
const order = await prisma.order.create({
  data: {
    // Normal relation
    product: { connect: { id: 'some-object-id' } },
    color: 'Red',
    size: 'Large',
    // Composite type
    shippingAddress: {
      set: {
        street: '1084 Candycane Lane',
        city: 'Silverlake',
        zip: '84323',
      },
    },
  },
})
```

##### Set an optional composite type to <inlinecode>null</inlinecode>

```ts
const order = await prisma.order.create({
  data: {
    // Embedded optional type, set to null
    billingAddress: {
      set: null,
    },
  },
})
```

### <inlinecode>unset</inlinecode>

Use `unset` to unset the value of a composite type. Unlike `set: null`, this removes the field entirely from the MongoDB document.

#### Examples

##### Remove the <inlinecode>billingAddress</inlinecode> from an <inlinecode>order</inlinecode>

```ts
const order = await prisma.order.update({
  where: {
    id: 'some-object-id',
  },
  data: {
    billingAddress: {
      // Unset the billing address
      // Removes "billingAddress" field from order
      unset: true,
    },
  },
})
```

### <inlinecode>update</inlinecode>

Use `update` to update fields within a required composite type.

#### Remarks

The `update` method cannot be used on optional types. Instead, use [upsert](#upsert-2)

#### Examples

##### Update the zip field of a <inlinecode>shippingAddress</inlinecode> composite type

```ts
const order = await prisma.order.update({
  where: {
    id: 'some-object-id',
  },
  data: {
    shippingAddress: {
      // Update just the zip field
      update: {
        zip: '41232',
      },
    },
  },
})
```

### <inlinecode>upsert</inlinecode>

Use `upsert` to update an existing optional composite type if it exists, and otherwise set the composite type.

#### Remarks

The `upsert` method cannot be used on required types. Instead, use [update](#update-2)

#### Examples

##### Create a new <inlinecode>billingAddress</inlinecode> if it doesn't exist, and otherwise update it

```ts
const order = await prisma.order.update({
  where: {
    id: 'some-object-id',
  },
  data: {
    billingAddress: {
      // Create the address if it doesn't exist,
      // otherwise update it
      upsert: {
        set: {
          street: '1084 Candycane Lane',
          city: 'Silverlake',
          zip: '84323',
        },
        update: {
          zip: '84323',
        },
      },
    },
  },
})
```

### <inlinecode>push</inlinecode>

Use `push` to push values to the end of a list of composite types.

#### Examples

##### Add a new photo to the <inlinecode>photos</inlinecode> list

```ts
const product = prisma.product.update({
  where: {
    id: 10,
  },
  data: {
    photos: {
      // Push a photo to the end of the photos list
      push: [{ height: 100, width: 200, url: '1.jpg' }],
    },
  },
})
```

## Composite type filters

<Admonition type="warning">

Available for MongoDB only in Prisma `3.11.0` and later.

</Admonition>

Composite type filters allow you to filter the contents of [composite types](/concepts/components/prisma-client/composite-types).

### Reference

```ts file=index.d.ts
export type AddressCompositeFilter = {
  equals?: AddressObjectEqualityInput
  is?: AddressWhereInput
  isNot?: AddressWhereInput
}
```

```ts file=index.d.ts
export type PhotoCompositeListFilter = {
  equals?: Enumerable<PhotoObjectEqualityInput>
  every?: PhotoWhereInput
  some?: PhotoWhereInput
  none?: PhotoWhereInput
  isEmpty?: boolean
}
```

### <inlinecode>equals</inlinecode>

Use `equals` to filter results by matching a composite type or a list of composite types. Requires all required fields of the composite type to match.

#### Remarks

When matching optional fields, you need to distinguish between undefined (missing) fields of the document, and fields that have been explicitly set to `null`:

- If you omit an optional field, it will match undefined fields, but not fields that have been set to `null`
- If you filter for `null` values of an optional field with `equals: { ... exampleField: null ... }`, then it will match only documents where the field has been set to `null`, and not undefined fields

The ordering of fields and lists matters when using `equals`:

- For fields, `{ "a": "1", "b": "2" }` and `{ "b": "2", "a": "1" }` are not considered equal
- For lists, `[ { "a": 1 }, { "a": 2 } ]` and `[ { "a": 2 }, { "a": 1 } ]` are not considered equal

#### Examples

##### Find orders that exactly match the given <inlinecode>shippingAddress</inlinecode>

```ts
const orders = await prisma.order.findMany({
  where: {
    shippingAddress: {
      equals: {
        street: '555 Candy Cane Lane',
        city: 'Wonderland',
        zip: '52337',
      },
    },
  },
})
```

##### Find products with photos that match all of a list of <inlinecode>url</inlinecode>s

```ts
const product = prisma.product.findMany({
  where: {
    equals: {
      photos: [{ url: '1.jpg' }, { url: '2.jpg' }],
    },
  },
})
```

### <inlinecode>is</inlinecode>

Use `is` to filter results by matching specific fields within composite types.

#### Examples

##### Find orders with a <inlinecode>shippingAddress</inlinecode> that matches the given street name

```ts
const orders = await prisma.order.findMany({
  where: {
    shippingAddress: {
      is: {
        street: '555 Candy Cane Lane',
      },
    },
  },
})
```

### <inlinecode>isNot</inlinecode>

Use `isNot` to filter results for composite type fields that do not match.

#### Examples

##### Find orders with a <inlinecode>shippingAddress</inlinecode> that does not match the given zip code

```ts
const orders = await prisma.order.findMany({
  where: {
    shippingAddress: {
      isNot: {
        zip: '52337',
      },
    },
  },
})
```

### <inlinecode>isEmpty</inlinecode>

Use `isEmpty` to filter results for an empty list of composite types.

#### Examples

##### Find products with no photos

```ts
const product = prisma.product.findMany({
  where: {
    photos: {
      isEmpty: true,
    },
  },
})
```

### <inlinecode>every</inlinecode>

Use `every` to filter for lists of composite types where every item in the list matches the condition

#### Examples

##### Find the first product where every photo has a <inlinecode>height</inlinecode> of <inlinecode>200</inlinecode>

```ts
const product = prisma.product.findFirst({
  where: {
    photos: {
      every: {
        { height: 200 },
      }
    }
  },
})
```

### <inlinecode>some</inlinecode>

Use `some` to filter for lists of composite types where one or more items in the list match the condition.

#### Examples

##### Find the first product where one or more photos have a <inlinecode>url</inlinecode> of <inlinecode>2.jpg</inlinecode>

```ts
const product = prisma.product.findFirst({
  where: {
    photos: {
      some: {
        { url: "2.jpg" },
      }
    }
  },
})
```

### <inlinecode>none</inlinecode>

Use `none` to filter for lists of composite types where no items in the list match the condition.

#### Examples

##### Find the first product where no photos have a <inlinecode>url</inlinecode> of <inlinecode>2.jpg</inlinecode>

```ts
const product = prisma.product.findFirst({
  where: {
    photos: {
      none: {
        { url: "2.jpg" },
      }
    }
  },
})

```

## Atomic number operations

Atomic operations on update is available for number field types (`Float` and `Int`). This feature allows you to update a field based on its **current** value (such as _subtracting_ or _dividing_) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client   | Operation           | Value  |
| :------- | :------------------ | :----- |
| Client 1 | **Get** field value | `21`   |
| Client 2 | **Get** field value | `21`   |
| Client 2 | **Set** field value | `22`   |
| Client 1 | **Set** field value | `22` ✘ |

The value _should_ be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client   | Operation                   | Value              |
| :------- | :-------------------------- | :----------------- |
| Client 1 | **Get and set** field value | `21` &rarr; `22`   |
| Client 2 | **Get and set** field value | `22` &rarr; `23` ✔ |

</details>

### Operators

| Option      | Description                                                   |
| :---------- | :------------------------------------------------------------ |
| `increment` | Adds `n` to the current value.                                |
| `decrement` | Subtacts `n` from the current value.                          |
| `multiply`  | Multiplies the current value by `n`.                          |
| `divide`    | Divides the current value by `n`.                             |
| `set`       | Sets the current field value. Identical to `{ myField : n }`. |

### Reference

```ts file=index.d.ts
export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

### Remarks

- You can only perform **one** atomic update per field, per query.
- If a field is `null`, it will not be updated by `increment`, `decrement`, `multiply`, or `divide`.

### Examples

#### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

#### Set all `views` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```

## <inlinecode>JSON</inlinecode> filters

For use cases and advanced examples, see: [Working with `Json` fields](/concepts/components/prisma-client/working-with-fields/working-with-json-fields) <span class="concepts"></span>

<Admonition type="warning">

Supported by [PostgreSQL](/concepts/database-connectors/postgresql) <span class="concept"></span> and [MySQL](/concepts/database-connectors/mysql) <span class="concept"></span> with different syntaxes for the `path` option. PostgreSQL does not support filtering on object key values in arrays.

</Admonition>

The examples in this section assumes that the value of the `pet` field is:

```json
{
  "favorites": {
    "catBreed": "Turkish van",
    "dogBreed": "Rottweiler",
    "sanctuaries": ["RSPCA", "Alley Cat Allies"],
    "treats": [
      { "name": "Dreamies", "manufacturer": "Mars Inc" },
      { "name": "Treatos", "manufacturer": "The Dog People" }
    ]
  },
  "fostered": {
    "cats": ["Bob", "Alice", "Svetlana the Magnificent", "Queenie"]
  },
  "owned": {
    "cats": ["Elliott"]
  }
}
```

### Remarks

- The implementation of JSON filtering [differs between database connectors](/concepts/components/prisma-client/working-with-fields/working-with-json-fields)
- Filtering is case sensitive in PostgreSQL and does not yet support `mode`

### <inlinecode>path</inlinecode>

`path` represents the location of a specific key. The following query returns all users where the nested `favourites` > `dogBreed` key equals `"Rottweiler"`.

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'dogBreed'],
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.dogBreed',
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
</TabbedContent>

The following query returns all users where the nested `owned` > `cats` array contains `"Elliott"`.

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['owned', 'cats'],
      array_contains: ['Elliott'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.owned.cats',
      array_contains: 'Elliott',
    },
  },
})
```

</tab>
</TabbedContent>

<Admonition type="warning">

Filtering by the key values of objects inside an array (below) is only supported by the MySQL connector.

</Admonition>

The following query returns all users where the nested `favorites` > `treats` array contains an object where the `name` value is `"Dreamies"`:

<TabbedContent tabs={[<FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.treats[*].name',
      array_contains: 'Dreamies',
    },
  },
})
```

</tab>

<tab>

</tab>

</TabbedContent>

### <inlinecode>string_contains</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value contains `"Van"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_contains: 'Van',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_contains: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_starts_with</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value starts with `"Turkish"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_ends_with</inlinecode>

The following query returns all users where the nested `favorites` > `catBreed` key value ends with `"Van"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>array_contains</inlinecode>

The following query returns all users where the `sanctuaries` array contains the value `"RSPCA"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_contains` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

The following query returns all users where the `sanctuaries` array contains _all_ the values in the given array:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_starts_with</inlinecode>

The following query returns all users where the `sanctuaries` array starts with the value `"RSPCA"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_starts_with: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_starts_with` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_starts_with: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_ends_with</inlinecode>

The following query returns all users where the `sanctuaries` array ends with the value `"Alley Cat Allies"`:

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_ends_with: ['Alley Cat Allies'],
    },
  },
})
```

<Admonition type="info">

**Note**: In PostgresSQL, the value of `array_ends_with` must be an array and not a string, even if the array only contains a single value.

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_ends_with: 'Alley Cat Allies',
    },
  },
})
```

</tab>
</TabbedContent>

## Client methods

Client-level methods are prefixed by `$`.

<!-- prettier-ignore -->
### <inlinecode>$disconnect()</inlinecode>

The `$disconnect()` method closes the database connections that were established when `$connect` was called and stops the process that was running Prisma's query engine. See [Connection management](/concepts/components/prisma-client/working-with-prismaclient/connection-management) for an overview of `$connect()` and `$disconnect()`.

#### Remarks

- `$disconnect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.

#### Reference

```ts
$disconnect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$connect()</inlinecode>

The `$connect()` method establishes a physical connection to the database via Prisma's query engine. See [Connection management](/concepts/components/prisma-client/working-with-prismaclient/connection-management) for an overview of `$connect()` and `$disconnect()`.

#### Remarks

- `$connect()` returns a `Promise`, so you should call it inside an `async` function with the `await` keyword.

#### Reference

```ts
$connect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$on()</inlinecode>

The `$on()` method allows you to subscribe to events. With those you can subscribe to [logging events](#log) or the [exit hook](/concepts/components/prisma-client/working-with-prismaclient/connection-management#exit-hooks).

<!-- prettier-ignore -->
### <inlinecode>$use()</inlinecode>

The `$use()` method adds [middleware](/concepts/components/prisma-client/middleware) <span class="concept"></span>:

```ts
prisma.$use(async (params, next) => {
  console.log('This is middleware!')
  // Modify or interrogate params here

  return next(params)
})
```

#### <inlinecode>next</inlinecode>

`next` represents the "next level" in the middleware stack, which could be the next middleware or the Prisma Query, depending on [where in the stack you are](/concepts/components/prisma-client/middleware#running-order-and-the-middleware-stack).

#### <inlinecode>params</inlinecode>

`params` is an object with information to use in your middleware.

| Parameter          | Description                                                                                            |
| :----------------- | :----------------------------------------------------------------------------------------------------- |
| `action`           | The query type - for example, `create` or `findMany`.                                                  |
| `args`             | Arguments that were passed into the query - for example, `where`, `data`, or `orderBy`                 |
| `dataPath`         | Populated if you use the [fluent API](/concepts/components/prisma-client/relation-queries#fluent-api). |
| `model`            | The model type - for example, `Post` or `User`.                                                        |
| `runInTransaction` | Returns `true` if the query ran in the context of a [transaction](#transaction).                       |

<Tip>

If you need the `model` property as a string, use: `String(params.model)`

</Tip>

Example parameter values:

```js
{
  args: { where: { id: 15 } },
  dataPath: [ 'select', 'author', 'select', 'posts' ],
  runInTransaction: false,
  action: 'findMany',
  model: 'Post'
}
```

#### Reference

`params` accepts the following type:

```ts file=index.d.ts
export type MiddlewareParams = {
  model?: ModelName
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

export declare const ModelName: {
  User: 'User'
  Post: 'Post'
}

export declare type ModelName = typeof ModelName[keyof typeof ModelName]
```

#### Examples

See [middleware examples](/concepts/components/prisma-client/middleware#examples) <span class="concept"></span>.

<!-- prettier-ignore -->
### <inlinecode>$executeRaw()</inlinecode>

See: [Raw database access (`$executeRaw()`)](/concepts/components/prisma-client/raw-database-access#executeraw).

<!-- prettier-ignore -->
### <inlinecode>$queryRaw()</inlinecode>

See: [Raw database access (`$queryRaw()`)](/concepts/components/prisma-client/raw-database-access#queryraw).

<!-- prettier-ignore -->
### <inlinecode>$runCommandRaw()</inlinecode>

See: [Raw database access (`$runCommandRaw()`)](/concepts/components/prisma-client/raw-database-access#runcommandraw).

<!-- prettier-ignore -->
### <inlinecode>$transaction()</inlinecode>

See: [Transactions](/concepts/components/prisma-client/transactions).

<!-- prettier-ignore -->
### <inlinecode>$metrics</inlinecode>

Prisma metrics give you a detailed insight into how Prisma Client interacts with your database. You can use this insight to help diagnose performance issues with your application. Learn more: [Metrics](/concepts/components/prisma-client/metrics).

Prisma metrics has the following methods:

- `$metrics.json()`: [Retrieves Prisma metrics in JSON format](/concepts/components/prisma-client/metrics#retrieve-metrics-in-json-format).
- `$metrics.prometheus()`: [Retrieves Prisma metrics in Prometheus format](/concepts/components/prisma-client/metrics#retrieve-metrics-in-prometheus-format).

## Utility types

Utility types are helper functions and types that live on the Prisma namespace. They are useful for keeping your application type safe.

### <inlinecode>Prisma.validator</inlinecode>

The `validator` helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid. See also: [Using `Prisma.validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) <span class="concept"></span>

#### Reference

```ts
export function validator<V>(): <S>(select: Exact<S, V>) => S

type Exact<A, W = unknown> = W extends unknown
  ? A extends Narrowable
    ? Cast<A, W>
    : Cast<
        { [K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never },
        { [K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K] }
      >
  : never

type Narrowable = string | number | boolean | bigint

type Cast<A, B> = A extends B ? A : B

export const type: unique symbol
```

#### Examples

The following example shows how you can extract a `create` operation into a custom function for re-use and accepting form data:

```ts
import { Prisma } from '@prisma/client'

const createUserAndPost = (
  name: string,
  email: string,
  postTitle: string,
  profileBio: string
) => {
  return Prisma.validator<Prisma.UserCreateInput>()({
    name,
    email,
    posts: {
      create: {
        title: postTitle,
      },
    },
    profile: {
      create: {
        bio: profileBio,
      },
    },
  })
}
```

## Compare columns in the same table

From version 4.3.0, you can compare columns in the same table directly, for non-unique filters.

<Admonition type="info">

In the following situations, you must [use raw queries to compare columns in the same table](/guides/database/troubleshooting-orm/help-articles/comparing-columns-through-raw-queries):

- If you use a version earlier than 4.3.0
- If you want to use a unique filter, such as [`findUnique`](#findunique) or [`findUniqueOrThrow`](#finduniqueorthrow)
- If you want to compare a field with a [unique constraint](/guides/general-guides/database-workflows/unique-constraints-and-indexes)
- If you want to use one of the following operators to compare a [JSON field](/concepts/components/prisma-client/working-with-fields/working-with-json-fields) in MySQL or MariaDB with another field: [`gt`](#gt), [`gte`](#gte), [`lt`](#lt), or [`lte`](#lte). Note that you can use these operators to compare the JSON field with a scalar value. This limitation applies only if you try to compare a JSON field with another field.

</Admonition>

To enable column comparisons in the same table, add the `fieldReference` feature flag to the `generator` block of your Prisma Schema as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fieldReference"]
}
```

To compare columns the same table, use the `<model>.fields` property. In the following example, the query returns all records where the value in the `prisma.product.quantity` field is less than or equal to the value in the `prisma.product.warnQuantity` field.

```ts
prisma.product.findMany({
  where: { quantity: { lte: prisma.product.fields.warnQuantity } },
})
```

<Admonition type="info">

`fields` is a special property of every model. It contains the list of fields for that model.

</Admonition>

### Considerations

#### Fields must be of the same type

You can only make comparisons on fields of the same type. For example, the following causes an error:

```ts
await prisma.order.findMany({
  where: {
    id: { equals: prisma.order.fields.due },
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Type error: id is a string, while amountDue is an integer
  },
})
```

#### Fields must be in the same model

You can only make comparisons with the `fields` property on fields in the same model. The following example does not work:

```ts
await prisma.order.findMany({
  where: {
    id: { equals: prisma.user.fields.name },
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // Type error: name is a field on the User model, not Order
  },
})
```

However, you can compare fields in separate models with [standard queries](#model-queries).

#### In <inlinecode>groupBy</inlinecode> model queries, put your referenced fields in the <inlinecode>by</inlinecode> argument

If you use the [groupBy](#groupby) model query with the `having` option, then you must put your referenced fields in the `by` argument.

The following example works:

```ts
prisma.user.groupBy({
  by: ['id', 'name'],
  having: { id: { equals: prisma.user.fields.name } },
})
```

The following example does not work, because `name` is not in the `by` argument:

```ts
prisma.user.groupBy({
  by: ['id'],
  having: { id: { equals: prisma.user.fields.name } },
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // name is not in the 'by' argument
})
```

#### Search for fields in scalar lists

If your data source supports scalar lists (for example in PostgreSQL), then you can search for all records where a specific field is in a list of fields. To do so, reference the scalar list with the [`in`](#in) and [`notIn`](#notin) filters. For example:

```ts
await prisma.user.findMany({
  where: {
    // find all users where 'name' is in a list of tags
    name: { in: prisma.user.fields.tags },
  },
})
```

## Filter on non-unique fields with <inlinecode>UserWhereUniqueInput</inlinecode>

From version 4.5.0, the generated type `UserWhereUniqueInput` on [`where`](#where) exposes all fields on the model, not just unique fields. To use this feature, [enable the `extendedWhereUnique` preview flag](#enable-the-ability-to-filter-on-non-unique-fields-with-userwhereuniqueinput).

You must specify at least one unique field in your `where` statement [outside of boolean operators](#boolean-operators-with-userwhereuniqueinput), and you can specify any number of additional unique and non-unique fields. You can use this to add filters to any operation that returns a single record. For example, you can use this feature for the following:

- [Optimistic concurrency control on updates](#optimistic-concurrency-control-on-updates)
- [Permission checks](#permission-checks)
- [Soft deletes](#soft-deletes)

### Enable the ability to filter on non-unique fields with <inlinecode>UserWhereUniqueInput</inlinecode>

Enable the `extendedWhereUnique` preview flag in your `schema.prisma` file's `generator` block, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["extendedWhereUnique"]
}
```

### Optimistic concurrency control on updates

You can filter on non-unique fields to perform [optimistic concurrency control](/guides/performance-and-optimization/prisma-client-transactions-guide#optimistic-concurrency-control) on `update` operations.

To perform optimistic concurrency control, we recommend that you use a `version` field to check whether the data in a record or related record has changed while your code executes. Before version 4.5.0, you could not evaluate the `version` field in an `update` operation, because the field is non-unique. From version 4.5.0, you can evaluate the `version` field.

In the following example, `updateOne` and `updateTwo` first read the same record and then attempt to update it. The database only executes these updates if the value in `version` is the same as the value when it did the initial read. When the database executes the first of these updates (which might be `updateOne` or `updateTwo`, depending on timing), it increments the value in `version`. This means that the database does not execute the second update because the value in `version` has changed.

```prisma
model User {
  id      Int    @id @default(autoincrement())
  email   String @unique
  city    String
  version Int
}
```

```ts
function updateOne() {
  const user = await prisma.user.findUnique({ id: 1 })

  await prisma.user.update({
    where: { id: user.id, version: user.version },
    data: { city: 'Berlin', version: { increment: 1 } },
  })
}

function updateTwo() {
  const user = await prisma.user.findUnique({ id: 1 })

  await prisma.user.update({
    where: { id: user.id, version: user.version },
    data: { city: 'New York', version: { increment: 1 } },
  })
}

function main() {
  await Promise.allSettled([updateOne(), updateTwo()])
}
```

### Permission checks

You can filter on non-unique fields to check permissions during an update.

In the following example, a user wants to update a post title. The `where` statement checks the value in `authorId` to confirm that the user is the author of the post. The application only updates the post title if the user is the post author.

```ts
await prisma.post.update({
  where: { id: 1, authorId: 1 },
  data: { title: 'Updated post title' },
})
```

### Soft deletes

You can filter on non-unique fields to handle soft deletes.

In the following example, we do not want to return a post if it is soft-deleted. The operation only returns the post if the value in `isDeleted` is `false`.

```ts
prisma.Post.findUnique({ where: { id: postId, isDeleted: false } })
```

### <inlinecode>UserWhereUniqueInput</inlinecode> considerations

#### Boolean operators with <inlinecode>UserWhereUniqueInput</inlinecode>

With `UserWhereUniqueInput`, you must specify at least one unique field outside of the boolean operators `AND`, `OR`, `NOT`. You can still use these boolean operators in conjunction with any other unique fields or non-unique fields in your filter.

In the following example, we test `id`, a unique field, in conjunction with `email`. This is valid.

```ts
await prisma.user.update({
  where: { id: 1, OR: [{ email: "bob@prisma.io" }, { email: "alice@prisma.io" }] },
        // ^^^ Valid: the expression specifies a unique field (`id`) outside of any boolean operators
  data: { ... }
})

// SQL equivalent:
// WHERE id = 1 AND (email = "bob@prisma.io" OR email = "alice@prisma.io")
```

The following example is not valid, because there is no unique field outside of any boolean operators:

```ts
await prisma.user.update({
  where: { OR: [{ email: "bob@prisma.io" }, { email: "alice@prisma.io" }] },
        // ^^^ Invalid: the expressions does not contain a unique field outside of boolean operators
  data: { ... }
})
```

#### One-to-one relations

From version 4.5.0, you can filter on non-unique fields in the following operations on [one-to-one relations](/concepts/components/prisma-schema/relations/one-to-one-relations):

- Nested update
- Nested upsert
- Nested disconnect
- Nested delete

Prisma Client automatically uses a unique filter to select the appropriate related record. As a result, you do not need to specify a unique filter in your `where` statement with a `WhereUniqueInput` [generated type](#generated-types-for-where). Instead, the `where` statement has a `WhereInput` generated type. You can use this to filter without the restrictions of `WhereUniqueInput`.

##### Nested update example

```ts
await prisma.user.update({
  where: { id: 1, },
  data: {
    to_one: {
      // Before Prisma version 4.5.0
      update: { field: "updated" }
      // From Prisma version 4.5.0, you can also do the following:
      update: { where: { /*WhereInput*/ }, data: { field: "updated" } } }
    }
  }
})
```

##### Nested upsert example

```ts
await prisma.user.update({
  where: { id: 1, },
  data: {
    to_one: {
      upsert: {
        where: { /* WhereInput */ } // new argument from Prisma 4.5.0
        create: { /* CreateInput */ },
        update: { /* CreateInput */ },
      }
    }
  }
})
```

##### Nested disconnect example

```ts
await prisma.user.update({
  where: { id: 1, },
  data: {
    to_one: {
      // Before Prisma version 4.5.0
      disconnect: true
      // From Prisma version 4.5.0, you can also do the following:
      disconnect: { /* WhereInput */ }
    }
  }
})
```

##### Nested delete example

```ts
await prisma.user.update({
  where: { id: 1, },
  data: {
    to_one: {
      // Before Prisma version 4.5.0
      delete: true
      // From Prisma version 4.5.0, you can also do the following:
      delete: { /* WhereInput */ }
    }
  }
})
```
