---
title: 'Introspection'
metaTitle: 'Introspection'
metaDescription: 'Introspection your database with Prisma'
langSwitcher: ['typescript', 'node']
dbSwitcher: ['postgresql', 'mysql', 'sqlserver', 'planetscale', 'cockroachdb']
toc: false
---

## Introspect your database with Prisma

<SwitchTech technologies={['*', 'postgresql']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql no-lines
CREATE TABLE "public"."User" (
  id SERIAL PRIMARY KEY NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE "public"."Post" (
  id SERIAL PRIMARY KEY NOT NULL,
  title VARCHAR(255) NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INTEGER NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "public"."User"(id)
);

CREATE TABLE "public"."Profile" (
  id SERIAL PRIMARY KEY NOT NULL,
  bio TEXT,
  "userId" INTEGER UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "public"."User"(id)
);
```

> **Note**: Some fields are written in double-quotes to ensure PostgreSQL uses proper casing. If no double-quotes were used, PostgreSQL would just read everything as _lowercase_ characters.

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`       | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `name`      | `VARCHAR(255)` | No          | No          | No       | -                  |
| `email`     | `VARCHAR(255)` | No          | No          | **✔️**   | -                  |

**Post**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`       | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `createdAt` | `TIMESTAMP`    | No          | No          | **✔️**   | `now()`            |
| `title`     | `VARCHAR(255)` | No          | No          | **✔️**   | -                  |
| `content`   | `TEXT`         | No          | No          | No       | -                  |
| `published` | `BOOLEAN`      | No          | No          | **✔️**   | `false`            |
| `authorId`  | `INTEGER`      | No          | **✔️**      | **✔️**   | -                  |

**Profile**

| Column name | Type      | Primary key | Foreign key | Required | Default            |
| :---------- | :-------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`  | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `bio`       | `TEXT`    | No          | No          | No       | -                  |
| `userId`    | `INTEGER` | No          | **✔️**      | **✔️**   | -                  |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql no-lines
CREATE TABLE User (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Post (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  title VARCHAR(255) NOT NULL,
  createdAt TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  authorId INTEGER NOT NULL,
  FOREIGN KEY (authorId) REFERENCES User(id)
);

CREATE TABLE Profile (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  bio TEXT,
  userId INTEGER UNIQUE NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(id)
);
```

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER`      | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `name`      | `VARCHAR(255)` | No          | No          | No       | -                  |
| `email`     | `VARCHAR(255)` | No          | No          | **✔️**   | -                  |

**Post**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER`      | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `createdAt` | `DATETIME(3)`  | No          | No          | **✔️**   | `now()`            |
| `title`     | `VARCHAR(255)` | No          | No          | **✔️**   | -                  |
| `content`   | `TEXT`         | No          | No          | No       | -                  |
| `published` | `BOOLEAN`      | No          | No          | **✔️**   | `false`            |
| `authorId`  | `INTEGER`      | No          | **✔️**      | **✔️**   | `false`            |

**Profile**

| Column name | Type      | Primary key | Foreign key | Required | Default            |
| :---------- | :-------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER` | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `bio`       | `TEXT`    | No          | No          | No       | -                  |
| `userId`    | `INTEGER` | No          | **✔️**      | **✔️**   | -                  |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'planetscale']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql no-lines
CREATE TABLE `Post` (
  `id` int NOT NULL AUTO_INCREMENT,
  `createdAt` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `updatedAt` datetime(3) NOT NULL,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `content` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `published` tinyint(1) NOT NULL DEFAULT '0',
  `authorId` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Post_authorId_idx` (`authorId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `Profile` (
  `id` int NOT NULL AUTO_INCREMENT,
  `bio` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `userId` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `Profile_userId_key` (`userId`),
  KEY `Profile_userId_idx` (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `User` (
  `id` int NOT NULL AUTO_INCREMENT,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `User_email_key` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

<details><summary>Expand for a graphical overview of the tables</summary>

**Post**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `int`          | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `createdAt` | `datetime(3)`  | No          | No          | **✔️**   | `now()`            |
| `updatedAt` | `datetime(3)`  | No          | No          | **✔️**   |                    |
| `title`     | `varchar(255)` | No          | No          | **✔️**   | -                  |
| `content`   | `varchar(191)` | No          | No          | No       | -                  |
| `published` | `tinyint(1)`   | No          | No          | **✔️**   | `false`            |
| `authorId`  | `int`          | No          | No          | **✔️**   | -                  |

**Profile**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `int`          | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `bio`       | `varchar(191)` | No          | No          | No       | -                  |
| `userId`    | `int`          | No          | No          | **✔️**   | -                  |

**User**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `int`          | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `name`      | `varchar(191)` | No          | No          | No       | -                  |
| `email`     | `varchar(191)` | No          | No          | **✔️**   | -                  |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'sqlserver']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql no-lines
CREATE TABLE [dbo].[Post] (
    [id] INT NOT NULL IDENTITY(1,1),
    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,
    [updatedAt] DATETIME2 NOT NULL,
    [title] VARCHAR(255) NOT NULL,
    [content] NVARCHAR(1000),
    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,
    [authorId] INT NOT NULL,
    CONSTRAINT [Post_pkey] PRIMARY KEY ([id])
);

CREATE TABLE [dbo].[Profile] (
    [id] INT NOT NULL IDENTITY(1,1),
    [bio] NVARCHAR(1000),
    [userId] INT NOT NULL,
    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [Profile_userId_key] UNIQUE ([userId])
);

CREATE TABLE [dbo].[User] (
    [id] INT NOT NULL IDENTITY(1,1),
    [email] NVARCHAR(1000) NOT NULL,
    [name] NVARCHAR(1000),
    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [User_email_key] UNIQUE ([email])
);

ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;
```

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type             | Primary key | Foreign key | Required | Default            |
| :---------- | :--------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT`            | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `name`      | `NVARCHAR(1000)` | No          | No          | No       | -                  |
| `email`     | `NVARCHAR(1000)` | No          | No          | **✔️**   | -                  |

**Post**

| Column name | Type             | Primary key | Foreign key | Required | Default            |
| :---------- | :--------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT`            | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `createdAt` | `DATETIME2`      | No          | No          | **✔️**   | `now()`            |
| `updatedAt` | `DATETIME2`      | No          | No          | **✔️**   |                    |
| `title`     | `VARCHAR(255)`   | No          | No          | **✔️**   | -                  |
| `content`   | `NVARCHAR(1000)` | No          | No          | No       | -                  |
| `published` | `BIT`            | No          | No          | **✔️**   | `false`            |
| `authorId`  | `INT`            | No          | **✔️**      | **✔️**   | -                  |

**Profile**

| Column name | Type             | Primary key | Foreign key | Required | Default            |
| :---------- | :--------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT`            | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `bio`       | `NVARCHAR(1000)` | No          | No          | No       | -                  |
| `userId`    | `INT`            | No          | **✔️**      | **✔️**   | -                  |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'cockroachdb']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql no-lines
CREATE TABLE "User" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  name STRING(255),
  email STRING(255) UNIQUE NOT NULL
);

CREATE TABLE "Post" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  title STRING(255) UNIQUE NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content STRING,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INT8 NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "User"(id)
);

CREATE TABLE "Profile" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  bio STRING,
  "userId" INT8 UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "User"(id)
);
```

> **Note**: Some fields are written in double quotes to ensure CockroachDB uses proper casing. If no double-quotes were used, CockroachDB would just read everything as _lowercase_ characters.

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type          | Primary key | Foreign key | Required | Default            |
| :---------- | :------------ | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT8`        | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `name`      | `STRING(255)` | No          | No          | No       | -                  |
| `email`     | `STRING(255)` | No          | No          | **✔️**   | -                  |

**Post**

| Column name | Type          | Primary key | Foreign key | Required | Default            |
| :---------- | :------------ | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT8`        | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `createdAt` | `TIMESTAMP`   | No          | No          | **✔️**   | `now()`            |
| `title`     | `STRING(255)` | No          | No          | **✔️**   | -                  |
| `content`   | `STRING`      | No          | No          | No       | -                  |
| `published` | `BOOLEAN`     | No          | No          | **✔️**   | `false`            |
| `authorId`  | `INT8`        | No          | **✔️**      | **✔️**   | -                  |

**Profile**

| Column name | Type     | Primary key | Foreign key | Required | Default            |
| :---------- | :------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INT8`   | **✔️**      | No          | **✔️**   | _autoincrementing_ |
| `bio`       | `STRING` | No          | No          | No       | -                  |
| `userId`    | `INT8`   | No          | **✔️**      | **✔️**   | -                  |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'postgresql']}>

As a next step, you will introspect your database. The result of the introspection will be a [data model](/orm/prisma-schema/data-model/models) inside your Prisma schema.

Run the following command to introspect your database:

```terminal copy
npx prisma db pull
```

This commands reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection is complete, your Prisma schema file was updated:

![Introspect your database with Prisma](../../../../doc-images/prisma-db-pull-generate-schema.png)

The data model now looks similar to this (note that the fields on the models have been reordered for better readability):

```prisma file=prisma/schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}
```

Prisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

Right now, there's a few minor "issues" with the data model:

- The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more "semantics", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.
- The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.
- Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.

These changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).

Because [relation fields](/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:

```prisma file=prisma/schema.prisma highlight=8,15,22,23;edit
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  posts   Post[]
  profile Profile?
}
```

In this example, the database schema did follow the [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions) for Prisma models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.

<details>
<summary> Using custom model and field names </summary>

Sometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake_case_ notation:

```prisma no-lines
model my_user {
  user_id    Int     @id @default(autoincrement())
  first_name String?
  last_name  String  @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake_case_ notation in its API:

```ts no-lines
const user = await prisma.my_user.create({
  data: {
    first_name: 'Alice',
    last_name: 'Smith',
  },
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):

```prisma no-lines
model MyUser {
  userId    Int     @id @default(autoincrement()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts no-lines
const user = await prisma.myUser.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

Learn more about this on the [Configuring your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

As a next step, you will introspect your database. The result of the introspection will be a [data model](/orm/prisma-schema/data-model/models) inside your Prisma schema.

Run the following command to introspect your database:

```terminal copy
npx prisma db pull
```

This commands reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection is complete, your Prisma schema file was updated:

![Introspect your database with Prisma](../../../../doc-images/prisma-db-pull-generate-schema.png)

The data model now looks similar to this (note that the fields on the models have been reordered for better readability):

```prisma file=prisma/schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}
```

<Admonition>

Refer to the [Prisma schema reference](/orm/reference/prisma-schema-reference) for detailed information about the schema definition.

</Admonition>

Prisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

Right now, there's a few minor "issues" with the data model:

- The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more "semantics", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.
- The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.
- Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.

These changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).

Because [relation fields](/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:

```prisma file=prisma/schema.prisma highlight=8,17,24,25;edit
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  posts   Post[]
  profile Profile?
}
```

In this example, the database schema did follow the [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions) for Prisma models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.

Sometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake_case_ notation:

```prisma no-lines
model my_user {
  user_id    Int     @id @default(autoincrement())
  first_name String?
  last_name  String  @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake_case_ notation in its API:

```ts no-lines
const user = await prisma.my_user.create({
  data: {
    first_name: 'Alice',
    last_name: 'Smith',
  },
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):

```prisma no-lines
model MyUser {
  userId    Int     @id @default(autoincrement()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts no-lines
const user = await prisma.myUser.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

Learn more about this on the [Configuring your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.

</SwitchTech>

<SwitchTech technologies={['*', 'sqlserver']}>

As a next step, you will introspect your database. The result of the introspection will be a [data model](/orm/prisma-schema/data-model/models) inside your Prisma schema.

Run the following command to introspect your database:

```terminal copy
npx prisma db pull
```

This commands reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection is complete, your Prisma schema file was updated:

![Introspect your database with Prisma](../../../../doc-images/prisma-db-pull-generate-schema.png)

The data model now looks similar to this (note that the fields on the models have been reordered for better readability):

```prisma file=prisma/schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  User   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}
```

Prisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

Right now, there's a few minor "issues" with the data model:

- The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more "semantics", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.
- The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.
- Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.

These changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).

Because [relation fields](/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:

```prisma file=prisma/schema.prisma highlight=7,14,22,23;edit
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique @db.VarChar(255)
  name    String?  @db.VarChar(255)
  posts   Post[]
  profile Profile?
}
```

In this example, the database schema did follow the [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions) for Prisma models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.

<details>
<summary> Using custom model and field names </summary>

Sometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake_case_ notation:

```prisma no-lines
model my_user {
  user_id    Int     @id @default(autoincrement())
  first_name String?
  last_name  String  @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake_case_ notation in its API:

```ts no-lines
const user = await prisma.my_user.create({
  data: {
    first_name: 'Alice',
    last_name: 'Smith',
  },
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):

```prisma no-lines
model MyUser {
  userId    Int     @id @default(autoincrement()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts no-lines
const user = await prisma.myUser.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

Learn more about this on the [Configuring your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'planetscale']}>

As a next step, you will introspect your database. The result of the introspection will be a [data model](/orm/prisma-schema/data-model/models) inside your Prisma schema.

Run the following command to introspect your database:

```terminal copy
npx prisma db pull
```

This commands reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection is complete, your Prisma schema file was updated:

![Introspect your database with Prisma](../../../../doc-images/prisma-db-pull-generate-schema.png)

The data model now looks similar to this:

```prisma file=prisma/schema.prisma
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  authorId  Int

  @@index([authorId])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique

  @@index([userId])
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

<Admonition>

Refer to the [Prisma schema reference](/orm/reference/prisma-schema-reference) for detailed information about the schema definition.

</Admonition>

Prisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

You will then need to add in any missing relations between your data using [relation fields](/orm/prisma-schema/data-model/relations#relation-fields):

```prisma file=prisma/schema.prisma highlight=8,17,27,28;add
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index([authorId])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique

  @@index([userId])
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}
```

After this, run introspection on your database for a second time:

```terminal copy
npx prisma db pull
```

Prisma Migrate will now keep the manually added relation fields.

Because relation fields are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database.

In this example, the database schema follows the [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions) for Prisma models. This optimizes the ergonomics of the generated Prisma Client API.

<details>
<summary> Using custom model and field names </summary>

Sometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake_case_ notation:

```prisma no-lines
model my_user {
  user_id    Int     @id @default(autoincrement())
  first_name String?
  last_name  String  @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake_case_ notation in its API:

```ts no-lines
const user = await prisma.my_user.create({
  data: {
    first_name: 'Alice',
    last_name: 'Smith',
  },
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):

```prisma no-lines
model MyUser {
  userId    Int     @id @default(autoincrement()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts no-lines
const user = await prisma.myUser.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

Learn more about this on the [Configuring your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'cockroachdb']}>

As a next step, you will introspect your database. The result of the introspection will be a [data model](/orm/prisma-schema/data-model/models) inside your Prisma schema.

Run the following command to introspect your database:

```terminal copy
npx prisma db pull
```

This commands reads the environment variable used to define the `url` in your `schema.prisma`, `DATABASE_URL`, that in our case is set in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection is complete, your Prisma schema file was updated:

![Introspect your database with Prisma](../../../../doc-images/prisma-db-pull-generate-schema.png)

The data model now looks similar to this:

```prisma file=prisma/schema.prisma
model Post {
  id        BigInt   @id @default(autoincrement())
  title     String   @unique @db.String(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  BigInt
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     BigInt  @id @default(autoincrement())
  bio    String?
  userId BigInt  @unique
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      BigInt   @id @default(autoincrement())
  name    String?  @db.String(255)
  email   String   @unique @db.String(255)
  Post    Post[]
  Profile Profile?
}
```

Prisma's data model is a declarative representation of your database schema and serves as the foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

Right now, there's a few minor "issues" with the data model:

- The `User` relation field is uppercased and therefore doesn't adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) . To express more "semantics", it would also be nice if this field was called `author` to _describe_ the relationship between `User` and `Post` better.
- The `Post` and `Profile` relation fields on `User` as well as the `User` relation field on `Profile` are all uppercased. To adhere to Prisma's [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions-1) , both fields should be lowercased to `post`, `profile` and `user`.
- Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](/orm/prisma-schema/data-model/models#type-modifiers) of posts – a better name therefore would be the plural form: `posts`.

These changes are relevant for the generated Prisma Client API where using lowercased relation fields `author`, `posts`, `profile` and `user` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names).

Because [relation fields](/orm/prisma-schema/data-model/relations#relation-fields) are _virtual_ (i.e. they _do not directly manifest in the database_), you can manually rename them in your Prisma schema without touching the database:

```prisma file=prisma/schema.prisma highlight=8,15,22,23;edit
model Post {
  id        BigInt   @id @default(autoincrement())
  title     String   @unique @db.String(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  BigInt
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     BigInt  @id @default(autoincrement())
  bio    String?
  userId BigInt  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      BigInt   @id @default(autoincrement())
  name    String?  @db.String(255)
  email   String   @unique @db.String(255)
  posts   Post[]
  profile Profile?
}
```

In this example, the database schema did follow the [naming conventions](/orm/reference/prisma-schema-reference#naming-conventions) for Prisma models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API.

<details>
<summary> Using custom model and field names </summary>

Sometimes though, you may want to make additional changes to the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake_case_ notation which is often used in database schemas into _PascalCase_ and _camelCase_ notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake_case_ notation:

```prisma no-lines
model my_user {
  user_id    Int     @id @default(sequence())
  first_name String?
  last_name  String  @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake_case_ notation in its API:

```ts no-lines
const user = await prisma.my_user.create({
  data: {
    first_name: 'Alice',
    last_name: 'Smith',
  },
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](/orm/prisma-schema/data-model/models#mapping-model-names-to-tables-or-collections):

```prisma no-lines
model MyUser {
  userId    Int     @id @default(sequence()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts no-lines
const user = await prisma.myUser.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

Learn more about this on the [Configuring your Prisma Client API](/orm/prisma-client/setup-and-configuration/custom-model-and-field-names) page.

</details>

</SwitchTech>

<SwitchTech technologies={['node', 'postgresql']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-node-postgresql"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-node-postgresql"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['node', 'mysql']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-node-mysql"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-node-mysql"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['node', 'planetscale']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-node-planetscale"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./install-prisma-client-node-planetscale"
  arrow
>
  Install Prisma Client
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['node', 'sqlserver']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-node-sqlserver"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-node-sqlserver"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['node', 'cockroachdb']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-node-cockroachdb"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-node-cockroachdb"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['typescript', 'postgresql']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-typescript-postgresql"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-typescript-postgresql"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['typescript', 'mysql']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-typescript-mysql"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-typescript-mysql"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['typescript', 'planetscale']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-typescript-planetscale"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./install-prisma-client-typescript-planetscale"
  arrow
>
  Install Prisma Client
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['typescript', 'sqlserver']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-typescript-sqlserver"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-typescript-sqlserver"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>

<SwitchTech technologies={['typescript', 'cockroachdb']}>

<NavigationLinksContainer>

<ButtonLink
  color="dark"
  type="primary"
  href="./connect-your-database-typescript-cockroachdb"
  arrowLeft
>
  Connect your database
</ButtonLink>

<ButtonLink
  color="dark"
  type="primary"
  href="./baseline-your-database-typescript-cockroachdb"
  arrow
>
  Baseline your database
</ButtonLink>

</NavigationLinksContainer>

</SwitchTech>
