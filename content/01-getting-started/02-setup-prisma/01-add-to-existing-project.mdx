---
title: 'Add to existing project'
metaTitle: 'Add Prisma to an existing project (15 min)'
metaDescription: 'Learn how to add Prisma to an existing Node.js or TypeScript project by connecting it to your database and generating Prisma Client for database access.'
dbSwitcher: true
langSwitcher: true
---

## Overview

<SwitchTech technologies={['typescript', '*']}>

This page walks you through the process of adding Prisma to a **TypeScript** project with an existing database. 

</SwitchTech>

<SwitchTech technologies={['node', '*']}>

This page walks you through the process of adding Prisma to a **Node.js** project with an existing database. 

</SwitchTech>

You can also watch this short [video series](https://www.youtube.com/playlist?list=PLn2e1F9Rfr6k9PnR_figWOcSHgc_erDr5) that shows the Prisma setup process with an existing database.

## Prerequisites

In order to successfully complete this guide, you need:

<SwitchTech technologies={['*', 'postgresql']}>

- an existing Node.js (version 10 or higher) project with a `package.json`
- [Node.js](https://nodejs.org/en/) installed on your machine
- a [PostgreSQL](https://www.postgresql.org/) database server running and a database with at least one table

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

- an existing Node.js (version 10 or higher) project with a `package.json`
- [Node.js](https://nodejs.org/en/) installed on your machine
- a [MySQL](https://www.mysql.com/) database server running and a database with at least one table

</SwitchTech>

Make sure you have your database [connection URL](../../reference/database-connectors/connection-urls) (includes your authentication credentials) at hand!

If you don't have a database server running and only want to explore Prisma, check out the [Quickstart](../quickstart).

## Setup Prisma

As a first step, navigate into it your project directory that contains the `package.json`.

Next, add the Prisma CLI as a development dependency to your project:

```
npm install @prisma/cli --save-dev
```

You can now invoke the Prisma CLI by prefixing it with `npx`:

```
npx prisma
```

Next, set up your Prisma project by creating your [Prisma schema](../../reference/tools-and-interfaces/prisma-schema/prisma-schema-file) file with the following command:

```
npx prisma init
```

This command created a new directory called `prisma` with the following contents:

- `schema.prisma`: The Prisma schema with your database connection and the Prisma Client generator
- `.env`: A [dotenv](https://github.com/motdotla/dotenv) file for defining environment variables (used for your database connection)

## Connect your database

To connect your database, you need to set the `url` field of the `datasource` block in your Prisma schema to your database [connection URL](../../reference/tools-and-interfaces/database-connectors/connection-urls):

<SwitchTech technologies={['*', 'postgresql']}>

```prisma
datasource postgresql {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

In this case, the `url` is [set via an environment variable](../../reference/tools-and-interfaces/prisma-schema/prisma-schema-file#using-environment-variables) which is defined in `prisma/.env`:

```
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"
```

You now need to adjust the connection URL to point to your own database. 

The format of the connection URL for your database typically depends on the database you use. For PostgreSQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):

```
postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
```

Here's a short explanation of each component:

- `USER`: The name of your database user
- `PASSWORD`: The password your database user
- `PORT`: The port where your database server is running (typically `5432` for PostgreSQL)
- `DATABASE`: The name of the [database](https://www.postgresql.org/docs/12/manage-ag-overview.html)
- `SCHEMA`: The name of the [schema](https://www.postgresql.org/docs/12/ddl-schemas.html) inside the database 

If you're unsure what to provide for the `schema` parameter for a PostgreSQL connection URL, you can probably omit it. In that case, the default schema name `public` will be used.

As an example, for a PostgreSQL database hosted on Heroku, the [connection URL](../../reference/tools-and-interfaces/database-connectors/connection-urls) might look similar to this:

```
DATABASE_URL="postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma"
```

When running PostgreSQL locally, your user and password as well as the database name _typically_ correspond to the current _user_ of your OS, e.g. assuming the user is called `janedoe`:

```
DATABASE_URL="postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma"
```

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```prisma
datasource postgresql {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

Note that the default schema created by `prisma init` uses PostgreSQL, so you first need to switch the `provider` to `mysql`:

```prisma
datasource mysql {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

In this case, the `url` is [set via an environment variable](../../reference/tools-and-interfaces/prisma-schema/prisma-schema-file#using-environment-variables) which is defined in `prisma/.env`:

```
DATABASE_URL="mysql://johndoe:randompassword@localhost:3306/mydb"
```

You now need to adjust the connection URL to point to your own database. 

The format of the connection URL for your database typically depends on the database you use. For MySQL, it looks as follows (the parts spelled all-uppercased are _placeholders_ for your specific connection details):

```
mysql://USER:PASSWORD@HOST:PORT/DATABASE
```

Here's a short explanation of each component:

- `USER`: The name of your database user
- `PASSWORD`: The password your database user
- `PORT`: The port where your database server is running (typically `3306` for MySQL)
- `DATABASE`: The name of the [database](https://dev.mysql.com/doc/refman/8.0/en/creating-database.html)

As an example, for a MySQL database hosted on AWS RDS, the [connection URL](../../reference/tools-and-interfaces/database-connectors/connection-urls) might look similar to this:

```
DATABASE_URL="mysql://johndoe:XXX@mysql–instance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb
```

When running MySQL locally, your connection URL typically looks similar to this:

```
DATABASE_URL="mysql://root:randompassword@localhost:3306/mydb"
```

</SwitchTech>

## Introspect your database with Prisma

<SwitchTech technologies={['*', 'postgresql']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql copy
CREATE TABLE "public"."User" (
  id SERIAL PRIMARY KEY NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE "public"."Post" (
  id SERIAL PRIMARY KEY NOT NULL,
  title VARCHAR(255) NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INTEGER NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "public"."User"(id)
);

CREATE TABLE "public"."Profile" (
  id SERIAL PRIMARY KEY NOT NULL,
  bio TEXT,
  "userId" INTEGER UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "public"."User"(id)
);
```

> **Note**: Some fields are written in double-quotes to ensure PostgreSQL uses proper casing. If no double-quotes were used, PostgreSQL would just read everything as _lowercase_ characters.

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`       | **✔️**         | No          | No       | _autoincrementing_ |
| `name`      | `VARCHAR(255)` | No          | No          | No       | -                  |
| `email`     | `VARCHAR(255)` | No          | No          | **✔️**      | -                  |

**Post**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`       | **✔️**         | No          | No       | _autoincrementing_ |
| `createdAt` | `TIMESTAMP`    | No          | No          | **✔️**      | `now()`            |
| `title`     | `VARCHAR(255)` | No          | No          | **✔️**      | -                  |
| `content`   | `TEXT`         | No          | No          | No       | -                  |
| `published` | `BOOLEAN`      | No          | No          | **✔️**      | `false`            |
| `authorId`    | `INTEGER`      | No          | **✔️**         | **✔️**      | `false`            |

**Profile**

| Column name | Type      | Primary key | Foreign key | Required | Default            |
| :---------- | :-------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `SERIAL`  | **✔️**         | No          | No       | _autoincrementing_ |
| `bio`       | `TEXT`    | No          | No          | **✔️**      | -                  |
| `userId`      | `INTEGER` | No          | **✔️**         | **✔️**      |-          |

</details>

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

For the purpose of this guide, we'll use a demo SQL schema with three tables:

```sql copy
CREATE TABLE User (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Post (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  title VARCHAR(255) NOT NULL,
  createdAt TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  authorId INTEGER NOT NULL,
  FOREIGN KEY (authorId) REFERENCES User(id)
);

CREATE TABLE Profile (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  bio TEXT,
  userId INTEGER UNIQUE NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(id)
);
```

<details><summary>Expand for a graphical overview of the tables</summary>

**User**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER`       | **✔️**         | No          | No       | _autoincrementing_ |
| `name`      | `VARCHAR(255)` | No          | No          | No       | -                  |
| `email`     | `VARCHAR(255)` | No          | No          | **✔️**      | -                  |

**Post**

| Column name | Type           | Primary key | Foreign key | Required | Default            |
| :---------- | :------------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER`       | **✔️**         | No          | No       | _autoincrementing_ |
| `createdAt` | `TIMESTAMP`    | No          | No          | **✔️**      | `now()`            |
| `title`     | `VARCHAR(255)` | No          | No          | **✔️**      | -                  |
| `content`   | `TEXT`         | No          | No          | No       | -                  |
| `published` | `BOOLEAN`      | No          | No          | **✔️**      | `false`            |
| `authorId`    | `INTEGER`      | No          | **✔️**         | **✔️**      | `false`            |

**Profile**

| Column name | Type      | Primary key | Foreign key | Required | Default            |
| :---------- | :-------- | :---------- | :---------- | :------- | :----------------- |
| `id`        | `INTEGER`  | **✔️**         | No          | No       | _autoincrementing_ |
| `bio`       | `TEXT`    | No          | No          | **✔️**      | -                  |
| `userId`      | `INTEGER` | No          | **✔️**         | **✔️**      | -           |

</details>

</SwitchTech>

As a next step, you will introspect your database. The result of the introspection will be a [data model](../../reference/tools-and-interfaces/prisma-schema/data-model) inside your Prisma schema.

Run the following command to introspect your database:

```
npx prisma introspect
```

This commands reads the `DATABASE_URL` environment variable that's defined in `.env` and connects to your database. Once the connection is established, it introspects the database (i.e. it _reads the database schema_). It then translates the database schema from SQL into a Prisma data model.

After the introspection has completed, your Prisma schema file was updated:

![](https://imgur.com/f7itiYw.png)

The data model now looks similar to this (note that the fields on the models have been reordered for better readability):

```prisma
model Post {
  id        Int      @default(autoincrement()) @id
  createdAt DateTime @default(now())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index([authorId], name: "authorId")
}

model Profile {
  id     Int      @default(autoincrement()) @id
  bio    String?
  user   User     @relation(fields: [userId], references: [id])
  userId Int      @unique
}

model User {
  id      Int      @default(autoincrement()) @id
  email   String   @unique
  name    String?
  Post    Post[]
  Profile Profile?
}
```

Prisma's data model is a declarative representation of your database schema and serves as foundation for the generated Prisma Client library. Your Prisma Client instance will expose queries that are _tailored_ to these models.

Right now, there's a few minor "issues" with the data model:

- The `Post` and `Profile` relation fields on `User` are both uppercased. To adhere to Prisma's [naming conventions](../../reference/tools-and-interfaces/prisma-schema/models#naming-models), both fields should be lowercased to `post` and `profile`.
- Even after lowercasing, the `post` field on `User` is still slightly misnamed. That's because it actually refers to a [list](../../reference/tools-and-interfaces/prisma-schema/models#type-modifiers) of posts – a better name therefore would be the plural from `posts`.

These changes are relevant for the generated Prisma Client API where using `posts` and `profile` will feel more natural and idiomatic to JavaScript/TypeScript developers. You can therefore [configure your Prisma Client API](../../reference/tools-and-interfaces/prisma-client/configuring-the-prisma-client-api).

Because both the generated `Post` and `Profile` fields are _virtual_ (i.e. they're _not backed by a foreign key in the database_), you can manually rename them in your Prisma schema:

```prisma
model User {
  id      Int       @default(autoincrement()) @id
  name    String?
  email   String    @unique
  posts   Post[]
  profile Profile?
}
```

In this example, the database schema did follow the [naming conventions](../../reference/tools-and-interfaces/prisma-schema/models#naming-models) for Prisma models (only the virtual relation fields that were generated from introspection did not adhere to them and needed adjustment). This optimizes the ergonomics of the generated Prisma Client API. 

Sometimes though, you may want to make additional changes to the the names of the columns and tables that are exposed in the Prisma Client API. A common example is to translate _snake\_case_ notation which is often used in database schemas into ` PascalCase` and `camelCase` notations which feel more natural for JavaScript/TypeScript developers.

Assume you obtained the following model from introspection that's based on _snake\_case_ notation:

```prisma
model my_user {
  user_id     Int       @default(autoincrement()) @id
  first_name  String?
  last_name   String    @unique
}
```

If you generated a Prisma Client API for this model, it would pick up the _snake\_case_ notation in its API:

```ts
const user = await prisma.my_user.create({
  data: {
    first_name: "Alice",
    last_name: "Smith"
  }
})
```

If you don't want to use the table and column names from your database in your Prisma Client API, you can configure them with [`@map` and `@@map`](../../reference/tools-and-interfaces/prisma-schema/data-model#mapping-column-table-and-enum-names):

```prisma
model MyUser {
  user_id     Int       @default(autoincrement()) @id @map("user_id")
  firstName  String?    @map("first_name")
  lastName   String    @unique @map("last_name")

  @@map("my_user")
}
```

With this approach, you can name your model and its fields whatever you like and use the `@map` (for field names) and `@@map` (for models names) to point to the underlying tables and columns. Your Prisma Client API now looks as follows:

```ts
const user = await prisma.myUser.create({
  data: {
    firstName: "Alice",
    lastName: "Smith"
  }
})
```

Learn more about this on the [Configuring your Prisma Client API](../../reference/tools-and-interfaces/prisma-client/configuring-the-prisma-client-api) page.

## Install and generate Prisma Client

To get started with Prisma Client, you need to install it as a node module:

```
npm install @prisma/client
```

Notice that the [`@prisma/client` node module](../../reference/tools-and-interfaces/prisma-client/configuring-the-prisma-client-api#the-prisma-client-npm-module) is a bit different from "conventional" node modules (e.g. a library like [`lodash`](https://lodash.com/)). When installing the module with `npm install @prisma/client`, npm only downloads an empty package into the `node_modules/@prisma/client` directory. The package is then "filled" with the actual library with the following command of the Prisma CLI:

```
npx prisma generate
```

This commands reads your Prisma schema and generates your Prisma Client library into `node_modules/@prisma/client`.

![](https://imgur.com/FensWfo.png)

Because the `@prisma/client` node module actually is customized to your project, it is sometimes referred to as a "smart node module":

![](https://i.imgur.com/83djlkl.png)

## Write your first query with Prisma Client

Now that you generated your Prisma Client library, you can start writing queries to read and write data in your database. So, now would be the time to start integrating Prisma Client in your application. For example, if you're building a REST API, you can use Prisma Client in your route handlers to read and write data in the database based on incoming HTTP requests. If you're building a GraphQL API, you can use Prisma Client in your resolvers to read and write data in the database based on incoming queries and mutations.

For the purpose of this guide however, you'll just create a plain Node.js script to learn how to send queries to your database using Prisma Client. Once you have an understanding of how the API works, you can start integrating it into your actual application code (e.g. REST route handlers or GraphQL resolvers).

<SwitchTech technologies={['typescript', '*']}>

Create a new file called `index.ts` and add the following code to it:

```js
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.disconnect()
  })
```

</SwitchTech>

<SwitchTech technologies={['node', '*']}>

Create a new file called `index.js` and add the following code to it:

```js
const { PrismaClient } = require("@prisma/client")

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.disconnect()
  })
```

</SwitchTech>

Here's a quick overview of the different parts of the code snippet:

1. Import the `PrismaClient` constructor from the `@prisma/client` node module
1. Instantiate `PrismaClient`
1. Define an `async` function called `main` to send queries to the database
1. Call the `main` function
1. Close the database connections when the script terminates

Depending on what your models look like, the Prisma Client API will look different as well. For example, if you have a `User` model, your `PrismaClient` instance exposes a property called `user` on which you can call [CRUD](../../reference/tools-and-interfaces/prisma-client/crud) methods like `findMany`, `create` or `update`. The property is named after the model, but the first letter is lowercased (so for the `Post` model the property is called `post`, for `Profile` it's called `profile`).

The following examples are all based on the models in the Prisma schema.

Inside the `main` function, add the folowing query to read all `User` records from the database and print the result:

```js
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}
```

<SwitchTech technologies={['typescript', '*']}>

Now run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:

```
ts-node index.ts
```

</SwitchTech>

<SwitchTech technologies={['node', '*']}>

Now run the code with this command:

```
node index.js
```

</SwitchTech>

This will print an array of `User` records as plain old JavaScript objects.

## Write data into the database

The `findMany` query you used in the previous section only _reads_ data from the database. In this section, you'll learn how to write a query to _write_ new records into the `Post` and `User` tables.

Adjust the `main` function to send a `create` query to the database:

```js
async function main() {

  await prisma.user.create({
    data: {
      name: "Alice",
      email: "alice@prisma.io",
      author: {
        create: { title: "Hello World" },
      },
      profile: {
        create: { bio:  "I like turtles" }
      }
    }
  })

  const allUsers = await prisma.user.findMany({
    include: { 
      posts: true,
      profile: true 
    },
  })
  console.dir(allUsers, { depth: null })
}
```

This code creates a new `User` record together with new `Post` and `Profile` records using a [nested write](#nested-writes) query. The `User` record is connected to the two other ones via the `Post.author` ↔ `User.posts` and `Profile.user` ↔ `User.profile` [relation fields](../../reference/tools-and-interfaces/prisma-schema/relations#relation-fields) respectively.

Notice that you're passing the [`include`](../../reference/tools-and-interfaces/prisma-client/field-selection#include) option to `findMany` which tells Prisma Client to include the `posts` and `profile` relations on the returned `User` objects.

<SwitchTech technologies={['typescript', '*']}>

Run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:

```
ts-node index.ts
```

</SwitchTech>

<SwitchTech technologies={['node', '*']}>

Run the code with this command:

```
node index.js
```

</SwitchTech>

Before moving on to the next section, you'll "publish" the `Post` record you just created using an `update` query. Adjust the `main` function as follows:

```js
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}
```

Now run the code using the same command as before:

<SwitchTech technologies={['typescript', '*']}>

Run the code with your current TypeScript setup. If you're using `ts-node`, you can run it like this:

```
ts-node index.ts
```

</SwitchTech>

<SwitchTech technologies={['node', '*']}>

Now run the code using the same command as before:

```
node index.js
```

</SwitchTech>

## Next steps

This section lists a number of potential next steps you can now take from here. Feel free to explore those or read the [Introduction](../../understand-prisma/introduction) page to get a high-level overview of Prisma.

### Continue exploring the Prisma Client API

You can send a variety of different queries with the Prisma Client API. Check out the [API reference](../../reference/tools-and-interfaces/prisma-client/api) and use your existing database setup from this guide to try them out.

**Tip**: You can use your editor's auto-completion feature to learn about the different API calls and the arguments it takes. Auto-completion is commonly invoked by hitting <kbd>CTRL</kbd>+<kbd>SPACE</kbd> on your keyboard.

<details><summary>Expand for more Prisma Client API examples</summary>

Here are a few suggestions for a number of more queries you can send with Prisma Client:

**Filter all `Post` records that contain `"hello"`**

```js
const filteredPosts = await prisma.post.findMany({
  where: {
    OR: [
      { title: { contains: "hello" },
      { content: { contains: "hello" },
    ],
  },
})
```

**Create a new `Post` record and connect it to an existing `User` record**

```js
const post = await prisma.post.create({
  data: {
    title: "Join us for Prisma Day 2020",
    posts: {
      connect: { email: "alice@prisma.io" },
    },
  },
})
```

**Use the fluent relations API to retrieve the `Post` records of a `User` by traversing the relations**

```js
const posts = await prisma.profile
  .findOne({
    where: { id: 1 },
  })
  .user()
  .posts()
```

**Delete a `User` record**

```js
const deletedUser = await prisma.user.delete({
  where: { email: "sarah@prisma.io" },
})
```

</details>

---

### Explore the data in Prisma Studio (experimental)

Prisma Studio is a visual editor for the data in your database. You can use it by running the following command:

```
npx prisma studio --experimental
```

### Change the database schema (e.g. add more tables)

To evolve the app, you need to follow the same flow of the tutorial:

1. Manually adjust your database schema using SQL
1. Re-introspect your database
1. Optionally re-configure your Prisma Client API
1. Re-generate Prisma Client

![](https://imgur.com/ToNkpb2.png)

---

### Try a Prisma example

The [`prisma-examples`](https://github.com/prisma/prisma-examples/) repository contains a number of ready-to-run examples:

**TypeScript**

| Demo                                                                                                               | Stack        | Description                                                                                         |
| :----------------------------------------------------------------------------------------------------------------- | :----------- | --------------------------------------------------------------------------------------------------- |
| [`rest-nextjs`](https://github.com/prisma/prisma-examples/tree/master/typescript/rest-nextjs)                     | Fullstack    | Simple [Next.js](https://nextjs.org/) app (React) with a REST API                                   |
| [`graphql-nextjs`](https://github.com/prisma/prisma-examples/tree/master/typescript/graphql-nextjs)               | Fullstack    | Simple [Next.js](https://nextjs.org/) app (React) with a GraphQL API                                |
| [`graphql-apollo-server`](https://github.com/prisma/prisma-examples/tree/master/typescript/graphql-apollo-server) | Backend only | Simple GraphQL server based on [`apollo-server`](https://www.apollographql.com/docs/apollo-server/) |
| [`rest-express`](https://github.com/prisma/prisma-examples/tree/master/typescript/rest-express)                   | Backend only | Simple REST API with Express.JS                                                                     |
| [`grpc`](https://github.com/prisma/prisma-examples/tree/master/typescript/grpc)                                   | Backend only | Simple gRPC API                                                                                     |

**JavaScript (Node.js)**

| Demo                                                                                                               | Stack        | Description                                                                                         |
| :----------------------------------------------------------------------------------------------------------------- | :----------- | :-------------------------------------------------------------------------------------------------- |
| [`rest-nextjs`](https://github.com/prisma/prisma-examples/tree/master/javascript/rest-nextjs)                     | Fullstack    | Simple [Next.js](https://nextjs.org/) app (React) with a REST API                                   |
| [`graphql-apollo-server`](https://github.com/prisma/prisma-examples/tree/master/javascript/graphql-apollo-server) | Backend only | Simple GraphQL server based on [`apollo-server`](https://www.apollographql.com/docs/apollo-server/) |
| [`rest-express`](https://github.com/prisma/prisma-examples/tree/master/javascript/rest-express)                   | Backend only | Simple REST API with Express.JS                                                                     |
| [`grpc`](https://github.com/prisma/prisma-examples/tree/master/javascript/grpc)                                   | Backend only | Simple gRPC API                                                                                     |


