---
title: 'Prisma Migrate'
metaTitle: 'Prisma Migrate | Database, Schema, SQL Migration Tool'
metaDescription: 'Prisma Migrate is a database migration tool available via the Prisma CLI that integrates with Prisma schema for data modeling.'
tocDepth: 3
---

<TopBlock>

Prisma Migrate is an **imperative database schema migration tool** that enables you to:

- Keep your database schema in sync with your [Prisma schema](../prisma-schema) as it evolves _and_
- Maintain existing data in your database

Prisma Migrate generates [a history of `.sql` migration files](#migration-history), and plays a role in both [development](#development-environments) and [deployment](#production-and-testing-environments).

> **Tip**: If you are prototyping, consider using the [`db push` command](db-push) - see [Schema prototyping with `db push`](../../../guides/application-lifecycle/prototyping-schema-db-push) <span class="guide"></span> for examples.

</TopBlock>

## Getting started with Prisma Migrate

> See [Developing with Prisma Migrate](../../../guides/application-lifecycle/developing-with-prisma-migrate) <span class="guide"></span> for a more in-depth development workflow.

To get started with Prisma Migrate in a development environment:

1. Create a Prisma schema:

   ```prisma file=schema.prisma
   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }

   model User {
     id    Int      @id @default(autoincrement())
     name  String
     posts Post[]
   }

   model Post {
     id        Int     @id @default(autoincrement())
     title     String
     published Boolean @default(true)
     authorId  Int
     author    User    @relation(fields: [authorId], references: [id])
   }
   ```

   > **Tip**: You can use [native type mapping attributes](type-mapping) in your schema to decide which exact database type to create (for example, `String` can map to `varchar(100)` or `text`).

1. Create the first migration:

   <CodeWithResult showText="Show migration SQL" hideText="Hide migration SQL">
   <Cmd>

   ```terminal
   prisma migrate dev --name init
   ```

   </Cmd>
   <CmdResult>

   ```sql
     -- CreateTable
   CREATE TABLE "User" (
   "id" SERIAL,
       "name" TEXT NOT NULL,

       PRIMARY KEY ("id")
   );
     -- CreateTable
   CREATE TABLE "Post" (
   "id" SERIAL,
       "title" TEXT NOT NULL,
       "published" BOOLEAN NOT NULL DEFAULT true,
       "authorId" INTEGER NOT NULL,

       PRIMARY KEY ("id")
   );

     -- AddForeignKey
   ALTER TABLE "Post" ADD FOREIGN KEY("authorId")REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
   ```

   </CmdResult>
   </CodeWithResult>

   Your Prisma schema is now in sync with your database schema and you have initialized a migration history:

   ```
   migrations/
     └─ 20210313140442_init/
       └─ migration.sql
   ```

1. Evolve your schema by introducing additional fields:

   ```prisma highlight=3;add
   model User {
     id       Int      @id @default(autoincrement())
     jobTitle String
     name     String
     posts    Post[]
   }
   ```

1. Create the second migration:

   <CodeWithResult showText="Show migration SQL" hideText="Hide migration SQL">
   <Cmd>

   ```terminal
   prisma migrate dev --name added_job_title
   ```

   </Cmd>
   <CmdResult>

   ```sql
     -- AlterTable
   ALTER TABLE "User" ADD COLUMN     "jobTitle" TEXT NOT NULL;
   ```

   </CmdResult>
   </CodeWithResult>

   Your Prisma schema is once again in sync with your database schema, and your migration history contains two migrations:

   ```
   migrations/
     └─ 20210313140442_init/
       └─ migration.sql
     └─ 20210313140442_added_job_title/
       └─ migration.sql
   ```

You now have a migration history that you can [source control](#team-development) and use to [deploy changes to test environments and production](#production-and-testing-environments).

## Migration history

Your migration history is the story of the changes to your data model, and is represented by:

- A `prisma/migrations` folder with a sub-folder and `migration.sql` file for each migration:

  ```
  migrations/
    └─ 20210313140442_init/
      └─ migration.sql
    └─ 20210313140442_added_job_title/
      └─ migration.sql
  ```

  This folder is the **source of truth** for the history of your data model.

- A `_prisma_migrations` table in the database, which is used to check:

  - If a migration has been run against the database
  - If an applied migration has been deleted
  - If an applied migration has been changed

  If you change or delete a migration (**not** recommended), the next steps depend on whether you are in a [development environment](#development-environments) (and therefore using `migrate dev`) or a [production / testing environment](#production-and-testing-environments) (and therefore using `migrate deploy`).

### Do not edit or delete migrations that have been applied

In general, you **should not edit or delete** a migration that has already been applied. Doing so can lead to inconsistencies between development and production environment migration histories, which may have unforeseen consequences - even if the change does not _appear_ to break anything at first.

The following scenario simulates a change that creates a seemingly harmless inconsistency:

1. Modify an **existing migration** that has **already been applied** in a development environment by changing the value of `VARCHAR(550)` to `VARCHAR(560)`:

   ```sql file=./prisma/migrations/20210310143435_default_value/migrations.sql
     -- AlterTable
    ALTER TABLE "Post" ALTER COLUMN "content" SET DATA TYPE VARCHAR(560);
   ```

   After making this change, the end state of the migration history no longer matches the Prisma schema, which still has `@db.VarChar(550)`.

1. Run `prisma migrate dev` - Prisma Migrate detects that a migration has changed, and asks to `reset` the database:

   ```bash
   ? The migration `20210310143435_change_type` was modified after it was applied.

    We need to reset the PostgreSQL database "migrate-example" at "localhost:5432".
    Do you want to continue? All data will be lost. » (y/N)
   ```

1. If you accept resetting, Prisma Migrate resets the database and replays all migrations, including the migration you edited.

1. After applying all existing migrations, Prisma Migrate compares the end state of the migration history to the Prisma schema and detects a discrepancy:

   - Prisma schema has `@db.VarChar(550)`
   - Database schema has `VARCHAR(560)`

1. Prisma Migrate generates a new migration to change the value back to `550`, because the end state of the migration history should match the Prisma schema.

1. From now on, when you use `prisma migrate deploy` to deploy migrations to production and test environments, Prisma Migrate will always **warn you** that migration histories do not match (and continue to warn you each time you run the command ) - even though the schema end states match:

```bash
6 migrations found in prisma/migrations
WARNING The following migrations have been modified since they were applied:
20210310143435_change_type
```

A change that does not appear to break anything after a `migrate reset` can hide problems - you may end up with a bug in production that you cannot replicate in development, or the other way around - particularly if the change concerns a highly customized migration.

If Prisma Migrate reports a missing or edited migration that has already been applied, we recommend fixing the **root cause** (restoring the file or reverting the change) rather than resetting.

### Source-controlling the migration history

You should commit the entire `prisma/migrations` folder to source control. This includes the `prisma/migrations/migration_lock.toml` file, which is used to detect if you have [attempted to change providers](prisma-migrate-limitations-issues#you-cannot-switch-database-providers).

## Development environments

In a development environment, use the `migrate dev` command to generate and apply migrations:

```terminal
npx prisma migrate dev
```

This command:

1. Replays the existing migration history in the [shadow database](shadow-database) in order to detect schema drift (edited or deleted migration file, or a manual changes to the database schema)
1. Applies pending migrations to the shadow database (for example, new migrations created by colleagues)
1. Generates a new migration from any changes you made to the Prisma schema before running `migrate dev`
1. Applies all unapplied migrations to the development database and updates the `_prisma_migrations` table
1. Triggers the generation of artifacts (for example, the Prisma Client)

The `migrate dev` command will prompt you to reset the database in the following scenarios:

- Migration history conflicts caused by [modified or missing migrations](#do-not-edit-or-delete-migrations-that-have-been-applied)
- The database schema has drifted away from the end-state of the migration history

You can also `reset` the database yourself to undo manual changes or `db push` experiments by running:

```terminal
npx prisma migrate reset
```

This command:

1. Drops the database
1. Creates a new database with the same name
1. Applies all migrations
1. Runs seed scripts

> **Note**: For a simple and integrated way to re-create data in your development database as often as needed, check out our [seeding guide](../../../guides/application-lifecycle/seed-database).

### Customizing migrations to prevent data loss

Sometimes, you need to modify a migration **before applying it** to ensure that existing data is preserved when you run the migration. This is the case if you, for example:

* Introduce a significant refactor, such as changing blog post tags from a `String[]` to a `Tag[]`
* [Rename a field](../../../guides/application-lifecycle/developing-with-prisma-migrate/advanced-migrate-scenarios#renaming-a-field) (by default, Prisma Migrate will drop the existing field)
* [Change the direction of a 1-1 relationship](/guides/application-lifecycle/developing-with-prisma-migrate/advanced-migrate-scenarios#changing-the-direction-of-a-1-1-rela)

The `--create-only` command allows you to create a migration without applying it:

```terminal
npx prisma migrate dev --create-only
```

To apply the edited migration, run `prisma migrate dev` again.

Refer to the [Advanced migrations](../../../guides/application-lifecycle/developing-with-prisma-migrate/advanced-migrate-scenarios) <span class="guide"></span> for examples.

### Team development

See: [Team development with Prisma Migrate](../../../guides/application-lifecycle/developing-with-prisma-migrate/team-development) <span class="guide"></span>.

## Production and testing environments

In production and testing environments, use the `migrate deploy` command to apply migrations:

```terminal
npx prisma migrate deploy
```

> **Note**: `migrate deploy` should generally be part of an automated CI/CD pipeline, and we do not recommend running this command locally to deploy changes to a production database (for example, by temporarily changing the `DATABASE_URL` environment variable). It is not generally considered good practice to store the production database URL locally.

This command:

1. Compares applied migrations against the migration history and **warns** if any migrations have been modified:

  ```bash
  WARNING The following migrations have been modified since they were applied:
  20210313140442_favorite_colors
  ```

1. Applies pending migrations

The `migrate deploy` command:

* **Does not** issue a warning if an already applied migration is _missing_ from migration history
* **Does not** detect drift (production database schema differs from migration history end state - for example, due to a hotfix
* **Does not** reset the database or generate artifacts (such as Prisma Client)
* **Does not** rely on a shadow database

See also:

* [Prisma Migrate in deployment](../../../guides/deployment/deployment#prisma-migrate) <span class="guide"></span>
* [Production troubleshooting](../../../guides/deployment/production-troubleshooting) <span class="guide"></span>

### Advisory locking

Prisma Migrate makes use of advisory locking when you run production commands like:

- `prisma migrate deploy`
- `prisma migrate resolve`

This safeguard ensures that multiple commands cannot run at the same time - for example, if you merge two pull requests in quick succession.

Advisory locking has a **10 second timeout** (not configurable), and uses the default advisory locking mechanism available in the underlying provider:

- [PostgreSQL](https://www.postgresql.org/docs/9.4/explicit-locking.html#ADVISORY-LOCKS)
- [MySQL](https://dev.mysql.com/doc/refman/5.7/en/locking-functions.html)
- [SQL server](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql?view=sql-server-ver15)

Prisma Migrate's implementation of advisory locking is purely to avoid catastrophic errors - if your command times out, you will need to run it again.

## Commands

See [Prisma Migrate CLI reference](../../../reference/api-reference/command-reference#prisma-migrate) <span class="api"></span> for all available Prisma Migrate commands.

<!-- ## FAQ

### When should I use <inlinecode>migrate deploy</inlinecode> and when should I use <inlinecode>migrate dev</inlinecode>? -->
