---
title: 'Null and undefined'
metaTitle: 'Null and undefined (Reference)'
metaDescription: 'How Prisma Client handles null and undefined, including a GraphQL use case.'
preview: false
---

<TopBlock>

Prisma Client differentiates between `null` and `undefined`:

- `null` is a **value**
- `undefined` means **do nothing**

> **Note**: This is particularly important to account for in [a **Prisma with GraphQL context**, where `null` and `undefined` are interchangeable](#use-case-null-and-undefined-in-a-graphql-resolver).

In the following example, if `emailInput` is `null`, the query sets `email` (a **mandatory** field) to `undefined` - which means ✔ **do not include this in the update**:

```ts
const update = await prisma.user.update({
  where: {
    id: 1,
  },
  data: {
    name: "Petunia",
|   email: emailInput != null ? emailInput : undefined, // If null, don't include in update!
  },
});

function getEmail() {
  const random = Math.floor(Math.random() * 10);

  if (random > 5) {
    return "ariadne@prisma.io"; // Could be null!
  }

  return null;
}
```

Setting a field value to `undefined` is the same as not including the `email` field in the `update` query **at all**:

```ts
const update = await prisma.user.update({
  where: {
    id: 1,
  },
  data: {
    name: "Petunia",
| // No email update here...
  },
});

function getEmail() {
  const random = Math.floor(Math.random() * 10);

  if (random > 5) {
    return "ariadne@prisma.io"; // Could be null!
  }

  return null;
}
```

By contrast, the following would ✘ **not work** as the mandatory `email` field cannot be `null`:

```ts
email: isValid(emailInput) ? emailInput : null, // email is a mandatory field!
```

> **Note**: TypeScript will give you an error in this scenario: `Type 'null' is not assignable to type 'string'. ts(2322)`

<details><summary>Expand for sample schema</summary>

```prisma
model User {
  email String  @unique
  id    Int     @default(autoincrement()) @id
  name  String?
  posts Post[]
}

model Post {
  id       String @default(cuid()) @id
  title    String
  authorId Int?
  views    Int?
  author   User?  @relation(fields: [authorId], references: [id])
}
```

</details>

</TopBlock>

## Use case: <inlinecode>null</inlinecode> and <inlinecode>undefined</inlinecode> in a GraphQL resolver

In the following example mutation that updates a user, both `authorEmail` and `name` accept `null` - from a GraphQL perspective, this means that fields are **optional**:

```ts
type Mutation {
  // Update author's email or name, or both - or neither!
  updateUser(id: Int!, authorEmail: String, authorName: String): User!
}
```

However, if you pass `null` values for `authorEmail` or `authorName` on to Prisma, the following will happen:

- If `args.authorEmail` is `null`, the query will **fail** - `email` does not accept `null` ✘
- If `args.authorName` is `null`, Prisma changes the value of `name` to `null` - this is probably not how you want an update to work ✘

```ts
updateUser: (parent, args, ctx: Context) => {
  return ctx.prisma.user.update({
    where: { id: Number(args.id) },
    data: {
|     email: args.authorEmail, // email cannot be null
|     name: args.authorName // name set to null - potentially unwanted behavior
     },
  })
},
```

Instead, set the value of `email` and `name` to `undefined` if the input value is `null`. Doing this is the same as not updating the field at all:

```ts
updateUser: (parent, args, ctx: Context) => {
  return ctx.prisma.user.update({
    where: { id: Number(args.id) },
    data: {
|     email: args.authorEmail != null ? args.authorEmail : undefined, // If null, do nothing
|     name: args.authorName != null ? args.authorName : undefined // If null, do nothing
     },
  })
},
```

## The effect of <inlinecode>NULL</inlinecode> on conditionals

There are some caveats to filtering with conditionals which might produce unexpected results. When filtering with conditionals you might expect one result but receive another given how Prisma treats `nullable` values.

### A high level overview


|Operator                     | 0 filters              | 1 filter               | n filters            |
|-----------------------------|------------------------|------------------------|----------------------|
|<inlinecode>OR</inlinecode>  | return empty list      | validate single filter | validate all filters |
|<inlinecode>AND</inlinecode> | return all items       | validate single filter | validate all filters |
|<inlinecode>NOT</inlinecode> | return all items       | validate single filter | validate all filters |


### <inlinecode>OR</inlinecode>

The `OR` operator states that one or more conditions must be true for the result to return any data. It is therefore logical to assume that using the `OR`
operator but supplying no filters, returns no results.

```js
prisma.myTable.findMany({
    where: {
        OR: [],
    },
});
```

When supplying the operator with a single filter, that filter will be run and it's results returned. If multiple filters are supplied then `n` results will be returned dependant on the filters supplied.

```js
// Single filter
prisma.myTable.findMany({
    where: {
        OR: [{name: 'Emelie'}],
    },
});

// Multiple filters
prisma.myTable.findMany({
    where: {
        OR: [{
          name: 'Emelie',
          drivesCar: true
        }],
    },
});
```

See the `OR` section in the [Prisma Client reference](../../../reference/api-reference/prisma-client-reference#or) for more information about the operator.

### <inlinecode>AND</inlinecode>

The `AND` operator expects all conditions to be true, that is, all filters must return something for it to return anything if it is to return data.
As stated above, Prisma treats `null` values as having a value, where as `undefined` means do nothing.
To that end if the `AND` operator is used but no filters are supplied then it will return all items requested in the query because providing no filter is like providing no condition,
which means that the query will return it's default data.

```js
// This is the same
prisma.myTable.findMany({
    where: {
        AND: [],
    },
});

// As this
prisma.myTable.findMany();
```

Prioviding a single filter to the `AND` operator works the same way as the `OR` condition except that the filter **must** return true for it to return the filtered data.
The same applies for multiple filters, where all filters must return true for the query to return any data.

```js
// Single filter
prisma.myTable.findMany({
    where: {
        AND: [
          {
            name: {
              contains: 'Emelie'
            },
          }
        ],
    },
});

// Multiple filters
prisma.myTable.findMany({
    where: {
        AND: [
          {
            name: {
              contains: 'Emelie'
            },
          },
          {
            drivesCar: {
              equals: true
            },
          }
        ],
    },
});
```

See the `AND` section in the [Prisma Client reference](../../../reference/api-reference/prisma-client-reference#and) for more information about the operator.

### <inlinecode>NOT</inlinecode>

The `NOT` operator expects that all conditions are false before it will return any data. Much like the `AND` operator, `NOT` will return the queries default data if no filters are passed.

```js
// This is the same
prisma.myTable.findMany({
    where: {
        NOT: [],
    },
});

// As this
prisma.myTable.findMany();
```

`NOT` is most often used in conjunction with other operators to form fluid conditions from which the data should be filtered through. Using all three conditional operators:

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        name: {
          contains: 'Emelie',
        },
      },
    ],
    AND: [
      {
        drivesCar: {
          equals: true
        },
      }
    ],
    NOT: {
      name: {
        contains: 'Mrs',
      },
    },
  },
})
```

See the `NOT` section in the [Prisma Client reference](../../../reference/api-reference/prisma-client-reference#not) for more information about the operator.
