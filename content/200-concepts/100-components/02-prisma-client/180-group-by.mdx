---
title: 'Group by'
metaTitle: 'Group by (Reference)'
metaDescription: 'Use Prisma Client to group rows that have the same values.'
preview: true
---

<TopBlock>

Prisma Client allows you to group records by one or more field values - such as `country`, or `country` and `city` - and perform aggregations on each group. The following example groups all users by the `country` field and returns the total number of profile views for each country:

<CodeWithResult expanded="{true}">
<Cmd>

```ts
const groupUsers = await prisma.user.groupBy({    
    by: ["country"],
    sum: {
        profileViews: true
    }
})
```
</Cmd>
<CmdResult>

```js
[
  { country: 'Germany', sum: { profileViews: 126 } },
  { country: 'Sweden', sum: { profileViews: 0 } },
]
```

</CmdResult>
</CodeWithResult>

`groupBy` is a preview feature. To enable this feature, add `"grupBy"` to the generator block in your schema as shown and run `prisma generate`:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["groupBy"]
}
```

</TopBlock>

## `groupBy` and filtering

`groupBy` supports two levels of filtering: `where` and `having`.

### Filter records with `where`

Use `where` to filter all records **before grouping**. The following example groups users by country and sums profile views, but only includes users where the email address contains `prisma.io`:

```ts
const groupUsers = await prisma.user.groupBy({
  by: ["country"],
|  where: {
|    email: {
|      contains: "prisma.io"
|    }
|  },
  sum: {
    profileViews: true
  }
})
```

### Filter groups with `having`

Use `having` to filter **entire groups** by an aggregate value such as the sum or average of a field, not individual records - for example, only return groups where the _average_ `profileViews` is greater than 100:

```ts
const groupUsers = await prisma.user.groupBy({
  by: ["country"],
  where: {
    email: {
      contains: "prisma.io"
    }
  },
  sum: {
    profileViews: true
  },
|  having: {
|    profileViews: {
|      avg: {
|        gt: 100
|      }
|    }
|  }
})
```

```js file=test.ts highlight=2;add|4;delete|6,7;edit|9-12;normal
async function main() {  
  added code 
 
  deleted code   
   
  edited 
  code 
   
  highlights 
  over multiple 
  lines can be done by using 
  a hyphen 
}    
``` 

Within `having`, you can only filter on the following:

* The aggregate value of any number field - for example, the `avg` or `sum` of profile views
* Any field provided in `by`

However, it is more succinct and 

```ts
const groupUsers = await prisma.user.groupBy({
  by: ["country"],
  where: {
|    country: {
|      not: "Sweden"
|    }
  },
  sum: {
    profileViews: true
  },
  having: {
|    country: {
|      not: "Ghana"
|    }
  }
})
```

```ts
  const fd = await prisma.user.groupBy({
    by: ["country"],
    where: {
|      country: {
|        notIn: ["Sweden", "Ghana"]
|      }
    },
    sum: {
      profileViews: true
    }
  })
```

## `groupBy` and ordering

The following constraints apply when you combine `groupBy` and `orderBy`:

* If you use `skip` and/or `take` with `groupBy`, you must also include `orderBy` in the query
* Any field included in `orderBy` must also be present in `by`

## Examples

The following examples are based on a sample schema:

<a  id="sample-model"></a>
 
<details>
  <summary>Expand sample schema</summary>

```prisma
generator client {
  provider             = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Post {
  id         Int     @default(autoincrement()) @id  
  authorId   Int?
  content    String?
  published  Boolean @default(false)
  title      String
  adEarnings Float? 
  user       User?   @relation(fields: [authorId], references: [id])  

  @@index([authorId], name: "authorId")
}

model User {
  id              Int     @default(autoincrement()) @id
  email           String  @unique  
  name            String?
  age             Int?
  profileViews    Int?
  role            Role    @default(USER)
  posts           Post[]  
}

enum Role {
  ADMIN
  USER
  MODERATOR
}
```

</details>


## Examples

### Group by a single field

### Group by multiple fields

### Group by with aggregation

### Group by with a `where` filter

### Group by with a `having` filter

## Generated types

The following types relating to aggregation are generated from the `User` model in the [sample schema](#sample-model) - aggregation types are generated for any `model` with number fields:

## FAQ

### Can I use `select` with `groupBy`?

You cannot use `select` with `groupBy`. However, all fields included in `by` are automatically returned.

### What is the difference between using `where` and `having` with `groupBy`?

`where` filers all records before grouping, and `having` filters entire groups.

### What is the difference between `groupBy` and `distinct`?

Both `distinct` and `groupBy` remove duplicate rows

* `groupBy` allows you to aggregate values within each group (for example, `max`)
* `distinct` allows you to `select` and `include` any additional fields you want - `groupBy` only returns aggregations (such as `max` or `avg`) and the fields specified in `by`