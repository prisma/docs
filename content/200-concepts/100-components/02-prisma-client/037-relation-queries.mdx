---
title: 'Relation queries'
metaTitle: 'Working with relations (Reference)'
metaDescription: 'Prisma Client provides convenient queries for working with relations, such as a fluent API, nested writes (transactions), nested reads and relation filters.'
tocDepth: 3
---

<TopBlock>

A key feature of Prisma Client is the ability to query [relations](../prisma-schema/relations) between two or more models. Relation queries include:

- [Nested reads](#nested-reads) (sometimes referred to as _eager loading_) via [`select`](../../../reference/api-reference/prisma-client-reference#select) <span class="api"></span> and [`include`](../../../reference/api-reference/prisma-client-reference#include) <span class="api"></span>
- [Nested writes](#nested-writes) with [transactional](transactions) guarantees
- [Filtering on related records](#relation-filters)

Prisma Client also has a [fluent API for traversing relations](#fluent-api).
</TopBlock>

## Nested reads

Use [`include`](../../../reference/api-reference/prisma-client-reference#include) <span class="api"></span> to include related records, such as a user's posts or profile, in the query response. This is known as a **nested read**. The following example returns a single user _and_ that user's posts:

<CodeWithResult>
<Cmd>

```ts highlight=5-7;normal
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  include: {
    posts: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 19,
  name: null,
  email: 'emma@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 20,
      title: 'My first post',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 21,
      title: 'How to make cookies',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

You can use [`select` to customize which relation fields to return](#select-specific-relation-fields). 

### Include all fields for a specific relation

The following example returns all posts with the word `cookie` in the `title` field and the author of each post. The result includes _all_ author fields.

<CodeWithResult>
<Cmd>

```ts
const getPosts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'cookies',
    },
  },
|   include: {
|    author: true, // Return all fields
|  },
})
```

</Cmd>
<CmdResult>

```js
;[
  {
    id: 17,
    title: 'How to make cookies',
    published: true,
    authorId: 16,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 16,
      name: null,
      email: 'orla@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
  {
    id: 21,
    title: 'How to make cookies',
    published: true,
    authorId: 19,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 19,
      name: null,
      email: 'emma@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
]
```

</CmdResult>
</CodeWithResult>

### Select specific relation fields

You can use a nested `select` to choose a subset of relation fields to return. For example, the following query returns the user's `name` and the `title` of each related post:

<CodeWithResult>
<Cmd>

```ts highlight=5,8-10;normal
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    name: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

</Cmd>
<CmdResult>

```js
{
  name: "Elsa",
  posts: [ { title: 'My first post' }, { title: 'How to make cookies' } ]
}
```

</CmdResult>
</CodeWithResult>

You can also nest a `select` inside an `include` - the following example returns **all* `User` fields and the `title` field of each post:

<CodeWithResult>
<Cmd>

```ts highlight=normal;8
const getUser = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  // select: { name: true } <-- Can't do this!
  include: {
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

</Cmd>
<CmdResult>

```js
{
  "id": 1,
  "name": null,
  "email": "martina@prisma.io",
  "profileViews": 0,
  "role": "USER",
  "coinflips": [],
  "posts": [
    {
      "title": "How to grow salad"
    },
    {
      "title": "How to ride a horse"
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

Note that you **cannot** use `select` and `include` _on the same level_. This means that if you choose to `include` a user's post and `select` each post's title, you cannot `select` only the users' `email`:

<CodeWithResult>
<Cmd>

```ts
// The follwing query returns an exception
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
|  select: { // This won't work!
    email:  true
  }
|   include: { // This won't work!
    posts: {
      select: {
        title: true
      }
    }
  },
})
```

</Cmd>
<CmdResult>

```
Invalid `prisma.user.findUnique()` invocation:

{
  where: {
    id: 19
  },
  select: {
  ~~~~~~
    email: true
  },
  include: {
  ~~~~~~~
    posts: {
      select: {
        title: true
      }
    }
  }
}


Please either use `include` or `select`, but not both at the same time.
```

</CmdResult>
</CodeWithResult>

Instead, use nested `select` options:

```ts
// The follwing query returns an exception
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: { // This won't work!
    email:  true,
    posts: {
      select: {
        title: true
      }
    }
  }
})
```

### Filter a list of relations

When you use `select` to return a subset of data from related records (for example, a user's posts), you can **filter and sort that list of relations**. For example, you might want to query all users with a `prisma.io` email address and select the titles of their published posts.

#### Return _all_ `User` records where `email` contains `prisma.io`, and select the `title` of all `Post` records that have not been published yet

```js highlight=9-14;normal
const result = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    posts: {
      where: {
        published: false,
      },
      orderBy: {
        title: "asc"
      },
      select: {
        title: true,
      },
    },
  },
})
```

You can use the `post` model property to write the same query:

```js
const result = await prisma.post.findMany({
  where: {
    published: false,
    User: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
  select: {
    title: true,
  },
})
```

## Nested writes

### Create a related record

You can create a record and one or more related records at the same time. The following query creates a `User` record and two related `Post` records:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [{ title: 'How to make an omelette' }, { title: 'How to eat an omelette' }],
    },
  },
  include: {
    posts: true, // Include all posts in the returned object
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 29,
  name: 'Elsa Prisma',
  email: 'elsa@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 22,
      title: 'How to make an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 23,
      title: 'How to eat an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

### Connect an existing record

The following query creates ([`create`](../../../reference/api-reference/prisma-client-reference#create) <span class="api"></span>) a new `User` record and connects that record (`connect` <span class="api"></span>) to three existing posts:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.create({
  data: {
    email: 'vlad@prisma.io',
    posts: {
      connect: [{ id: 8 }, { id: 9 }, { id: 10 }],
    },
  },
  include: {
    posts: true, // Include all posts in the returned object
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 27,
  name: null,
  email: 'vlad@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 10,
      title: 'An existing post',
      published: true,
      authorId: 27,
      comments: {},
      views: 0,
      likes: 0
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

> **Note**: Prisma Client throws an exception if any of the post records cannot be found: `connect: [{ id: 8 }, { id: 9 }, { id: 10 }]`

You can `connect` <span class="api"></span> an existing record to a new or existing user. The following query:

1. Connects an existing post (`id: 11`) to an existing user (`id: 9`)
2. Adds a new related post (`title: "My fist post title"`)

```ts
  const getUser = await prisma.user.update({
    where: {
      id: 9
    },
    data: {
      posts: {
|        connect: {
|          id: 11
|       },
        create: {
          title: "My new post title"
        }
      }
    }
  })
```

### Connect _or_ create a record

If a related record may or may not already exist, use `connectOrCreate` <span class="api"></span> to connect the related record:

- Connect a `User` with the email address `viola@prisma.io` _or_
- Create a new `User` with the email address `viola@prisma.io` if the user does not already exist

<CodeWithResult>
<Cmd>

```ts
  const createPost = await prisma.post.create({
      data: {
        title: "How to make croissants",
        author: {
          connectOrCreate: {
            where: {
              email: "viola@prisma.io"
            },
            create: {
              email: "viola@prisma.io",
              name: "Viola"
            }
          }
        }
      },
      include: {
        author: true
      }
  })
}
```

</Cmd>
<CmdResult>

```js
{
  id: 26,
  title: 'How to make croissants',
  published: true,
  authorId: 43,
  views: 0,
  likes: 0,
  author: {
    id: 43,
    name: 'Viola',
    email: 'viola@prisma.io',
    profileViews: 0,
    role: 'USER',
    coinflips: []
  }
}
```

</CmdResult>
</CodeWithResult>

### Disconnect a related record

To `disconnect` one out of a list of records (for example, a specific blog post) provide the ID or unique identifier of the record(s) to disconnect:

<CodeWithResult>
<Cmd>

```ts
  const updatePost = await prisma.user.update({
      where: {
        id: 16
      },
      data: {
        posts: {
          disconnect: {
            id: [ {12}, {19} ]
          }
        }
      },
      select: {
        posts: true
      }
  })
```

</Cmd>
<CmdResult>

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

</CmdResult>
</CodeWithResult>

To `disconnect` _one_ record (for example, a post's author), use `disconnect: true`:

<CodeWithResult>
<Cmd>

```ts
const updatePost = await prisma.post.update({
  where: {
    id: 23,
  },
  data: {
    author: {
      disconnect: true,
    },
  },
  include: {
    author: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 23,
  title: 'How to eat an omelette',
  published: true,
  authorId: null,
  comments: null,
  views: 0,
  likes: 0,
  author: null
}
```

</CmdResult>
</CodeWithResult>

### Disconnect all related records

To `disconnect` <span class="api"></span> _all_ related records in a one-to-many relation (a user has many posts), `set` the relation to an empty list as shown:

<CodeWithResult>
<Cmd>

```ts

  const updateUser = await prisma.user.update({
      where: {
        id: 16
      },
      data: {
        posts: {
|         set: []
        }
      },
      include: {
        posts: true
      }
  })
```

</Cmd>
<CmdResult>

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

</CmdResult>
</CodeWithResult>

### Delete all related records

Delete all related `Post` records:

```ts
const update = await prisma.user.update({
  where: {
    id: 11,
  },
  data: {
    posts: {
      deleteMany: {},
    },
  },
})
```

### Delete specific related records

Update a user by deleting all unpublished posts:

```ts
const update = await prisma.user.update({
  where: {
    id: 11,
  },
  data: {
    posts: {
      deleteMany: {
        published: false,
      },
    },
  },
})
```

Update a user by deleting specific posts:

```ts
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      deleteMany: [{ id: 7 }],
    },
  },
})
```

### Update all related records (or filter)

You can use a nested `updateMany` to update _all_ related records for a particular user. The following query unpublishes all posts for a specific user:

```ts
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: true,
        },
        data: {
          published: false,
        },
      },
    },
  },
})
```

### Update a specific related record

```ts
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      update: {
        where: {
          id: 9,
        },
        data: {
          title: 'My updated title',
        },
      },
    },
  },
})
```

### Update _or_ create a related record

```ts
const update = await prisma.post.update({
  where: {
    id: 6,
  },
  data: {
    author: {
      upsert: {
        create: {
          email: 'bob@prisma.io',
          name: 'Bob the New User',
        },
        update: {
          email: 'bob@prisma.io',
        },
      },
    },
  },
})
```

## Relation filters

### Filter records by relation fields

Prisma Client provides the `some`, `every`, and `none` options to filter records by the properties of _related_ records. For example:

| Requirement                                                                       | Query option to use                 |
| --------------------------------------------------------------------------------- | ----------------------------------- |
| "I want a list of every `User` that has _at least one_ unpublished `Post` record" | `some` posts are unpublished        |
| "I want a list of every `User` that has _no_ unpublished `Post` records"          | `none` of the posts are unpublished |
| "I want a list of every `User` that has _only_ unpublished `Post` records"        | `every` post is unpublished         |

#### Returns `User` that have no posts (`none`) with more than 100 views

```ts
  const users = await prisma.user.findMany({
    where: {
      posts: {
        none: {
          views: {
            gt: 100
          }
        }
      }
    },
  }
```

#### Return `User` records that only have posts (`every`) with more than 100 views

```ts
  const users = await prisma.user.findMany({
    where: {
      posts: {
        every: {
          views: {
            gt: 100
          }
        }
      }
    },
  }
```

## Fluent API

The fluent API lets you _fluently_ traverse the [relations](../prisma-schema/relations) of your models via function calls. Note that the _last_ function call determines the return type of the entire query (the respective type annotations are added in the code snippets below to make that explicit).

This query returns all `Post` records by a specific `User`:

```ts
const postsByUser: Post[] = await prisma.user
  .findUnique({ where: { email: 'alice@prisma.io' } })
  .posts()
```

Note that this call is equivalent to this Prisma Client query:

```ts
const postsByUser = await prisma.post.findMany({
  where: { author: { email: 'alice@prisma.io' } },
})
```

The main difference between the two is that the fluent API call is translated into two separate database queries while the other one only generates a single query (see this [GitHub issue](https://github.com/prisma/prisma/issues/1984)).

This request returns all categories by a specific post:

```ts
const categoriesOfPost: Category[] = await prisma.post.findUnique({ where: { id: 1 } }).categories()
```

Note that you can chain as many queries as you like. In this example, the chaining starts at `Profile` and goes over `User` to `Post`:

```ts
const posts: Post[] = await prisma.profile
    .findUnique({ where: { id: 1 } })
    .user()
    .posts()
}
```

The only requirement for chaining is that the previous function call must return only a _single object_ (e.g. as returned by a `findUnique` query or a "to-one relation" like `profile.user()`).

The following query is **not possible** because `findMany` does not return a single object but a _list_:

```ts
// This query is illegal
const posts = await prisma.user
    .findMany()
    .posts()
}
```
