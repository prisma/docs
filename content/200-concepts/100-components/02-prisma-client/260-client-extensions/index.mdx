---
title: 'Prisma Client extensions'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
preview: true
tocDepth: 3
---

<TopBlock>

<Admonition type="warning">

This page is in draft.

</Admonition>

Use Prisma Client extensions to add functionality to your models, result objects, queries, or to Prisma Client itself.

There are four types of extension. You can use each type to customize a different aspect of Prisma Client, as follows:

- `model` extensions: [add custom methods or fields to your models](/concepts/components/prisma-client/client-extensions/model)
- `client` extensions: [add client-level methods to Prisma Client](/concepts/components/prisma-client/client-extensions/client)
- `result` extensions (for future release): [add custom fields to your query results](/concepts/components/prisma-client/client-extensions/result)
- `query` extensions (for future release): [create custom Prisma Client queries](/concepts/components/prisma-client/client-extensions/query)

</TopBlock>

## About Prisma Client extensions

To use a Prisma Client extension, you must create an associated _extended client_. An extended client is a forked variant of the standard Prisma Client with an extension applied. The standard client does not change.

You can run an extension in its own isolated extended client, or combine it with other extensions in an extended client. [Learn more about multiple extensions](#multiple-extensions).

You can also [share your Prisma Client extensions](/concepts/components/prisma-client/client-extensions/shared-extensions) with other Prisma users, and [import Prisma Client extensions developed by other users](#install-a-packaged-extension) into your Prisma project.

### Client instances

Extended clients interact with each other, and with the standard client, as follows:

- Each extended client operates independently in an isolated instance.
- Extended clients cannot conflict with each other, or with the standard client.
- All extended clients and the standard client communicate with the same [Prisma query engine](/concepts/components/prisma-engines/query-engine).
- All extended clients and the standard client share the same connection pool.

### Example use cases for extended clients

Because extended clients operate in isolated instances, they are a good way to implement the following:

- Implement row-level security (RLS), where each HTTP request has its own client with its own RLS extension, customized with session data. This can keep each user entirely separate, each in a separate client.
- Add a `user.current()` method for the `User` model to get the currently logged-in user.
- Enable more verbose logging for requests if a debug cookie is set.
- Attach a unique request id to all logs so you can correlate them later.
- Remove a `delete` method from models unless the application calls the admin endpoint and the user has the necessary privileges.

## Prerequisites

Prisma Client extensions are available in Preview from version [4.7.0](https://github.com/prisma/prisma/releases/tag/4.7.0).

To use Prisma Client extensions, you must enable the `clientExtensions` preview feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create an extension

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an extended client. In your `$extends` structure, use the appropriate extension type or types (`model`, `client`, `result` or `query`). Write your extension logic in the `model`, `client`, `result` or `query` structure.

For example, the following code uses a [`model` extension](/concepts/components/prisma-client/client-extensions/model) to extend the `User` model.

```ts
const xprisma = prisma.$extends({
  name: `signUp`, // Optional: name appears in error logs
  model: {        // This is a `model` type extension
    user: { ... } // The extension logic goes inside the curly braces
  },
})
```

`name` is an optional field that you can use to name the extension. This name appears in error logs.

## Multiple extensions

When you create multiple extensions, there are two ways to associate them with extended clients:

- Create each extension in a separate extended client.
- Combine two or more extensions into one extended client. The functionality from these extensions applies in the same client instance.

  Note: [Combined extensions can conflict](#conflicts-in-combined-extensions).

You can combine the two approaches above. For example, you could have one extension in its own extended client and combine two other extensions into another extended client.

[Learn more about how client instances interact](#client-instances)

### Apply multiple extensions to one or more extended clients

In the following example, suppose that you have two extensions, `extensionA` and `extensionB`. There are two ways to combine these into a client.

First, declare the standard Prisma client as usual:

```ts
// First of all, store your original Prisma Client in a variable as usual
const prisma = new PrismaClient()
```

** Option 1: declare the new client in one line **

With this option, you apply both extensions to a new client in one line of code.

```ts
// Declare an extended client that has an extensionA and extensionB
const prismaAB = prisma.$extends(extensionA).$extends(extensionB)
```

You can refer to `prismaAB` in your code, for example `prismaAB.getName()`.

** Option 2: declare multiple extended clients **

The advantage of this option is that you can call any of the extended clients separately.

```ts
// Declare an extended client that has extensionA applied
const clientA = prisma.$extends(extensionA)

// Declare an extended client that has extension B applied
const clientB = prisma.$extends(extensionB)

// Declare an extended client that is a combination of clientA and clientB
const clientAplusB = clientA.$extends(extensionB)
```

In your code, you can call any of these clients separately, for example `clientA.getName()`, `clientB.getName()`, or `clientAplusB.getName()`.

### Conflicts in combined extensions

When you combine two or more extensions, then the _last_ extension that you declare takes precedence in any conflict. In the example in option 1 above, suppose there is a method called `getName()` in `clientA` and a method called `getName()` in `clientB`. When you call `clientAB.getName()`, then the client uses `getName()` as defined in `clientB`.

## Extensions versus middlewares

You can use either Client extensions or [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases) to hook into the query life-cycle and modify the incoming query or its result. However, the two differ from each other in the following ways:

- If you use two or more middlewares at the same time, then they all apply globally to the same client.
- Extensions are isolated: the functionality in each one is separate, unless you deliberately combine them.
  - For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.
- During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.

You can use Prisma Client extensions in all scenarios where middlewares can be used.

## Name an extension for error logs

You can name your extensions, to help identify them in error logs and tracing. To do so, use the optional field `name`. For example:

```ts
const xprisma = prisma.$extends({
  name: `signUp`,  // (Optional) Extension name
  model: {
    user: { ... }
 },
})
```
