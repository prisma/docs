---
title: 'Create custom Prisma Client queries'
metaTitle: 'Prisma Client extensions: query component (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
tocDepth: 3
---

<TopBlock>

From version 4.7.0, you can use `query` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) to create custom queries. You can use them to hook into the query life-cycle and modify an incoming query or its result.

You can use `query` extensions as an alternative to [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases). Unlike middlewares, `query` extensions give you [user isolation](/concepts/components/prisma-client/client-extensions#client-instances) and end-to-end type safety. [Learn more](#query-extensions-versus-middlewares).

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create custom queries

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an [extended client](/concepts/components/prisma-client/client-extensions#about-prisma-client-extensions). An extended client is a wrapped variant of the standard Prisma Client with an extension applied. Use the `query` extension component to create custom queries to a specific model in your schema or to all models in your schema.

To create a custom query, use the following structure:

```ts
const xprisma = prisma.$extends({
  name?: 'name',
  query?: {
    user: { ... } //in this case, we add a query to the `user` model
  },
});
```

The properties are as follows:

- `name`: an optional property that you can use to name the extension. This name appears in error logs.
- `query`: an optional property that defines a custom query.

### Add a custom query to a specific model

The `query` object contains functions that map to the names of the [Prisma Client operations](/docs/reference/api-reference/prisma-client-reference#model-queries), such as `findUnique`, `findFirst`, `findMany`, `count`, and `create`. The following example defines a custom query that finds users who are older than 18 years:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, action, args, data }) {
        // `where` can be `undefined`, so `args.where.age` might
        // fail. Therefore, we assign an object and backfill
        // the rest of the `where` clause:
        args.where = { age: { gt: 18 }, ...args.where }
        const users = await data
        return data
      },
    },
  },
})

await xprisma.user.findMany() // returns users whose age is greater than 18
```

** TBW: I need to understand what is going on in the where clause there, and how this relates to args **

In the above example, a call to `xprisma.user.findMany` triggers `query.user.findMany` on execution. Each callback receives a type-safe `{ model, operation, args, data }` object that describes the query. This object has the following properties:

- `model`: the name of the model whose query is being extended.

  In the above example, the `model` is a string of type `"User"`.

- `operation`: the name of the operation being extended and executed.

  In the above example, the `operation` is a string of type `"findMany"`.

  ** TBC: should this be `operation` or `action`? **

- `args`: the specific query input information to be extended.

  This is a type-safe object that you can mutate before the query happens. You can mutate any of the properties in `args`, except for `include` or `select`. You cannot mutate these properties because that would change the expected output type and break type safety.

- `data`: a result promise for the query that is being executed.

  ** TBD: wording of the above line**

  You can `await` and then mutate this promise, because its value is type-safe. TypeScript catches any unsafe mutations on the object. `await data` is equivalent to calling `next(...)` in a middleware. For a more natural way to write extensions, you can mutate `args` before `then` is triggered. `args` is fully type-safe, meaning that some properties are `readonly`, (for example `includes` and `select`).

### Add a custom query to all models in your schema

To extend all models in your schema, use `$allmodels` instead of a specific model name. For example:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations
        return data
      },
    },
  },
})
```

Note: Recursive wildcards cannot return values but can just modify the query itself.

** TBD - I need to understand the above better **

### Add a custom query to all operations in a model, or all operations in all models

You do not have to apply your custom query to a specific operation. You can apply it to the following:

- All operations in a model
- All operations in all models of your schema

To do so, use `$allOperations` instead of a specific operation name.

For example, the following code applies a custom query to all operations on the `user` model:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations
        return data
      },
    },
  },
})
```

To apply a custom query to all operations on all models:

```ts
const xprisma = prisma.$extends({
  query: {
    $allModels: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations
        return data
      },
    },
  },
})
```

## Query extensions versus middlewares

You can use query extensions or [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases) to hook into the query life-cycle and modify an incoming query or its result. Client extensions and middlewares differ in the following ways:

- Middlewares always apply globally to the same client. Client extensions are isolated, unless you deliberately combine them.
  - For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.
- During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.
- Extensions benefit from end-to-end type safety and inference, but middlewares don't.

You can use Prisma Client extensions in all scenarios where middlewares can be used.

### If you use query extensions and middlewares

If you use `query` extensions and middlewares in your project, then the following priorities apply:

- In your application code, you must declare all your middlewares on the main Prisma Client instance before you declare your query extensions.
- You cannot instantiate middlewares (with `$use`) in extended clients. You can only instantiate middlewares in the original client.
- In situations where middlewares and `query` extensions execute, Prisma Client executes the middlewares before it executes the `query` extensions. Prisma Client executes the individual middlewares and `query` extensions in the order in which you instantiated them with `$use` or `$extends`.
