---
title: 'Create custom Prisma Client queries'
metaTitle: 'Prisma Client extensions: query component (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
tocDepth: 3
---

<TopBlock>

From version 4.7.0, you can use the `query` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) component to hook into the query life-cycle and modify an incoming query or its result.

You can use the `query` extension component as an alternative to [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases). Unlike middlewares, the `query` extension component gives you [user isolation](/concepts/components/prisma-client/client-extensions#extended-clients) and end-to-end type safety. [Learn more](#query-extensions-versus-middlewares).

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create custom queries

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an [extended client](/concepts/components/prisma-client/client-extensions#about-prisma-client-extensions). An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions.

Use the `query` extension component to create custom queries. You can add a custom query to the following:

- [A specific operation in a specific model of your schema](#add-a-custom-query-to-a-specific-operation-in-a-specific-model)
- [A specific operation in all models of your schema](#add-a-custom-query-to-a-specific-operation-in-all-models-of-your-schema)
- [All operations in a specific model of your schema](#add-a-custom-query-to-all-operations-in-a-specific-model)
- [All operations in all models of your schema](#add-a-custom-query-to-all-operations-in-all-models-of-your-schema)

To create a custom query, use the following structure:

```ts
const xprisma = prisma.$extends({
  name?: 'name',
  query?: {
    user: { ... } //in this case, we add a query to the `user` model
  },
});
```

The properties are as follows:

- `name`: (optional) specifies a name for the extension that appears in error logs.
- `query`: (optional) defines a custom query.

### Add a custom query to a specific operation in a specific model

The `query` object contains functions that map to the names of the [Prisma Client operations](/docs/reference/api-reference/prisma-client-reference#model-queries), such as `findUnique`, `findFirst`, `findMany`, `count`, and `create`. The following example defines a custom query that finds users who are older than 18 years:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, operation, args, data }) {
        // `where` can be `undefined`, so `args.where.age` might
        // fail. To work around this, we assign an object and
        // backfill the rest of the `where` clause:
        args.where = { age: { gt: 18 }, ...args.where }
        const users = await data
        return data
      },
    },
  },
})

await xprisma.user.findMany() // returns users whose age is greater than 18
```

In the above example, a call to `xprisma.user.findMany` triggers `query.user.findMany`. Each callback receives a type-safe `{ model, operation, args, data }` object that describes the query. This object has the following properties:

- `model`: the name of the containing model for the query that we want to extend.

  In the above example, the `model` is a string of type `"User"`.

- `operation`: the name of the operation being extended and executed.

  In the above example, the `operation` is a string of type `"findMany"`.

- `args`: the specific query input information to be extended.

  This is a type-safe object that you can mutate before the query happens. You can mutate any of the properties in `args`. Exception: you cannot mutate `include` or `select` because that would change the expected output type and break type safety.

- `data`: a promise for the result of the query.

  - You can use `await` and then mutate the result of this promise, because its value is type-safe. TypeScript catches any unsafe mutations on the object.
  - `await data` is equivalent to calling `next(...)` in a middleware.

### Add a custom query to a specific operation in all models of your schema

To extend all models in your schema, use `$allmodels` instead of a specific model name. For example:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, operation, args, data }) {
        // `where` can be `undefined`, so `args.where.age` might
        // fail. To work around this, we assign an object and
        // backfill the rest of the `where` clause:
        args.where = { age: { gt: 18 }, ...args.where }
        const users = await data
        return data
      },
    },
  },
})
```

### Add a custom query to all operations in a specific model

Use `$allOperations` to apply your custome query to all operations, instead of to a specific operation name.

For example, the following code applies a custom query to all operations on the `user` model:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations
        return data
      },
    },
  },
})
```

### Add a custom query to all operations in all models of your schema

Use `$allOperations` to apply your custome query to all operations, instead of to a specific operation name.

To apply a custom query to all operations on all models of your schema:

```ts
const xprisma = prisma.$extends({
  query: {
    $allModels: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations
        return data
      },
    },
  },
})
```

## Query extensions versus middlewares

You can use query extensions or [middlewares](/concepts/components/prisma-client/middleware#performance-and-appropriate-use-cases) to hook into the query life-cycle and modify an incoming query or its result. Client extensions and middlewares differ in the following ways:

- Middlewares always apply globally to the same client. Client extensions are isolated, unless you deliberately combine them. [Learn more about client extensions](/concepts/components/prisma-client/client-extensions#about-prisma-client-extensions).
  - For example, in a row-level security (RLS) scenario, you can keep each user in an entirely separate client. With middlewares, all users are active in the same client.
- During application execution, with extensions you can choose from one or more extended clients, or the standard Prisma Client. With middlewares, you cannot choose which client to use, because there is only one global client.
- Extensions benefit from end-to-end type safety and inference, but middlewares don't.

You can use Prisma Client extensions in all scenarios where middlewares can be used.

### If you use the <inlinecode>query</inlinecode> extension component and middlewares

If you use the `query` extension component and middlewares in your project, then the following priorities apply:

- In your application code, you must declare all your middlewares on the main Prisma Client instance before you declare your extensions that use the `query` component.
- You cannot instantiate middlewares (with `$use`) in extended clients. You can only instantiate middlewares in the original client.
- In situations where middlewares and extensions with a `query` component execute, Prisma Client executes the middlewares before it executes the extensions with the `query` component. Prisma Client executes the individual middlewares and extensions in the order in which you instantiated them with `$use` or `$extends`.
