---
title: 'Add custom methods to your models'
metaTitle: 'Prisma Client extensions: model component (Preview)'
metaDescription: 'Extend the functionality of Prisma Client, model component'
tocDepth: 3
---

<TopBlock>

You can use the `model` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) component type to add custom methods to your models. We introduced this feature in version 4.7.0.

Possible uses for the `model` component include the following:

- New operations to operate alongside existing Prisma Client operations, such as `findMany`
- Encapsulated business logic
- Repetitive operations
- Model-specific utilities

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Add a custom method

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions. Use the `model` extension component to add methods to models in your schema.

### Add a custom method to a specific model

To extend a specific model in your schema, use the following structure. This example adds a method to the `user` model.

```ts
const xprisma = prisma.$extends({
  name?: '<name>',  // (optional) names the extension for error logs
  model?: {
    user: { ... }   // in this case, we extend the `user` model
  },
});
```

#### Example

The following example adds a method called `signUp` to the `user` model. This method creates a new user with the specified email address.

```ts
const xprisma = prisma.$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create({ data: { email } })
      },
    },
  },
})
```

You would call `signUp` in your application as follows:

```ts
const user = await xprisma.user.signUp('john@prisma.io')
```

When you call a method in an extension, use the constant name from your `$extends` statement, not `prisma`. In the above example, `xprisma.user.signUp` works, but `prisma.user.signUp` does not, because the original `prisma` is not modified.

### Add a custom method to all models in your schema

To extend _all_ models in your schema, use the following structure:

```ts
const xprisma = prisma.$extends({
  name?: '<name>', // `name` is an optional field that you can use to name the extension for error logs
  model?: {
    $allModels: { ... }
  },
})
```

#### Example

The following example adds a `validate` method to all models.

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      validate(data: unknown) {
        /* Generic validation logic */
      },
    },
  },
})
```

You would call `validate` in your application as follows:

```ts
// `validate` method available on all models
xprisma.user.validate(someData)
xprisma.post.validate(someData)
```

## Call a custom method from another custom method

You can call a custom method from another custom method, if the two methods are declared on the same model. For example, you can call a custom method on the `user` model from another custom method on the `user` model. It does not matter if the two methods are declared in the same extension or in different extensions.

To do so, use `Prisma.getExtensionContext(this).methodName`. Note that you cannot use `prisma.user.methodName`. This is because `prisma` is not extended yet, and therefore does not contain the new method.

For example:

```ts
prisma.$extends({
  model: {
    user: {

      firstMethod() {
        ...
      }

      secondMethod() {
          Prisma.getExtensionContext(this).firstMethod()
      }
    }
  }
})
```

You cannot use `Prisma.getExtensionContext(this)` inside an [`$allModels`](#add-a-custom-method-to-all-models-in-your-schema) structure.

## Advanced type safety on model components

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

**Rewrite this intro on Monday:** To help with type safety, Prisma provides code validation for the internal types in generic models. It is especially useful for published extensions, because other users can more easily benefit from autocompletion, no matter what models apply. **TBA:** link to "sharing extensions" section; also link here from that section, but make it clear in the link text that this is an advanced topic

The following type utilities are available:

- `Exact<X, Y>`: Assists with enforcing strict type safety on an input `X`. `Exact` makes sure that a generic type `X` strictly complies by `Y` while [narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) `X` down to the most precise types.
- `Args<T, O>`: Retrieves the input arguments for any given model `T` and a given operation `O` . This is particularly useful for extension authors wanting to re-use existing input types to extend them and modify them, and also benefit from the same auto-completion experience as on existing operations.
- `Result<T, A, O>`: Takes the input args `A` and provides the result for a given model `T` and a given operation `O`. In most cases, it is to be used in conjunction with `Args`. Similarly, this will allow you to re-use existing output types to extend them or modify them.
- `Payload<T, O>`: Retrieves the entire structure of the result, as scalars and relations objects for a given model `T` and a given operation `O`. It can be useful, for instance, to know which keys are scalars or objects on a type level.

- **TBA:** some more code comments to annotate the following example, especially in the $query section

```ts
const prisma = new PrismaClient()

const xprisma = prisma.$extends({
  model: {
    $allModels: {
      customCall<T, A>(
        // On the following line, `this` and `T` refer to a generic model,
        // which is a placeholder for the model that is in use.
        // For example, `this` might be the value of `prisma.user`.
        this: T,
        x: Prisma.Exact<
          A,
          Prisma.Args<T, 'findFirst'> & { customProperty: boolean }
        >
        // We get the correct result types for a given model
        // of type `T`, arguments of type `A` for `findFirst`
      ): Prisma.Result<T, A, 'findFirst'> {
        // ctx refers to the current model
        const ctx = Prisma.getExtensionContext(this)

        // ctx.name returns the name of the current method
        console.log(ctx.name)

        return {} as any // TODO
      },
    },
  },
  query: {
    $allModels: {
      findUnique(operation) {
        const { __internalParams, query, args } = operation as any as {
          query: (...args: any[]) => Promise<any>
          __internalParams: any
          args: any
        }

        __internalParams.headers = {
          ...__internalParams.headers,
          'x-custom-header': 'hello',
        }

        return query(args, __internalParams)
      },
    },
  },
})

async function main() {
  const test0 = xprisma.link.customCall({
    cache: true,
    select: {
      id: true,
    },
  })
}
```

## Get the current model name at runtime

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

You can get the name of the current model at runtime with `Prisma.getExtensionContext(this).name`. You can use this to write out the model name to a log, to send the name to another service, or even to branch your code based on the method. **TBD: ** I'm not sure we need to mention all of these

For example:

```ts
// `ctx` refers to the current model
const ctx = Prisma.getExtensionContext(this)

// `ctx.name` returns the name of the current method
console.log(ctx.name)
```

**TBA:**

- short code example - e.g. showing `ctx.name` to give you the method name
- crosslink between this and other `getExtensionContext` mention/s
- **question for Pierre** - in our docs [here](https://www.prisma.io/docs/concepts/components/prisma-client/client-extensions/model#call-a-custom-method-from-another-custom-method) we say that you cannot use `getExtension(this)` inside an `$AllModels` structure. Is that still true for `Prisma.getExtensionContext(this).methodName`?
  - If not, we can remove the note.
  - If so, we need to update the note to make it specifically about `methodName`.
- I'm not sure that this section should go here - rethink on Monday, when my mind is less fried
