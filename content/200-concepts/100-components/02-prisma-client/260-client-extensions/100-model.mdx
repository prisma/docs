---
title: 'Add custom methods to your models'
metaTitle: 'Prisma Client extensions: model component (Preview)'
metaDescription: 'Extend the functionality of Prisma Client, model component'
tocDepth: 3
---

<TopBlock>

You can use the `model` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) component type to add custom methods to your models. We introduced this feature in version 4.7.0.

Possible uses for the `model` component include the following:

- New operations to operate alongside existing Prisma Client operations, such as `findMany`
- Encapsulated business logic
- Repetitive operations
- Model-specific utilities

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Add a custom method

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions. Use the `model` extension component to add methods to models in your schema.

### Add a custom method to a specific model

To extend a specific model in your schema, use the following structure. This example adds a method to the `user` model.

```ts
const xprisma = prisma.$extends({
  name?: '<name>',  // (optional) names the extension for error logs
  model?: {
    user: { ... }   // in this case, we extend the `user` model
  },
});
```

#### Example

The following example adds a method called `signUp` to the `user` model. This method creates a new user with the specified email address.

```ts
const xprisma = prisma.$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create({ data: { email } })
      },
    },
  },
})
```

You would call `signUp` in your application as follows:

```ts
const user = await xprisma.user.signUp('john@prisma.io')
```

When you call a method in an extension, use the constant name from your `$extends` statement, not `prisma`. In the above example, `xprisma.user.signUp` works, but `prisma.user.signUp` does not, because the original `prisma` is not modified.

### Add a custom method to all models in your schema

To extend _all_ models in your schema, use the following structure:

```ts
const xprisma = prisma.$extends({
  name?: '<name>', // `name` is an optional field that you can use to name the extension for error logs
  model?: {
    $allModels: { ... }
  },
})
```

#### Example

The following example adds a `validate` method to all models.

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      validate(data: unknown) {
        /* Generic validation logic */
      },
    },
  },
})
```

You would call `validate` in your application as follows:

```ts
// `validate` method available on all models
xprisma.user.validate(someData)
xprisma.post.validate(someData)
```

## Call a custom method from another custom method

You can call a custom method from another custom method, if the two methods are declared on the same model. For example, you can call a custom method on the `user` model from another custom method on the `user` model. It does not matter if the two methods are declared in the same extension or in different extensions.

To do so, use `Prisma.getExtensionContext(this).methodName`. Note that you cannot use `prisma.user.methodName`. This is because `prisma` is not extended yet, and therefore does not contain the new method.

For example:

```ts
prisma.$extends({
  model: {
    user: {

      firstMethod() {
        ...
      }

      secondMethod() {
          Prisma.getExtensionContext(this).firstMethod()
      }
    }
  }
})
```

## Get the current model name at runtime

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

You can get the name of the current model at runtime with `Prisma.getExtensionContext(this).name`. You might use this to write out the model name to a log, to send the name to another service, or to branch your code based on the model.

For example:

```ts
// `ctx` refers to the current model
const ctx = Prisma.getExtensionContext(this)

// `ctx.name` returns the name of the current model
console.log(ctx.name)
```

## Advanced type safety: improve the type safety and developer experience of your extensions

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

To help you create highly type-safe extensions, Prisma Client provides a set of type utilities that tap into input and output types. They are fully dynamic, which means that they adapt to any given model and schema. You can use them to imrpove the auto-completion and developer exprience in your [shared extensions](/concepts/components/prisma-client/client-extensions/shared-extensions).

The following type utilities are available in Prisma Client:

- `Exact<X, Y>`: Enforces strict type safety on input `X`. `Exact` makes sure that a generic type `X` strictly complies with the type that you specify in `Y`. It [narrows](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) `X` down to the most precise types.
- `Args<T, O>`: Retrieves the input arguments for any given model `T` and a given operation `O` . This is particularly useful for extension authors who want to do the following:
  - Re-use existing types to extend or modify them.
  - Benefit from the same auto-completion experience as on existing operations.
- `Result<T, A, O>`: Takes the input args `A` and provides the result for a given model `T` and a given operation `O`. You would usually use this in conjunction with `Args`. As with `Args`, `Result` helps you to re-use existing types to extend or modify them.
- `Payload<T, O>`: Retrieves the entire structure of the result, as scalars and relations objects for a given model `T` and a given operation `O`. For example, you can use this to determine which keys are scalars or objects at a type level.

In the following example... **[intro to be written]**
So we

example details

- introduce customCall - this is a generic customCall -> generic type T - corresponds to the model in use - generic type A - corresponds to the arugment for the operation - T and A are bound togeher in customcall - if T changes, A will be bound to T - A varies with T.

this: T - says this type is bound to T
what this does - when you example model A or B, T will be inferred to the type of the model
we now have the model on the type level

the model has type level information
you can retrieve the arguments for a given model and a given operation

x: Prisma.Exact ->
use Prisma.Args - pass T -type value of model
We want the args for this model and operation and FindFirst
we take these args - add customProperyy that is type boolean

user in fucntion ain can pass usual args or pass a customProperty

if findFirst doesn't exist, you'd get an unknown type - so the onus is on the user - there's a strict list - you get type checks on that so it's hard to get it wrong - not worth mentioning in doc

Prisma.Args - not enough
need to check the user input strictly matches the customCall
we can narrow the types
we use Exact - so we have the srictest types

If you want to re-use the result - have similar construct -> Prisma.Result
T is the model in use
A is the args just passed
Result - computes the result for a given operation - e.g. select id:true

```ts
const prisma = new PrismaClient()

const xprisma = prisma.$extends({
  model: {
    $allModels: {
      customCall<T, A>(
        // On the following line, `this` and `T` refer to a generic model,
        // which is a placeholder for the model that is in use.
        // For example, `this` might have the value `prisma.user`.
        this: T,
        x: Prisma.Exact<
          A,
          Prisma.Args<T, 'findFirst'> & { customProperty: boolean }
        >
        // We get the correct result types for a given model
        // of type `T`, arguments of type `A` for `findFirst`
      ): Prisma.Result<T, A, 'findFirst'> {
        // ctx refers to the current model
        const ctx = Prisma.getExtensionContext(this)

        // ctx.name returns the name of the current model
        console.log(ctx.name)

        // ovverride TypeScript type safety, because we cannot
        // predict the result types in advance
        return {} as any
      },
    },
  },
})

async function main() {
  const test0 = xprisma.link.customCall({
    customProperty: true,
    select: {
      id: true,
    },
  })
}
```
