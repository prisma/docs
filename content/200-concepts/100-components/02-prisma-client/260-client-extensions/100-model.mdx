---
title: 'Add custom methods to your models'
metaTitle: 'Prisma Client extensions: model component (Preview)'
metaDescription: 'Extend the functionality of Prisma Client, model component'
tocDepth: 3
---

<TopBlock>

You can use the `model` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) component type to add custom methods to your models. We introduced this feature in version 4.7.0.

Possible uses for the `model` component include the following:

- New operations to operate alongside existing Prisma Client operations, such as `findMany`
- Encapsulated business logic
- Repetitive operations
- Model-specific utilities

</TopBlock>

## Enable the preview feature

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the `generator` block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Add a custom method

Use the `$extends` [client-level method](/reference/api-reference/prisma-client-reference#client-methods) to create an _extended client_. An extended client is a variant of the standard Prisma Client that is wrapped by one or more extensions. Use the `model` extension component to add methods to models in your schema.

### Add a custom method to a specific model

To extend a specific model in your schema, use the following structure. This example adds a method to the `user` model.

```ts
const xprisma = prisma.$extends({
  name?: '<name>',  // (optional) names the extension for error logs
  model?: {
    user: { ... }   // in this case, we extend the `user` model
  },
});
```

#### Example

The following example adds a method called `signUp` to the `user` model. This method creates a new user with the specified email address.

```ts
const xprisma = prisma.$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create({ data: { email } })
      },
    },
  },
})
```

You would call `signUp` in your application as follows:

```ts
const user = await xprisma.user.signUp('john@prisma.io')
```

When you call a method in an extension, use the constant name from your `$extends` statement, not `prisma`. In the above example, `xprisma.user.signUp` works, but `prisma.user.signUp` does not, because the original `prisma` is not modified.

### Add a custom method to all models in your schema

To extend _all_ models in your schema, use the following structure:

```ts
const xprisma = prisma.$extends({
  name?: '<name>', // `name` is an optional field that you can use to name the extension for error logs
  model?: {
    $allModels: { ... }
  },
})
```

#### Example

The following example adds a `validate` method to all models.

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      validate(data: unknown) {
        /* Generic validation logic */
      },
    },
  },
})
```

You would call `validate` in your application as follows:

```ts
// `validate` method available on all models
xprisma.user.validate(someData)
xprisma.post.validate(someData)
```

## Call a custom method from another custom method

You can call a custom method from another custom method, if the two methods are declared on the same model. For example, you can call a custom method on the `user` model from another custom method on the `user` model. It does not matter if the two methods are declared in the same extension or in different extensions.

To do so, use `Prisma.getExtensionContext(this).methodName`. Note that you cannot use `prisma.user.methodName`. This is because `prisma` is not extended yet, and therefore does not contain the new method.

For example:

```ts
prisma.$extends({
  model: {
    user: {

      firstMethod() {
        ...
      }

      secondMethod() {
          Prisma.getExtensionContext(this).firstMethod()
      }
    }
  }
})
```

## Get the current model name at runtime

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

You can get the name of the current model at runtime with `Prisma.getExtensionContext(this).name`. You might use this to write out the model name to a log, to send the name to another service, or to branch your code based on the model.

For example:

```ts
// `ctx` refers to the current model
const ctx = Prisma.getExtensionContext(this)

// `ctx.name` returns the name of the current model
console.log(ctx.name)
```

## Advanced type safety on model components

<Admonition type = "info">

This feature is available from version 4.9.0.

</Admonition>

To help you create highly type-safe extensions, Prisma Client provides a set of type utilities that tap into input and output types. They are fully dynamic, which means that they adapt to any given model and schema and help you deliver a great auto-completion and developer experience for your [shared extensions](/concepts/components/prisma-client/client-extensions/shared-extensions).

The following type utilities are available:

- `Exact<X, Y>`: Enforces strict type safety on input `X`. `Exact` makes sure that a generic type `X` strictly complies with the type that you specify in `Y`. It [narrows](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) `X` down to the most precise types.
- `Args<T, O>`: Retrieves the input arguments for any given model `T` and a given operation `O` . This is particularly useful for extension authors who want to do the following:
  - Re-use existing types to extend or modify them.
  - Benefit from the same auto-completion experience as on existing operations.
- `Result<T, A, O>`: Takes the input args `A` and provides the result for a given model `T` and a given operation `O`. You would usually use this in conjunction with `Args`. As with `Args`, `Result` helps you to re-use existing types to extend or modify them.
- `Payload<T, O>`: Retrieves the entire structure of the result, as scalars and relations objects for a given model `T` and a given operation `O`. It can be useful, for instance, to know which keys are scalars or objects at a type level.

```ts
const prisma = new PrismaClient()

const xprisma = prisma.$extends({
  model: {
    $allModels: {
      customCall<T, A>(
        // On the following line, `this` and `T` refer to a generic model,
        // which is a placeholder for the model that is in use.
        // For example, `this` might be the value of `prisma.user`.
        this: T,
        x: Prisma.Exact<
          A,
          Prisma.Args<T, 'findFirst'> & { customProperty: boolean }
        >
        // We get the correct result types for a given model
        // of type `T`, arguments of type `A` for `findFirst`
      ): Prisma.Result<T, A, 'findFirst'> {
        // ctx refers to the current model
        const ctx = Prisma.getExtensionContext(this)

        // ctx.name returns the name of the current method
        console.log(ctx.name)

        return {} as any // TODO
      },
    },
  },
})

async function main() {
  const test0 = xprisma.link.customCall({
    customProperty: true,
    select: {
      id: true,
    },
  })
}
```
