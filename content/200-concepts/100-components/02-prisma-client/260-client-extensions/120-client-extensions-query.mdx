---
title: 'Create custom Prisma Client queries (Prisma Client extensions)'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
tocDepth: 3
---

<TopBlock>

<Admonition type="warning">

** IMPORTANT: `query` extensions are not currently available. This page is a draft doc for a feature that we plan to release in a future Prisma version. **

</Admonition>

From version **TBD**, you can use `query` [Prisma Client extensions](/concepts/components/prisma-client/2client-extensions) to create custom Prisma Client queries. These custom queries return type-safe data and, like all Prisma Client extensions, [run in isolated instances](/concepts/components/prisma-client/client-extensions#multiple-extensions).

</TopBlock>

## Add the <inlinecode>clientExtensions</inlinecode> feature flag to <inlinecode>schema.prisma</inlinecode>

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the generator block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create custom queries

To create Prisma Client extensions, use the [`$extends`](/concepts/components/prisma-client/client-extensions#about-prisma-client-extensions) client-level method. To extend queries, use the `query` extension type.

The following example queries the database to find users older than 18 years:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, action, args, data }) {
        args.where.age = { gt: 18 }
        const myData = await data
        return data
      },
    },
  },
})

await xprisma.user.findMany() // returns users whose age is greater than 18
```

The `query` object contains functions that map to the names of the [Prisma Client operations](/docs/reference/api-reference/prisma-client-reference#model-queries), such as `findUnique`, `findFirst`, `findMany`, `count`, and `create`.

In the above example, a call to `xprisma.user.findMany` triggers `query.findMany` on execution. Each callback receives a type-safe `{ model, operation, args, data }` object that describes a query as follows:

- `model`: the property name of the model whose query is being extended.

  In the above example, the `model` is a string of type `"User"`.

- `operation`: the property name of the operation being extended and executed.

  In the above example, the `o`peration would be a string of type `"findMany"`.

- `args`: the property that carries the specific query input information to be extended.

  This is a type-safe object that is meant to be mutated before the query happens. You can mutate any of the properties in `args`, except for `include` or `select`, because that would change the expected output type in such a way that it breaks type safety.

- `data`: the property that is a promise of the result of the query that is being executed.

  You can `await` and then mutate this promise, because its value is also type-safe. TypeScript catches any unsafe mutations on that object. Doing `await data` is equivalent to calling `next(...)` in a middleware. You are free to mutate `args` before `then` is triggered, which leads to a more natural way of writing such extensions. `args` is fully type-safe, meaning that some properties are `readonly`, (like `includes` or `select`).

### Nested queries

This is a declarative interface for hooking and extending queries, so you can also handle nested queries. `query` accepts wildcard operations to handle any levels of nesting.

The following hooks map to operation properties from Prisma Client operations to execute:
** !!! clarify the above !!! **

- `connect` / `connectOrCreate`
- `create` / `createMany`
- `delete` / `deleteMany`
- `select` / `include`
- `disconnect`
- `set`
- `update` / `updateMany`
- `upsert`
- `where`

These are not real operations, but are parts of a query that can be deeply nested or even applied with another model, such as with a relation query.

You can handle nested operations with the `$nestedOperations` option. You can recursively traverse the arguments of a given operation, as follows:

** !!! TBA: we need more detail here **

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $nestedOperations: {
        where({ model, operation, args, data, path }) {
          // path here could be `user.findFirst`

          args.where.age = { gt: 18 }
        },
      },
    },
  },
})
```

** !!! To be clarified **

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      create({ model, operation, args, data, path }) {
        // handle all prisma.user.create

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, path }) {
          // handle nested create for user
        },
      },
    },
  },
})
```

- `$nestedOperations`: an optional property that handles deeply nested operations.
- `path`: a property that describes the nesting level of such an operation.

## Add a custom query to all models in your schema

To extend all models in your schema, use `$allmodels` instead of a specific model name.

For example:

```ts
const xprisma = prisma.$extends({
  query: {
    $allModels: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, data, path }) {
          // handle nested operations

          return data
        },
      },
    },
  },
})
```

Note: Recursive wildcards cannot return values but can just modify the query itself.

- `$allModels`: an optional property that handles all models in a single extension.
- `$allOperations`: an optional property that handles all operations for a given model.
- `$nestedOperations`: an optional property that handles specific nested operations.
