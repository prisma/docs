---
title: 'CRUD'
metaTitle: 'CRUD (Reference)'
metaDescription: 'This page provides a detailed reference of the auto-generated CRUD queries that are exposed in the Prisma Client API, such as findUnique, findMany, create, ...'
tocDepth: 3
---

<TopBlock>

This page describes how to perform CRUD operations with your generated Prisma Client API. CRUD is an acronym that stands for:

- [Create](#create)
- [Read](#read)
- [Update](#update)
- [Delete](#delete)

Paginate, aggregate, sort, and work with transactions.

</TopBlock>

## Example schema

All examples are based on the following schema:

<details><summary>Expand for sample schema</summary>

```prisma file=schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ExtendedProfile {
  id        Int    @id @default(autoincrement())
  biography String
  user      User   @relation(fields: userId, references: id)
  userId    Int
}

model User {
  id           Int             @id @default(autoincrement())
  name         String?
  email        String          @unique
  profileViews Int             @default(0)
  role         Role            @default(USER)
  coinflips    Boolean[]
  posts        Post[]
  profile      ExtendedProfile?
}

model Post {
  id         Int        @id @default(autoincrement())
  title      String
  published  Boolean    @default(true)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  comments   Json?
  views      Int        @default(0)
  likes      Int        @default(0)
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}

enum Role {
  USER
  ADMIN
}
```

</details>

Use the `db push` command to push the example schema to your own database:

```terminal
npx prisma db push --preview-feature
```

## Create

### Create a single record

The following query creates ([`create`](../../../reference/api-reference/prisma-client-reference#create) <span class="api"></span>) a single user with two fields:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 22,
  name: 'Elsa Prisma',
  email: 'elsa@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: []
}
```

</CmdResult>
</CodeWithResult>

Your schema determines [which fields are mandatory](../prisma-schema/data-model#optional-and-mandatory-fields).

#### Create a single record using generated types

The following example produces an identical result, but creates a `UserCreateInput` variable named `user` _outside_ the context of the `create` query. After completing a simple check (should posts be included in this `create` query?), the `user` variable is passed into the query:

```ts
import { PrismaClient, Prisma } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  let includePosts: boolean = false
  let user: Prisma.UserCreateInput

  // Check if posts should be included in the query
  if (includePosts) {
    user = {
      email: 'elsa@prisma.io',
      name: 'Elsa Prisma',
      posts: {
        create: {
          title: 'Include this post!',
        },
      },
    }
  }
  {
    user = {
      email: 'elsa@prisma.io',
      name: 'Elsa Prisma',
    }
  }

  // Pass 'user' object into query
  const createUser = await prisma.user.create({ data: user })
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

For more information about working with generated types, see: [Generated types](working-with-generated-types).

### Create multiple records

Prisma Client does not yet support batching at a database level.  The following example does create two `User` records - however, this will result in two separate `INSERT` queries. Follow [GitHub issue #332](https://github.com/prisma/prisma-client-js/issues/332) for information about bulk inserts.

<CodeWithResult expanded="{true}">
<Cmd>

```ts
import { PrismaClient, UserCreateInput } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  // Create input for two new users
  let users: UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  // Prepare and execute all queries
  await Promise.all(
    users.map(async user => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .catch(e => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</Cmd>
<CmdResult>

```
prisma:query BEGIN
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
prisma:query COMMIT
```

</CmdResult>

</CodeWithResult>

### Create a record and several related records

The following query creates ([`create`](../../../reference/api-reference/prisma-client-reference#create) <span class="api"></span>) a single user and two related posts (nested [`create`](../../../reference/api-reference/prisma-client-reference#create-1) <span class="api"></span>). The example uses the [`include`](../../../reference/api-reference/prisma-client-reference#include) <span class="api"></span> option to include the related posts in the response:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [{ title: 'How to make an omelette' }, { title: 'How to eat an omelette' }],
    },
  },
  include: {
    posts: true, // Include all posts in the returned object
  },
})
```

</Cmd>
<CmdResult>

```js
{
  id: 29,
  name: 'Elsa Prisma',
  email: 'elsa@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 22,
      title: 'How to make an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 23,
      title: 'How to eat an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

</CmdResult>
</CodeWithResult>

For more information about creating related records, see [Working with relations](working-with-relations).

### Create a record and connect it to an existing related record

See [Working with relations](working-with-relations#connect-an-existing-record) for information about connecting related records.

## Read

### Get record by ID or unique identifier

The following queries return a single record ([`findUnique`](../../../reference/api-reference/prisma-client-reference#findunique) <span class="api"></span>) by unique identifier or ID:

```ts
// By unique identifier
const user = await prisma.user.findUnique({
  where: {
    email: 'elsa@prisma.io',
  },
})

// By ID
const user = await prisma.user.findUnique({
  where: {
    id: 99,
  },
})
```

### Get all records

The following [`findMany`](../../../reference/api-reference/prisma-client-reference#findmany) <span class="api"></span> query returns _all_ `User` records:

```ts
const user = await prisma.user.findMany()
```

You can also [paginate your results](pagination).

### Get the first record that matches a specific criteria

The following [`findFirst`](../../../reference/api-reference/prisma-client-reference#findfirst) <span class="api"></span> query returns the _most recently created user_ with at least one post that has more than 100 likes:

1. Order users by ascending ID (largest first) - the largest ID is the most recent
2. Return the first user in ascending order with at least one post that has more than 100 likes

```ts
  const findUser = await prisma.user.findFirst({
    where: {
      posts: {
        some: {
          likes: {
            gt: 100
          }
        }
      }
    },
    orderBy: {
      id: "asc"
    }
  })
}
```

### Get a filtered list of records

#### Filter by a single field value

The following query returns all users with an email that ends in `prisma.io`:

```ts
  const users = await prisma.user.findMany({
    where: {
      email: {
        endsWith: "prisma.io"
      }
    },
  }
```

#### Filter by multiple field values

The following query uses a combinations of operators to return users whose name start with `E` _or_ administrators with at least 1 profile view:

```ts
const users = await prisma.user.findMany({
  where: {
    OR: [
      {
        name: {
          startsWith: 'E',
        },
      },
      {
        AND: {
          profileViews: {
            gt: 0,
          },
          role: {
            equals: 'ADMIN',
          },
        },
      },
    ],
  },
})
```

#### Filter by related record field values

The following query returns users with an email that ends with `prisma.io` _and_ have at least _one_ post (`some`) that is not published:

```ts
  const users = await prisma.user.findMany({
    where: {
      email: {
        endsWith: "prisma.io"
      },
      posts: {
        some: {
          published: false
        }
      }
    },
  }
```

See [Working with relations](working-with-relations) for more examples of filtering on related field values.

### Select a subset of fields

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.findUnique({
  where: {
    email: 'emma@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{ email: 'emma@prisma.io', name: "Emma" }
```

</CmdResult>
</CodeWithResult>

For more information about including relations, see [Select fields and include relations](select-and-include).

#### Select a subset of related record fields

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.findUnique({
  where: {
    email: 'emma@prisma.io',
  },
  select: {
    email: true,
    posts: {
      select: {
        likes: true,
      },
    },
  },
})
```

</Cmd>
<CmdResult>

```js
{ email: 'emma@prisma.io', posts: [ { likes: 0 }, { likes: 0 } ] }
```

</CmdResult>
</CodeWithResult>

For more information about including relations, see [Select fields and include relations](select-and-include).

### Select distinct field values

See [Select `distinct`](aggregations#select-distinct) fo information about selecting distinct field values.

### Include related records

The following query returns all `ADMIN` users and includes each user's posts in the result:

<CodeWithResult>
<Cmd>

```ts
const user = await prisma.user.findMany({
  where: {
    role: 'ADMIN',
  },
  include: {
    posts: true,
  },
})
```

</Cmd>
<CmdResult>

```js
{
    "id": 38,
    "name": "Maria",
    "email": "maria@prisma.io",
    "profileViews": 20,
    "role": "ADMIN",
    "coinflips": [
        true,
        false,
        false
    ],
    "posts": []
},
{
    "id": 39,
    "name": "Oni",
    "email": "oni2@prisma.io",
    "profileViews": 20,
    "role": "ADMIN",
    "coinflips": [
        true,
        false,
        false
    ],
    "posts": [
        {
        "id": 25,
        "authorId": 39,
        "title": "My awesome post",
        "published": true,
        "comments": null,
        "views": 0,
        "likes": 0
        }
    ]
}
```

</CmdResult>
</CodeWithResult>

For more information about including relations, see [Select fields and include relations](select-and-include).

#### Include a filtered list of relations

See [Working with relations](#working-with-relations#filter-the-relations-list) to find out how to combine `include` and `where` for a filtered list of relations - for example, only include a user's published posts.


## Update

### Update a single record

The following query uses `update` to find and update a single `User` record by `email`:

<CodeWithResult>
<Cmd>

```ts
const updateUser = await prisma.user.update({
  where: {
    email: 'viola@prisma.io',
  },
  data: {
    name: 'Viola the Magnificent',
  },
})
```

</Cmd>
<CmdResult>

```js
{
   "id": 43,
   "name": "Viola the Magnificent",
   "email": "viola@prisma.io",
   "profileViews": 0,
   "role": "USER",
   "coinflips": [],
}
```

</CmdResult>
</CodeWithResult>

### Update multiple records

The following query uses `updateMany` to update all `User` records that contain `prisma.io`:

<CodeWithResult>
<Cmd>

```ts
const updateUsers = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  data: {
    role: 'ADMIN',
  },
})
```

</Cmd>
<CmdResult>

```js
{
   "count": 19
}
```

</CmdResult>
</CodeWithResult>

### Update _or_ insert records

The following query uses `upsert` to update a `User` record with a specific email address, or create that `User` record if it does not exist:

<CodeWithResult>
<Cmd>

```ts
const upsertUser = await prisma.user.upsert({
  where: {
    email: 'viola@prisma.io',
  },
  update: {
    name: 'Viola the Magnificent',
  },
  create: {
    email: 'viola@prisma.io',
    name: 'Viola the Magnificent',
  },
})
```

</Cmd>
<CmdResult>

```js
{
   "id": 43,
   "name": "Viola the Magnificent",
   "email": "viola@prisma.io",
   "profileViews": 0,
   "role": "ADMIN",
   "coinflips": [],
}
```

</CmdResult>
</CodeWithResult>

### Connect and disconnect related records

Refer to [Working with relations](working-with-relations) for information about disconnecting ([`disconnect`](../../../reference/api-reference/prisma-client-reference#disconnect) <span class="api"></span>) and connecting ([`connect`](../../../reference/api-reference/prisma-client-reference#connect) <span class="api"></span>) related records.

## Delete

### Delete a single record

The following query uses `delete` to delete a single `User` record:

```ts
const deleteOne = await prisma.user.delete({
  where: {
    email: 'bert@prisma.io',
  },
})
```

Attempting to delete a user with one or more posts result in an error, as every `Post` requires an author - see [cascading deletes](#cascading-deletes-deleting-related-records).

### Delete multiple records

The following query uses `deleteMany` to delete all `User` records where `email` contains `prisma.io`:

```ts
const deleteOne = await prisma.user.deleteMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
})
```

Attempting to delete a user with one or more posts result in an error, as every `Post` requires an author - see [cascading deletes](#cascading-deletes-deleting-related-records).

### Cascading deletes (deleting related records)

The following query uses `delete` to delete a single `User` record:

```ts
const deleteOne = await prisma.user.delete({
  where: {
    email: 'bert@prisma.io',
  },
})
```

However, the example schema includes a **required relation** between `Post` and `User`, which means that you cannot delete a user with posts:

```
The change you are trying to make would violate the required relation 'PostToUser' between the `Post` and `User` models.
```

To resolve this error, you can:

- Make the relation optional:

  ```prisma file=schema.prisma
  model Post {
  id         Int        @id @default(autoincrement())
  + author     User?       @relation(fields: [authorId], references: [id])
  + authorId   Int?
  - author     User?       @relation(fields: [authorId], references: [id])
  - authorId   Int?
  }
  ```

- Change the author of the posts to another user:

  ```ts
  const updatePosts =
  ```

- Delete a user and all their posts with two separate queries in a transaction (all queries must succeed):

  ```ts
  const deletePosts = prisma.post.deleteMany({
    where: {
      authorId: 7,
    },
  })

  const deleteUser = prisma.user.delete({
    where: {
      id: 7,
    },
  })

  const transaction = await prisma.$transaction([deletePosts, deleteUser])
  ```

## Advanced query examples

### Create a deeply nested tree of records

- A single `User`
- Two new, related `Post` records
- Connect or create `Category` per post

```ts
const u = await prisma.user.create({
  include: {
    posts: {
      include: {
        categories: true,
      },
    },
  },
  data: {
    email: 'emma@prisma.io',
    posts: {
      create: [
        {
          title: 'My first post',
          categories: {
            connectOrCreate: [
              {
                create: { name: 'Introductions' },
                where: {
                  name: 'Introductions',
                },
              },
              {
                create: { name: 'Social' },
                where: {
                  name: 'Social',
                },
              },
            ],
          },
        },
        {
          title: 'How to make cookies',
          categories: {
            connectOrCreate: [
              {
                create: { name: 'Social' },
                where: {
                  name: 'Social',
                },
              },
              {
                create: { name: 'Cooking' },
                where: {
                  name: 'Cooking',
                },
              },
            ],
          },
        },
      ],
    },
  },
})
```
