---
title: 'Relations'
metaTitle: ''
metaDescription: ''
---

## Overview

This is an extension of the [Data model]() page which describes how to handle relations between Prisma models in the Prisma schema.

Relations between models are represented via foreign keys in the underlying database. However, as opposed to how relations are modeled in SQL, **Prisma always requires explicit relation fields on _both_ sides of the relation to be set on your Prisma models**. This means that one of these relation fields represents the foreign key in the underlying database, the other relation field is a [virtual relation field]() (in the case of [implicit many-to-many relations]()), both relation fields are virtual.

## Example

The examples on this page are based on the following schema file:

```prima
datasource postgresql {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
  profile   Profile?
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}

model Post {
  id         Int        @id @default(autoincrement())
  author     User
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

> **Note**. This schema is the same as the [example data model](./data-modeling.md/#example) but has all [scalar fields](./data-modeling.md/#scalar-types) removed so you can focus on the relation fields.

## Terminology

### Cardinality

There are three different [cardinalities](<https://en.wikipedia.org/wiki/Cardinality_(data_modeling)>) of relations in Prisma:

- One-to-one (also called 1-1-relation)
- One-to-many (also called 1-n-relation)
- Many-to-many (also called m-n-relation)

In the example above, there are the following relations:

- 1-1: `User` ↔ `Profile`
- 1-n: `User` ↔ `Post`
- m-n: `Post` ↔ `Category`

### Relation fields

Relation fields are fields on a Prisma [model]() that do _not_ have a [scalar type](). Instead, their type is another model. Consider these two models:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id         Int        @id @default(autoincrement())
  title      String
  author     User
}
```

These models have the following fields:

| Model  | Field    | Type     | Relation field        |
| :----- | :------- | :------- | :-------------------- |
| `User` | `id`     | `Int`    | No                    |
|        | `email`  | `String` | No                    |
|        | `role`   | `Role`   | No                    |
|        | `posts`  | `Post[]` | **Yes** (virtual)     |
| `Post` | `id`     | `Int`    | No                    |
|        | `title`  | `String` | No                    |
|        | `author` | `User`   | **Yes** (foreign key) |

Both `posts` and `author` are relation fields because their types are not scalar types but other models.

Note that a relation field is always either backed by a foreign key in the underlying database or it is [virtual]() (which means that it's not "visible" in the schema of the underlying database).

### Implicit vs explicit many-to-many relations

Many-to-many relations can be either implicit or explicit in the Prisma schema.

#### Explicit many-to-many relations

Explicit many-to-many relations define an extra model which represents a _relation table_ (also sometimes called _JOIN_, _link_ or _pivot_ table) in the underlying database:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model CategoriesOnPosts {
  post     Post
  category Category

  @@id([post, category])
}
```

#### Implicit many-to-many relations

Implicit many-to-many relations define relation fields as lists on both sides of the relation:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

Note that this m-n-relation is still manifested in a relation table in the underlying database. However, this relation table is managed by Prisma which makes the [Prisma Client API]() for many-to-many relations a bit simpler (since you e.g. have one fewer level of nesting inside of [nested writes]()).

If you're not using Prisma Migrate but obtain your data model from [introspection](), you can still make use of implicit many-to-many relations by following Prisma's [conventions for relation tables]().

### Relation tables

A relation table (also sometimes called _JOIN_, _link_ or _pivot_ table) connects two or more other tables and therefore creates a _relation_ between them. Creating relation tables is a common data modeling practice in SQL to represent relationships between different entities.

When using Prisma, you can create relation tables by defining [models]() similar to how you would model them as tables. The main difference is that the fields of the relation table are both relation fields that are backed by foreign keys (neither of them is virtual).

Another use case for relation tables is to add "meta-information" to a relation. For example, _when_ the relation was created.

Here is an example for a relation table called `CategoriesOnPosts`:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model CategoriesOnPosts {
  post      Post
  category  Category
  createdAt DateTime @default(now())

  @@id([post, category])
}
```

In this example, the `createdAt` field stores additional information about the relation between `Post` and `Category` (i.e. it stores the point in time when "the post was added to the catgegory").

When you don't need to attach additional information to the relation, you can model m-n-relations as [implicit many-to-many relations](#implicit-many-to-many-relations). If you're not using Prisma Migrate but get your data model from introspection, you can s

### Foreign key relation field

Foreign key relation fields are relation fields that are backed by a foreign key in the underlying database. For

### Virtual relation fields

Virtual relation fields are relation fields in the Prisma schema that are not "manifested" in the database schema.

There are two different kinds of virtual relation fields.

For **1-1 and 1-n relations**, pne side of the relation represents a foreign key, the other side is a virtual relation field:

![](https://imgur.com/kOO4eh2.png)

For **implicit m-n-relations**, both relation fields are virtual since neither of them directly maps to a foreign key:

![](https://imgur.com/01pxhWM.png)

Prisma always requires both sides of a relation to be present, this means that one virtual relation field always needs to be added per relation. When [formatting the Prisma schema](), the formatter automatically inserts any missing virtual relation fields for you to save some typing work.

Virtual relation fields are also present in the generated [Prisma Client API]() which makes working with relations more convenient as you can traverse relationships in your code in both directions, for example:

```js
// Traverse relation from `Post` to `User` via fluent API
const user = await prisma.post
  .findOne({ where: { id: 1 } })
  .author()

// Traverse relation from `User` to `Post` via fluent API
const user = await prisma.user
  .findOne({ where: { id: 1 } })
  .posts()
```

## The @relation attribute

The `@relation` attribute can only be applied to the [relation fields]() of a Prisma model, not to its [scalar fields](). In most cases the `@relation` attribute is optional, but it can be required, e.g. when:

- you need to disambiguate a relation (that's e.g. the case when you have two relations between the same models)
- you define a [self-relation](#self-relations)
- you need to determine on which side of the relation a foreign key should be used
- you need to control how the relation table is represented in the underlying database (e.g. use a specific name for a relation table)

### Signature

```
@relation(_ name: String?, references: FieldReference[]?)
```

> **Note**: The leading underscore in the signature means that the argument name can be omitted.

| Argument     | Type               | Required | Description                                                                                                             | Example                             |
| :----------- | :----------------- | :------- | :---------------------------------------------------------------------------------------------------------------------- | :---------------------------------- |
| `name`       | `String`           | No       | Defines the name of the relationship. In an m-n-relation, it also determines the name of the underlying relation table. | `"CategoryOnPost"`, `"MyRelation"`  |
| `references` | `FieldReference[]` | No       | A list of [fields]()                                                                                                    | `["id"]`, `["firstName, lastName"]` |

### Cases when the @relation attribute is required

TBD

## One-to-one relations

One-to-one (1-1) relations refer to relations where at most one record can be connected on both sides of the relation.

### Example

In the example above, there's one 1-1-relation betwen `User` and `Profile`:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

This 1-1-relation expresses the following:

- "a user can have zero or one profiles" (because the `profile` field is [optional]() on `User`)
- "a profile must always be connected to one user"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "user" integer NOT NULL UNIQUE,
    FOREIGN KEY ("user") REFERENCES "User"(id)
);
```

Notice the `UNIQUE` constraint on the foreign key `user`. If this `UNIQUE` constrain was missing, the relation would be considered a 1-n relation.

### Making both sides required in one-to-one relations

When using Prisma, you can "augment" a 1-1-relation and make it required on _both_ sides:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  profile   Profile
}

model Profile {
  id   Int    @id @default(autoincrement())
  bio  String
  user User
}
```

This 1-1-relation now expresses the following:

- "a user must always have one profile" (because the `profile` field is [required]() on `User`)
- "a profile must always be connected to one user"

Making the `profile` field on `User` required does not impact the schema in the underlying database since relational databases are not able to model such a constraint. This constraint is implemented and enforced by Prisma's [query engine]().

> **Note**: One-to-one [self-relations](#self-relations) must not be made required on both sides, at least one side always must be declared optional.

It's important to note that in the case of required 1-1-relations, the only way to create a new record for either `User` or `Profile` is by using [nested writes]():

```ts
const user = await prisma.user.create({
  data: {
    name: "Alice"
    create: {
      profile: {
        bio: "Hello World"
      }
    }
  }
})

// or

const user = await prisma.profile.create({
  data: {
    bio: "I like turtles"
    create: {
      user: {
        name: "Bob"
      }
    }
  }
})
```

If you're using [introspection](), you can make 1-1-relations required by manually adjusting your [Prisma schema]() and making both relation fields required, then you can [re-generate Prisma Client]() which will now make sure that the required 1-1-relation is enforced by the query engine.

### Determining the side of the foreign key

Consider again the above 1-1-relation between `User` and `Profile` where `profile` is optional on `User`:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

When using [Prisma Migrate](), this will create the foreign key on the `user` column of the `Profile` table in the underlying database. This is the only possible option because the `profile` relation field on `User` is actually [virtual](), so it can't be used as a foreign key.

This is what the relation looks like in the database:

![](https://imgur.com/N5wHT6D.png)

If both of the relation fields in the relation would be either required or optional, Prisma Migrate assigns the foreign key to the table that comes first in the alphabet.

**Both relation fields required**

```prisma
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

**Both relation fields optional**

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User?
}
```

In both cases, the foreign key is being added to the `Profile` table because its name comes in the alphabet before `User`:

![](https://imgur.com/N5wHT6D.png)

However, in these cases you can still determine yourself on which side of the relation the foreign key should be stored by using the `@relation` attribute. To store the foreign key on `User` you need to add the `@relation` attribute to its relation field as follows:

**Both relation fields required but using `@relation` to determine the foreign key**

```prisma
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile  @relation(references: [id]) // references `id` of `Profile`
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

**Both relation fields optional but using `@relation` to determine the foreign key\***

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?  @relation(references: [id]) // references `id` of `Profile`
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User?
}
```

In both cases, the foreign key is now defined on the `profile` column of the `User` table:

![](https://imgur.com/NAd72ql.png)

To summarize, these are the rules for determining which side of a 1-1-relation holds the foreign key:

- If **one relation field is optional and the other one is required**, the required one holds the foreign key (as the other is [virtual]()).
- If **both relation fields are optional**, the one that comes first in the alphabet holds the foreign key. Note that this can be configured differently via the `@relation` attribute.
- If **both relation fields are required**, the one that comes first in the alphabet holds the foreign key. Note that this can be configured differently via the `@relation` attribute.

Here's the summary in the form of a table assuming the two relation fields of the models from before `Profile.user` and `User.profile`:

| `Prrofile.user` | `User.profile` | Foreign key on                                               | `@relation` attribute                             |
| :------------------------ | :------------------------ | ------------------------------------------------------------ | ------------------------------------------------- |
| Required                  | Optional                  | `Profile` (because the relation field on `User` is virtual) | Can't be used to determine the foreign key        |
| Optional                  | Required                  | `User` (because the relation field on `Profile` is virtual) | Can't be used to determine the foreign key        |
| Optional                  | Optional                  | `Profile` (because it's first in the alphabet)                | Can be used to manually determine the foreign key |
| Required                  | Required                  | `Profile` (because it's first in the alphabet)                | Can be used to manually determine the foreign key |

## One-to-many

One-to-many (1-n) relations refer to relations where one record on one side of the relation can be connected to zero or more records on the other side.

### One-to-one vs one-to-many relations

In relational databases, the main difference between a 1-1 and a 1-n-relation is that in a 1-1-relation the foreign key must have a `UNIQUE` constraint defined on it.

### Example

In the example above, there's one 1-n-relation betwen `User` and `Post`:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id         Int        @id @default(autoincrement())
  author     User
}
```

Notice that the `posts` field on `User` is [virtual](), meaning that it's not manifested in the underlying database schema.

This 1-n-relation expresses the following:

- "a user can have zero or more posts"
- "a post must always have an author"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    author integer NOT NULL,
    FOREIGN KEY (author) REFERENCES "User"(id)
);
```

Since there's no `UNIQUE` constraint on the `author` column (foreign key), you can create multiple `Post` records that point to the same `User` record therefore creating a one-to-many relationship between the two tables.

### Required vs optional relation fields in one-to-many relations

A 1-n-relation always has one [virtual relation field]() (which must be a [list]()) and a [foreign key relation field](). In the example above, `posts Post[]` on the `User` model is virtual, `author User` holds a foreign key.

The relation fields in a relation can take the following forms:

- the foreign key relation field can be either optional or required
- the virtual relation field must be a list and is always required

So, the following variant of the example above would be _allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id         Int    @id @default(autoincrement())
  author     User?  // make `author` optional
}
```

But this one would be _not allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]?  // illegal
}

model Post {
  id         Int   @id @default(autoincrement())
  author     User
}
```

## Many-to-many

Many-to-many (m-n) relations refer to relations where zero or more records on one side of the relation can be connected to zero or more records on the other side. m-n-relations are typically modelled via [relation tables]() in a relational database. m-n-relations can be either [explicit]() or [implicit]() in the Prisma schema.

### Example

In the example above, there's one _implicit_ m-n-relation betwen `Post` and `Category`:

```prisma
model Post {
  id         Int        @id @default(autoincrement())
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

Notice that the `posts` field on `Category` and the `categories` field on `Post` both are [virtual](), meaning that they're not manifested in the underlying database schema.

Instead, the implicit many-to-many relation is maintained by Prisma with a [relation table]() that's not reflected in the Prisma schema.

This m-n-relation expresses the following:

- "a post can have zero or more categories"
- "a category can have zero or more posts"

In SQL, this implicit m-n-relation maps to the following tables (following Prisma's [conventions for relation tables]()):

```sql
CREATE TABLE "Category" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY
);
-- Relation table + indexes -------------------------------------------------------
CREATE TABLE "_CategoryToPost" (
    "A" integer NOT NULL REFERENCES "Category"(id),
    "B" integer NOT NULL REFERENCES "Post"(id)
);
CREATE UNIQUE INDEX "_CategoryToPost_AB_unique" ON "_CategoryToPost"("A" int4_ops,"B" int4_ops);
CREATE INDEX "_CategoryToPost_B_index" ON "_CategoryToPost"("B" int4_ops);
```

![](https://imgur.com/DQClFIX.png)

An _explicit_ variant of a similar m-n-relation would define an extra model to represent a relation table. In this case, you can also attach additional information to the relation (such as the point in time when it was created):

```prisma
model Category {
  id             Int              @default(autoincrement()) @id
  categoryToPost CategoryToPost[]
}

model Post {
  id             Int              @default(autoincrement()) @id
  categoryToPost CategoryToPost[]
}

model CategoryToPost {
  category  Category
  post      Post
  createdAt DateTime @default(now())

  @@unique([category, post], name: "CategoryToPost_category_post_unique")
}
```

This would be represented as follows in SQL:

```sql
CREATE TABLE "Category" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY
);
-- Relation table + indexes -------------------------------------------------------
CREATE TABLE "CategoryToPost" (
    "category" integer NOT NULL,
    "post" integer NOT NULL,
    "createdAt" timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY ("category")  REFERENCES "Category"(id),
    FOREIGN KEY ("post") REFERENCES "Post"(id)
);
CREATE UNIQUE INDEX "CategoryToPost_category_post_unique" ON "CategoryToPost"("category" int4_ops,"post" int4_ops);
```

![](https://imgur.com/JQ22x60.png)

### Conventions for relation tables in implicit m-n-relations

If you're not using Prisma Migrate but obtain your data model from [introspection](), you can still make use of implicit many-to-many relations by following Prisma's conventions for relation tables. For the folowing example, assume you want to create a relation table to get an implicit many-to-many relation for two models called `Post` and `Category`.

#### Table name

The name of the relation table must be prefixed with an underscore:

- **Valid**: `_CategoryToPost`, `_MyRelation`
- **Invalid**: ``CategoryToPost`, `MyRelation`

#### Columns

A relation table for an implicit-many-to-many relation must have exactly two columns:

- A foreign key column that points to `Category` called `A`
- A foreign key column that points to `Post` called `B`

The columns must be called `A` and `B` where `A` points to the model that comes first in the alphabet and `B` points to the column which comes last in the alphabet.

#### Unique index

There further must be a unique index defined on both foreign key columns:

```sql
CREATE UNIQUE INDEX "_CategoryToPost_AB_unique" ON "_CategoryToPost"("A" int4_ops,"B" int4_ops);
```

#### Example

This the a sample SQL statement that would create the three tables including indexes (in PostgreSQL dialect):

```sql
CREATE TABLE "_CategoryToPost" (
    "A" integer NOT NULL REFERENCES "Category"(id) ,
    "B" integer NOT NULL REFERENCES "Post"(id)
);
CREATE INDEX "_CategoryToPost_B_index" ON "_CategoryToPost"("B" int4_ops);
CREATE TABLE "Category" (
    id integer DEFAULT nextval('"Category_id_seq"'::regclass) PRIMARY KEY
);
CREATE UNIQUE INDEX "Category_pkey" ON "Category"(id int4_ops);
CREATE TABLE "Post" (
    id integer DEFAULT nextval('"Post_id_seq"'::regclass) PRIMARY KEY
);
CREATE UNIQUE INDEX "Post_pkey" ON "Post"(id int4_ops);
```

### Configuring the name of the relation table in implicit many-to-many relations

When using Prisma Migrate, you can configure the name of the relation table that's managed by Prisma using the `@relation` attribute. The only requirement is that it starts with an underscore. For example, if you want the relation table to be called `_MyRelationTable` instead of the default name `_CategoryToPost`, you can specify it as follows:

```prisma
model Post {
  id         Int         @id @default(autoincrement())
  categories Category[]  @relation("MyRelationTable")
}

model Category {
  id    Int     @id @default(autoincrement())
  posts Post[]  @relation("MyRelationTable")
}
```

## Self-relations

A relation field can also reference its own model, in this case the relation is called a _self-relation_. Self-relations can be of any cardinality, 1-1, 1-n and m-n.

Note that self-relations always require the `@relation` attribute.

### One-to-one self-relations

A one-to-one self-relation looks as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  husband     User?    @relation("MarriagePartners")
  wife        User     @relation("MarriagePartners")
}
```

This relation expresses the following:

- "a user has zero or one _husband_ "
- "a user can have zero or one _wife_"

Note that one-to-one self-relations can not be made required on both sides, one field has to be optional.

In this case, the `wife` relation field is [virtual](). The `husband` field on the other hand is backed by a foreign key in the underlying database. This is implicitly determined by Prisma based on alphabetical order (`husband` comes before `wife` in the alphabet). You can adjust this by [setting the foreign key]() using the `@relation` attribute:

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  husband  User?    @relation("MarriagePartners")
  wife     User     @relation("MarriagePartners", references: [id]) 
}
```

Now the foreign key is stored on `wide` and `husband` is virtual.

### One-to-many self relations

A one-to-many self-relation looks as follows:

```prisma
model User {
  id       Int      @id @default(autoincrement())
  name     String?
  teacher  User?    @relation("TeacherStudents")
  students User[]   @relation("TeacherStudents") 
}
```

This relation expresses the following:

- "a user has zero or one _teachers_ "
- "a user can have zero or more _students_"

Note that you can also require each user to have a teacher by making the `teacher` field [required]().

### Many-to-many self relations

A many-to-many self-relation looks as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  followedBy  User[]   @relation("UserFollows")
  following   User[]   @relation("UserFollows")
}
```

This relation expresses the following:

- "a user can be followed by zero or more users"
- "a user can follow zero or more users"

### Defining multiple self-relations on the same model

You can also define multiple self-relations on the same model at once. Taking all relations from the previous sections as example, you could define a `User` model as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  husband     User?    @relation("MarriagePartners")
  wife        User     @relation("MarriagePartners")
  teacher     User?    @relation("TeacherStudents")
  students    User[]   @relation("TeacherStudents") 
  followedBy  User[]   @relation("UserFollows")
  following   User[]   @relation("UserFollows")
}
```

## Disambiguating relations

When you define two relations between two the same models, you need to add the `@relation` attribute to disambiguate them. As an example for why that's needed, consider the following models:

```prisma
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]
  pinnedPost   Post?
}

model Post {
  id       Int     @id @default(autoincrement())
  title    String?
  author   User
  pinnedBy User?
}
```

In that case, the relations are ambiguous, there are four different ways to interpet them:

- `User.writtenPosts` ↔ `Post.author`
- `User.writtenPosts` ↔ `Post.pinnedBy`
- `User.pinnedPost` ↔ `Post.author`
- `User.pinnedPost` ↔ `Post.pinnedBy`

To disambiguate these relations, you need to annotate the relation fields with the `@relation` attribute and provide the `name` argument. You can set any `name` (except for the empty string `""`), but it must match on both sides of the relation:

```prisma
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]  @relation("WrittenPosts")
  pinnedPost   Post?   @relation("PinnedPost")
}

model Post {
  id       Int     @id @default(autoincrement())
  title    String?
  author   User    @relation("WrittenPosts")
  pinnedBy User?   @relation("PinnedPost")
}
```