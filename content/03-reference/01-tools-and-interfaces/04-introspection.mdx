---
title: 'Introspection'
metaTitle: ''
metaDescription: ''
---

## Overview

You can introspect your database using the Prisma CLI in order to generate the [data model]() in your [Prisma schema](). The data model is needed to [generate Prisma Client]().

Introspection is often used to generate an _initial_ version of the data model when [adding Prisma to an existing project]().

However, it can also be used _repeatedly_ in an application. This is most commonly the case when you're _not_ using [Prisma Migrate]() but perform schema migrations using plain SQL or another migration tool. In that case, you also need to re-introspect your database and subsequently re-generate Prisma Client to reflect the schema changes in your [Prisma Client API]().

## What does introspection do?

Introspection has one main goal: Populate your Prisma schema with a data model that reflects the current database schema.

![](https://imgur.com/EYC3RIK.png)

Here's an overview of its main functions:

- Map _tables_ in the database to [Prisma models]()
- Map _columns_ in the database to the [fields]() of Prisma models
- Map _indexes_ in the database to [indexes]() in the Prisma schema
- Map _database_ constraints to [attributes]() or [type modifiers]() in the Prisma schema

You can learn more about how Prisma maps types from the database to the types available in the Prisma schema on the respective docs page for the data source connector:

- [PostgreSQL]()
- [MySQL]()
- [SQLite]()

## The `prisma introspect` command

You can introspect your database using the `prisma introspect` command of the [Prisma CLI](). Note that using this command requires your [connection URL]() to be set in your Prisma schema!

> **Warning**: The `prisma introspect` command overwrites the current version of your Prisma schema! If you made any manual adjustments to the Prisma schema (e.g. by adding [comments](), [making a 1-1-relation required on both sides]() or [configuring your Prisma Client API]()), be sure to back up your schema before running the command!

Here's a high-level overview of the steps that `prisma introspect` performs internally:

1. Read the [connection URL]() from the `datasource` configuration in the Prisma schema
1. Open database connection
1. Introspect database schema (i.e. read tables, columns and other structures ...)
1. Transform database schema into Prisma data model
1. Write data model into Prisma schema

## Introspection workflow

The typical workflow for projects that are not using Prisma Migrate, but instead use plain SQL or another migration tool looks as follows:

1. Change the database schema (e.g. using plain SQL)
1. Run `prisma introspect` to update the Prisma schema
1. Run `prisma generate` to update Prisma Client
1. Use the updated Prisma Client in your application

Note that as you evolve the application, this process can be repeated for an indefinite number of times.

![](https://imgur.com/8Tp9jRL.png)

## Rules and conventions

Prisma employs a number of conventions for translating a database schema into a Prisma data model:

### Model, field and enum names

Field, model and enum names (identifiers) must start with a letter and generally must only contain underscores, letters and digits. You can find the naming rules and conventions for each of these identifiers on the respective docs page:

- [Naming models]()
- [Naming fields]()
- [Naming enums]()

The general rule for identifiers is that they need to adhere to this regular expression:

```
[A-Za-z][A-Za-z0-9_]*
```

**Invalid characters** are being sanitized during introspection:

- If they appear _before_ a letter in an identifier, they get dropped.
- If they appear _after_ the first letter, they get replaced by an underscorce.

Additionally, the transformed name is mapped to the database using `@map` or `@@map` to retain the original name.

Consider the following table as an example:

```sql
CREATE TABLE "42User" (
  _id SERIAL PRIMARY KEY,
  _name VARCHAR(255),
  two$two INTEGER
);
```

Because the leading `42` in the table name as well as the leading underscores and the `$` on the columns are forbidden in Prisma, introspection adds the `@map` and `@@map` attributes so that these names adhere to Prisma's naming conventions:

```prisma
model User {
  id      Int     @default(autoincrement()) @id @map("_id")
  name    String? @map("_name")
  two_two Int?    @map("two$two")

  @@map("42User")
}
```

If sanitization results in duplicate identifiers, no immediate error handling is in place. You get the error later and can manually fix it. Consider the case of the following two tables:

```sql
CREATE TABLE "42User" (
  _id SERIAL PRIMARY KEY
);

CREATE TABLE "24User" (
  _id SERIAL PRIMARY KEY
);
```

This would result in the following introspection result:

```prisma
model User {
  id      Int     @default(autoincrement()) @id @map("_id")

  @@map("42User")
}

model User {
  id      Int     @default(autoincrement()) @id @map("_id")

  @@map("24User")
}
```

In this case, you must manually change the name of one of the two generated `User` models because duplicate model names are not allowed in the Prisma schema.

### Relations

Prisma translates foreign keys that are defined on your database tables into [relations]().

#### One-to-one relations

Prisma adds a [one-to-one]() relation to your data model when the foreign key on a table has a `UNIQUE` constraint, e.g.:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "user" integer NOT NULL UNIQUE,
    FOREIGN KEY ("user") REFERENCES "User"(id)
);
```

Prisma translates this into the following data model:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

Note that you can still [make both sides of the relation required]() by manually removing the `?` on `User.profile`:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User
}
```

The required constraint will be enforced by Prisma Client.

#### One-to-many relations

By default, Prisma adds a [one-to-many]() relation to your data model for a foreign key it finds in your database schema:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "author" integer NOT NULL,
    FOREIGN KEY ("author") REFERENCES "User"(id)
);
```

These tables are transformed into the following models:

```prisma
model Post {
  id     Int  @default(autoincrement()) @id
  author User @relation(references: [id])
}

model User {
  id   Int    @default(autoincrement()) @id
  Post Post[]
}
```

#### Many-to-many relations

Many-to-many relations are commonly represented as [relation tables]() in relational databases.

Prisma supports two ways for defining many-to-many relations in the Prisma schema:

- [Implicit many-to-many relations]() (Prisma manages the relation table under the hood)
- [Explicit many-to-many relations]() (the relation table is present as a [model]())

_Implicit_ many-to-many relations are recognized if they adhere to Prisma's [conventions for relation tables](). Otherwise the relation table is rendered in the Prisma schema as a model (therefore making it an _explicit_ many-to-many relation).

This topic is covered extensively on the docs page about [relations]().

#### Disambiguating relations

Prisma generally omits the `name` argument on the [`@relation`]() attribute if it's not needed. Consider the `User` â†” `Post` example from the previous section. The `@relation` attribute only has the `references` argument, `name` is omitted because it's not needed in this case:

```prisma
model Post {
  id     Int  @default(autoincrement()) @id
  author User @relation(references: [id])
}
```

It would be needed if there were _two_ foreign keys defined on the `Post` table:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "author" integer NOT NULL,
    "favoritedBy" INTEGER,
    FOREIGN KEY ("author") REFERENCES "User"(id),
    FOREIGN KEY ("favoritedBy") REFERENCES "User"(id)
);
```

In this case, Prisma needs to [disambiguate the relation]() using a dedicated relation name:

```prisma
model Post {
  id          Int   @default(autoincrement()) @id
  author      User  @relation("Post_authorToUser", references: [id])
  favoritedBy User? @relation("Post_favoritedByToUser", references: [id])
}

model User {
  id                          Int    @default(autoincrement()) @id
  Post_Post_authorToUser      Post[] @relation("Post_authorToUser")
  Post_Post_favoritedByToUser Post[] @relation("Post_favoritedByToUser")
}
```

Note that you can [rename the virtual relation field]() to anything you like so that it looks friendlier in the generated Prisma Client API.

## Introspecting only a subset of your database schema

Introspecting only a subset of your database schema is [not yet officially supported](https://github.com/prisma/prisma2/issues/807) by Prisma.

However, you can achieve this by creating a new database user that only has access to the tables which you'd like to see represented in your Prisma schema, and then perform the introspection using that user. The introspection will then only include the tables the new user has access to.

If your goal is to exclude certain models from the [Prisma Client generation](), you can also manually delete the models that should be excluded from your Prisma schema. Note however that they will be added again when you run `prisma introspect`.
