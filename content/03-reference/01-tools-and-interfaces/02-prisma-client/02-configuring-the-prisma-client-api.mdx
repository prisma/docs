---
title: "Configuring the Prisma Client API"
metaTitle: ""
metaDescription: ""
---

## Overview

The Prisma Client API is generated based on the models in your [Prisma schema](). Models are _typically_ 1:1 mappings of your database tables.

In some cases, especially when using [introspection](), it might be useful to _decouple_ the naming of database tables and columns from the names that are used in your Prisma Client API. This can be done via the `@map` and `@@map` attributes in your Prisma schema.

## Example

Assume you have a database schema looking similar to this:

```sql
CREATE TABLE users (
	user_id SERIAL PRIMARY KEY NOT NULL,
	name VARCHAR(256),
	email VARCHAR(256) UNIQUE NOT NULL
);
CREATE TABLE posts (
	post_id SERIAL PRIMARY KEY NOT NULL,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	title VARCHAR(256) NOT NULL,
	content TEXT,
	author_id INTEGER REFERENCES users(user_id) 
);
CREATE TABLE profiles (
	profile_id SERIAL PRIMARY KEY NOT NULL,
	bio TEXT,
	user_id INTEGER NOT NULL UNIQUE REFERENCES users(user_id) 
);
CREATE TABLE categories (
	category_id SERIAL PRIMARY KEY NOT NULL,
	name VARCHAR(256)
);
CREATE TABLE post_in_categories (
	post_id INTEGER NOT NULL REFERENCES posts(post_id),
	category_id INTEGER NOT NULL REFERENCES categories(category_id)
);
CREATE UNIQUE INDEX post_id_category_id_unique ON post_in_categories(post_id int4_ops,category_id int4_ops);
```

When introspecting a database with that schema, you'll get a Prisma schema looking similar to this:

```prisma
model categories {
  category_id        Int                  @default(autoincrement()) @id
  name               String?
  post_in_categories post_in_categories[]
}

model post_in_categories {
  category_id categories
  post_id     posts

  @@unique([post_id, category_id], name: "post_id_category_id_unique")
}

model posts {
  content            String?
  created_at         DateTime?
  post_id            Int                  @default(autoincrement()) @id
  title              String
  author_id          users?
  post_in_categories post_in_categories[]
}

model profiles {
  bio        String?
  profile_id Int     @default(autoincrement()) @id
  user_id    users
}

model users {
  email    String    @unique
  name     String?
  user_id  Int       @default(autoincrement()) @id
  posts    posts[]
  profiles profiles?
}
```

The are a few "issues" with this Prisma schema when the Prisma Client API is generated:

**Adhering to Prisma's naming conventions**

Prisma has a [naming convention]() of **camelCasing** and using the **singular form** for Prisma models. If these naming conventions are not met, the Prisma schema can become harder to interpret. Consider the following, generated model:

```prisma
model users {
  user_id  Int        @default(autoincrement()) @id
  posts    posts[]
  profiles profiles?
}
```

Although `profiles` refers to a 1:1 relation, its type is currently called `profiles` in plural, suggesting that there might be many `profiles` in this relation. With Prisma conventions, the models and fields were _ideally_ named as follows:

```prisma
model User {
  user_id  Int        @default(autoincrement()) @id
  posts    Post[]
  profile  Profile?
}
```

**Naming of relation fields**

Foreign keys are represented as _relation fields_ in the Prisma schema. Here's how all the relations from the SQL schema are represented:

```prisma
model categories {
  category_id        Int                  @default(autoincrement()) @id
  post_in_categories post_in_categories[]
}

model post_in_categories {
  category_id categories
  post_id     posts

  @@unique([post_id, category_id], name: "post_id_category_id_unique")
}

model posts {
  post_id            Int                  @default(autoincrement()) @id
  author_id          users?
  post_in_categories post_in_categories[]
}

model profiles {
  profile_id Int     @default(autoincrement()) @id
  user_id    users
}

model users {
  user_id  Int       @default(autoincrement()) @id
  posts    posts[]
  profiles profiles?
}
```

In the _database schema_, it makes sense to call the foreign key references after the referenced column, e.g. `post_id`, `user_id`. However, the mental model for relations in the Prisma schema is different. Here, the relation is referencing the _entire_ model, not only it's ID field. Therefore, the naming doesn't seem appropriate.

The current naming of relation fields can also lead to confusion in the Prisma Client API, for example with [nested writes]() or the [fluent API]():

```ts
// Nested writes
const profile = await prisma.profiles.create({
  data: {
    bio: 'Hello World',
    user_id: {
      create: {
        name: 'Alice',
        email: 'alice@prisma.io'
      }
    }
  }
})

// Fluent API
const userByProfile = await prisma.profiles.findOne({
  where: { id: 1 }
}).user_id()
```

In both cases, `user_id` is used to refer to an _entire_ "user object", not only to the `user_id` column. 

## Using `@map` and `@@map` to rename fields and models in the Prisma Client API

You can "rename" fields and models that are used in the Prisma Client by mapping them to the "original" names in the database using the `@map` and `@@map` attributes. For the [example](#example) above, you could e.g. annotate your models as follows to prevent the mentioned issues.

_After_ you introspected your database with `prisma introspect`, you can adjust the resulting Prisma schema as follows:

```prisma
model Category {
  category_id        Int                  @default(autoincrement()) @id
  post_in_categories post_in_categories[]

  @@map(name: "categories")
}

model PostInCategories {
  category Category @map(name: "category_id")
  post     Post @map(name: "post_id")

  @@unique([post, category], name: "post_id_category_id_unique")
  @@map(name: "post_in_categories")
}

model Post {
  post_id            Int                  @default(autoincrement()) @id
  author          User? @map(name: "author_id")
  post_in_categories PostInCategories[]

  @@map(name: "posts")
}

model Profile {
  profile_id Int     @default(autoincrement()) @id
  user_id    User @map(name: "user_id")

  @@map(name: "profiles")
}

model User {
  user_id  Int       @default(autoincrement()) @id
  posts    Post[]
  profiles Profile?

  @@map(name: "users")
}
```

With these changes, you're now adhering to Prisma's naming conventions and the generated Prisma Client API feels more "natural":

```ts
// Nested writess
const profile = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      create: {
        name: 'Alice',
        email: 'alice@prisma.io'
      }
    }
  }
})

// Fluent API
const userByProfile = await prisma.profile.findOne({
  where: { id: 1 }
}).user()
```

> **Warning**: `@map` and `@@map` attributes are removed when you run `prisma introspect` again. You might want to back up your Prisma schema with these attributes in order to not having to annotate everything from scratch again after a re-introspection.