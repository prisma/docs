---
title: 'Aggregations'
metaTitle: 'Aggregations (Reference)'
metaDescription: ''
preview: true
---

<TopBlock>

Prisma Client allows you to perform aggregations operations on the **number** fields (such as `Int` and `Float`) of a model - for example, you can get the average age of all users (based on [the sample model](aggregations#sample-model)):

```ts
const aggregations = await prisma.user.aggregate({
    avg: {
        age: true,
    },
});

console.log("Average age:" + aggregations.avg.age);
```

Prisma Client supports the following aggregations:

* `avg`
* `sum`
* `min`
* `max` 

`count` is already available, and can be used in the following way:

```ts
const userCount = await prisma.user.count();
```

</TopBlock>

## Prerequisites

This is a preview feature. Add the highlighted feature flag to enable distinct querying capabilities:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["aggregateApi"]
}
```

Please help us make this feature production-ready by trying it out, [sharing your feedback](https://github.com/prisma/prisma/issues/2838) and [reporting bugs](../../../more/creating-bug-reports)! The more and better feedback we receive, the earlier the feature can be released for production usage.


## Aggregations, filtering, and ordering

You can combine aggregation with filtering and ordering. For example, the following query returns the average age of users:

* Ordered by `age` ascending
* Where `email` contains `prisma.io`
* Limited to the 10 users

```ts
const aggregations = await prisma.user.aggregate({
avg: {
    age: true,
},
where: {
    email: {
    contains: "prisma.io",
    },
},
orderBy: {
    age: "asc",
},
take: 10,
});

console.log("Average age:" + aggregations.avg.age);
```

## Examples

The following examples are based on a sample schema:

<a  id="sample-model"></a>

<details>
  <summary>Expand sample schema</summary>

```prisma
  generator client {
  provider             = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Post {
  authorId   Int?
  content    String?
  id         Int     @default(autoincrement()) @id
  published  Boolean @default(false)
  title      String
  user       User?   @relation(fields: [authorId], references: [id])
  adEarnings Float? 

  @@index([authorId], name: "authorId")
}

model User {
  email           String  @unique
  id              Int     @default(autoincrement()) @id
  name            String?
  posts           Post[]
  extendedProfile Json?
  role            Role    @default(USER)
  age             Int?
}

enum Role {
  ADMIN
  USER
  MODERATOR
}
```

</details>

### 

## Generated types

The following types relating to aggregation are generated from the `User` model in the <a href="sorting#sample-model">sample schema</a>:


```ts
export type AggregateUser = {
  count: number
  avg: UserAvgAggregateOutputType | null
  sum: UserSumAggregateOutputType | null
  min: UserMinAggregateOutputType | null
  max: UserMaxAggregateOutputType | null
}

export type UserAvgAggregateOutputType = {
  id: number
  age: number
}

export type UserSumAggregateOutputType = {
  id: number
  age: number | null
}

export type UserMinAggregateOutputType = {
  id: number
  age: number | null
}

export type UserMaxAggregateOutputType = {
  id: number
  age: number | null
}


export type UserAvgAggregateInputType = {
  id?: true
  age?: true
}

export type UserSumAggregateInputType = {
  id?: true
  age?: true
}

export type UserMinAggregateInputType = {
  id?: true
  age?: true
}

export type UserMaxAggregateInputType = {
  id?: true
  age?: true
}

export type AggregateUserArgs = {
  where?: UserWhereInput
  orderBy?: UserOrderByInput
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  count?: true
  avg?: UserAvgAggregateInputType
  sum?: UserSumAggregateInputType
  min?: UserMinAggregateInputType
  max?: UserMaxAggregateInputType
}
```