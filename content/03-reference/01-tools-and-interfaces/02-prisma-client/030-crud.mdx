---
title: 'CRUD'
metaTitle: 'CRUD (Reference)'
metaDescription: 'This page provides a detailed reference of the auto-generated CRUD queries that are exposed in the Prisma Client API, such as findOne, findMany, create, ...'
---

<TopBlock>

Prisma Client offers out-of-the-box support for several CRUD queries. CRUD stands for:

- **C**reate
- **R**ead
- **U**pdate
- **D**elete

The following CRUD queries are available in Prisma Client:

- [`findOne`](#findone)
- [`findMany`](#findmany)
- [`create`](#create)
- [`update`](#update)
- [`updateMany`](#updatemany)
- [`upsert`](#upsert)
- [`delete`](#delete)
- [`deleteMany`](#deletemany)
- [`count`](#count)

This page contains a detailed description for each query. Unless otherwise noted, the examples on this page are based on the following Prisma schema:

```prisma
model User {
  id           Int       @id @default(autoincrement())
  name         String?
  email        String    @unique
  profileViews Int       @default(0)
  role         Role      @default(USER)
  coinflips    Boolean[]
  posts        Post[]
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String
  published  Boolean @default(true)
  author     User    @relation(fields:  [authorId], references: [id])
  authorId   Int
  comments   Json
  views      Int     @default(0)
  likes      Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

CRUD queries are exposed by the _model properties_ on your `PrismaClient` instance. Taking the `User` and `Post` models from above as examples, you'd invoke the CRUD queries via the `prisma.user` and `prisma.post` model properties. For example:

```ts
await prisma.user.create({ data: { name: 'Alice' } })
// or
await prisma.post.findMany()
```

</TopBlock>

## `findOne`

The `findOne` query lets you retrieve a single database record by _ID_ or another _unique_ attribute. You can use the `select` and `include` options to determine which properties should be included on the returned object.

### Options

#### Type

`findOne` takes an object with one of the following types as input:

```ts
export type FindOneUserArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

These are further relevant generated types:

```ts
export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}
```

<details><summary>Expand for a multi-field ID/unique example</summary>

In case your model defines a multi-field ID or unique attribute such as the following:

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

The `UserWhereUniqueInput` input type looks slightly different:

```ts
export type UserWhereUniqueInput = {
  firstName_lastName?: FirstNameLastNameCompoundUniqueInput | null
}

export type FirstNameLastNameCompoundUniqueInput = {
  firstName: string
  lastName: string
}
```

</details>

#### Reference

| Name      | Type                   | Required | Description                                                                      |
| --------- | ---------------------- | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput` | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                  |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object. |

### Return type

`findOne` returns a plain old JavaScript object or `null`.

The type of the object that a `findOne` API call returns depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

#### Single-field ID or unique attribute

##### Retrieve the `User` record with an `id` of `42`

```ts
const result = await prisma.user.findOne({
  where: {
    id: 42,
  },
})
```

##### Retrieve the `User` record with an `email` of `alice@prisma.io`

```ts
const result = await prisma.user.findOne({
  where: {
    email: 'alice@prisma.io',
  },
})
```

#### Multi-field ID attribute

Assume your model has a multi-field ID or unique attribute, e.g.:

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith`

```ts
const result = await prisma.user.findOne({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

#### Multi-field unique attribute

Assume your model has a multi-field unique attribute:

```prisma
model User {
  firstName String
  lastName  String

|  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

> **Note**: This example of `@@unique` includes an optional `name`. If you do not specify a name, the field name in the generated client is `firstName_lastName`

##### Retrieve the `User` record with `firstName` of `Alice` and `lastName` of `Smith`

```ts
const result = await prisma.user.findOne({
  where: {
    fullname: { // name property of @@unique attribute
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

## findFirst

The `findFirst` query returns the first record in a list that matches your criteria. `findFirst` accepts the same arguments as `findMany`.

### Options

#### Type

`findFirst` takes as input an object of the following type:

```ts
export type FindFirstUserArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput> | UserOrderByInput
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

These are further relevant generated types:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}

export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}

export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}

export type UserOrderByInput = {
  id?: SortOrder | null
  name?: SortOrder | null
  email?: SortOrder | null
  role?: SortOrder | null
  profileViews?: SortOrder | null
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```
 
#### Reference

| Name      | Type                   | Required | Description                                                                                                 |
| --------- | ---------------------- | -------- | ----------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`       | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                        |
| `orderBy` | `Enumerable<UserOrderByInput>`     | No       | Lets you order the returned list by any property.                                                          |
| `skip`    | `string`               | No       | Specifies how many of the returned objects in the list should be skipped.                                   |
| `cursor`   | `UserWhereUniqueInput` | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value). |
| `take`   | `number`               | No       | Specifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list.  |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                                               |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object.                                  |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`          | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                  |

### Return type

`findFirst` returns a plain old JavaScript object or `null`.

The type of the object returned by the `findFirst` API call depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

#### Retrieve the first `User` record where the `name` is `Alice`

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

See [filtering documentation](filtering#filter-on-related-records) for advanced examples.

#### Retrieve the first `Post` record where the `title` starsts with `A test`, reverse the list with `take`

Providing a negative value for `take` when you use a `findFirst` query reverses the order of the list. Use the following example to experiment - the value of `c` changes depending on whether or not `take` is negative or positive:

```ts file="script.ts"
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({});

async function mainAsync() {
  const a = await prisma.post.create({
    data: {
      title: "A test 1",
    },
  });

  const b = await prisma.post.create({
    data: {
      title: "A test 2",
    },
  });

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: "A test",
      },
    },
    orderBy: {
      title: "asc",
    },
    take: -1,
  });

  console.log(c);
}

mainAsync();
```

## findMany

The `findMany` query returns a list of records. You can use the `select` and `include` options to determine which properties the returned objects should include. You can also paginate, [filter](filtering), and order the list.

### Options

#### Type

`findMany` takes as input an object of the following type:

```ts
export type FindManyUserArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
  where?: UserWhereInput | null
  orderBy?: Enumerable<UserOrderByInput> | null
  cursor?: UserWhereUniqueInput | null
  take?: number | null
  skip?: number | null
  distinct?: Enumerable<UserDistinctFieldEnum>  
}
```

These are further relevant generated types:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}

export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}

export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}

export type UserOrderByInput = {
  id?: SortOrder | null
  name?: SortOrder | null
  email?: SortOrder | null
  role?: SortOrder | null
  profileViews?: SortOrder | null
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```
 
#### Reference

| Name      | Type                   | Required | Description                                                                                                 |
| --------- | ---------------------- | -------- | ----------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`       | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                        |
| `orderBy` | `Enumerable<UserOrderByInput>`     | No       | Lets you order the returned list by any property.                                                           |
| `skip`    | `string`               | No       | Specifies how many of the returned objects in the list should be skipped.                                   |
| `cursor`   | `UserWhereUniqueInput` | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value). |
| `take`   | `number`               | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (+ve value) or _end_ (-ve value) **either** of the list **or** from the `cursor` position if mentioned)  |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                                               |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object.                                  |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`          | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                  |


### Return type

`findMany` returns an array of plain old JavaScript objects.

The type of the objects returned by the `findMany` API call depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

**Retrieve all `User` records where the `name` is `Alice`**:

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

See [filtering documentation](filtering#filter-on-related-records) for advanced examples.

## create

The `create` query creates a new database record. You can use the `select` and `include` options to determine which properties should be included on the returned object.

### Options

#### Type

`create` takes as input an object of the following type:

```ts
export type UserCreateArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
  data: UserCreateInput
}
```

These are further relevant generated types:

```ts
export type UserCreateInput = {
  name?: string | null
  email: string
  role?: Role | null
  profileViews: number
  coinflips?: UserCreatecoinflipsInput | null
  posts?: PostCreateManyWithoutAuthorInput | null
}

export type UserCreatecoinflipsInput = {
  set?: Enumerable<boolean> | null
}

export type PostCreateManyWithoutAuthorInput = {
  create?: Enumerable<PostCreateWithoutAuthorInput> | null
  connect?: Enumerable<PostWhereUniqueInput> | null
}

export type PostCreateWithoutAuthorInput = {
  title: string
  published?: boolean | null
  comments?: object | null
}

export type PostWhereUniqueInput = {
  id?: number | null
}
```

#### Reference

| Name      | Type              | Required | Description                                                                                                                                                                                                                                                                |
| --------- | ----------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `UserCreateInput` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `select`  | `UserSelect`      | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                            |
| `include` | `UserInclude`     | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                            |

### Return type

`create` returns a plain old JavaScript object.

The type of the object that's returned by a `create` API call depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

#### Create a new record with the only required field `email`

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

#### Nested writes

You can also perform nested writes, such as:

* Create a `User` and one or more connected `Post` records at the same time (see [example](relation-queries#create-a-new-user-record-with-two-new-post-records))
* Create a `Post` and connect it to an existing user, or create a new `User` record (see [example](relation-queries#create-a-new-post-record-and-connect-it-to-an-existing-user-record-or-create-a-new-user))

## update

The `update` query updates an existing database record. You can use the `select` and `include` options to determine which properties should be included on the returned object.

To perform arithmeic operations (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

### Options

#### Type

`update` takes as input an object of the following type:

```ts
export type UserUpdateArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
  data: UserUpdateInput
  where: UserWhereUniqueInput
}
```

These are further relevant generated types:

```ts
export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}

export type UserUpdateInput = {
  id?: number | null
  name?: string | null
  email?: string | null
  role?: Role | null
  profileViews?: number | null
  coinflips?: UserUpdatecoinflipsInput | null
  posts?: PostUpdateManyWithoutAuthorInput | null
}

export type UserUpdatecoinflipsInput = {
  set?: Enumerable<boolean> | null
}

export type PostUpdateManyWithoutAuthorInput = {
  create?: Enumerable<PostCreateWithoutAuthorInput> | null
  connect?: Enumerable<PostWhereUniqueInput> | null
  set?: Enumerable<PostWhereUniqueInput> | null
  disconnect?: Enumerable<PostWhereUniqueInput> | null
  delete?: Enumerable<PostWhereUniqueInput> | null
  update?: Enumerable<PostUpdateWithWhereUniqueWithoutAuthorInput> | null
  updateMany?: Enumerable<PostUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<PostScalarWhereInput> | null
  upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutAuthorInput> | null
}
```

#### Reference

| Name      | Type                   | Required | Description                                                                                                                                                                               |
| --------- | ---------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`    | `UserUpdateInput`      | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional. |
| `where`   | `UserWhereUniqueInput` | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                          |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                                                                                                                           |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                          |

### Return type

`update` returns a plain old JavaScript object or throws an exception (`RecordNotFound`).

The type of the object that an `update` API call returns depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

**Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`**:

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

#### Nested writes

You can also perform nested writes during an update, such as:

* Update a `User` and update one or more connected `Post` records at the same time (see [example](relation-queries#update-an-existing-user-record-by-updating-two-post-records-its-connected-to))
* Update a `User` and connect it to one or more existing `Post` records, or add new `Post` records (see [example](relation-queries#update-an-existing-user-record-by-connect-it-to-two-existing-post-records-or-creating-two-new-post-records))

## `upsert`

The `upsert` query updates an existing or creates a new database record. You can use the `select` and `include` options to determine which properties should be included on the returned object.

To perform arithmeic operations (add, subtract, multiply, divide), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

### Options

#### Type

`upsert` takes as input an object of the following type:

```ts
export type UserUpsertArgs = {
  select?: UserSelect | null
  include?: UserInclude | null
  where: UserWhereUniqueInput
  create: UserCreateInput
  update: UserUpdateInput
}
```

Refer to [`findOne`](#findone), [`create`](#create) and [`update`](#update) to see what the generated types `UserWhereUniqueInput`, `UserCreateInput` and `UserUpdateInput` types look like.

#### Reference

| Name      | Type                   | Required | Description                                                                                                                                                                                                                                                                |
| --------- | ---------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`  | `UserCreateInput`      | **Yes**  | Wraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `update`  | `UserUpdateInput`      | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                                                                  |
| `where`   | `UserWhereUniqueInput` | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected.                                                                                                                                                                                           |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                                                                                                                                                                                                            |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object.                                                                                                                                                                                           |

### Return type

`upsert` returns a plain old JavaScript object.

The type of the object that an `upsert` API call returns depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

#### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```


## delete

The `delete` query deletes an existing database record. Even though the record is being deleted, `delete` still returns the object that was deleted. You can use the `select` and `include` options to determine which properties should be included on the returned object.

### Options

#### Type

`delete` takes as input an object of the following type:

```ts
export type FindOneUserArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

These are further relevant generated types:

```ts
export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}
```

<details><summary>Expand for a multi-field ID/unique example</summary>

In case your model has a multi-field ID or unique attribute such as the following:

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

The `UserWhereUniqueInput` input looks slightly different:

```ts
export type UserWhereUniqueInput = {
  firstName_lastName?: FirstNameLastNameCompoundUniqueInput | null
}

export type FirstNameLastNameCompoundUniqueInput = {
  firstName: string
  lastName: string
}
```

</details>

#### Reference

| Name      | Type                   | Required | Description                                                                      |
| --------- | ---------------------- | -------- | -------------------------------------------------------------------------------- |
| `where`   | `UserWhereUniqueInput` | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. |
| `select`  | `UserSelect`           | No       | Specifies which properties to include on the returned object.                  |
| `include` | `UserInclude`          | No       | Specifies which relations should be eagerly loaded on the returned object. |

### Return type

`delete` returns a plain old JavaScript object or throws a `RecordNotFound` exception if the unique identifier does not exist:

```terminal
Error for binding '0': RecordNotFound("Record to delete does not exist.")
```

> **Tip**: If you need to delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

The type of the object that's returned by a `delete` API call depends on whether you use the `select` and `include` options.

If you use neither of these options, the return type will correspond to the TypeScript type that's generated for the model. For the `User` model from above, this type looks as follows:

```ts
export type User = {
  id: number
  name: string | null
  email: string
  role: Role
  coinflips: boolean[]
  profileViews: number
}
```

### Examples

**Delete the `User` record with an `id` of `1`**:

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

## updateMany

The `updateMany` query updates a batch of existing database records in bulk and returns the number of updated records. You can [filter](filtering) the list of records to be updated.

To perform arithmeic operations (add, subtract, multiply), use [atomic updates](#atomic-operations-on-update) to prevent race conditions.

### Options

#### Type

`updateMany` takes as input an object of the following type:

```ts
export type UserUpdateManyArgs = {
  data: UserUpdateManyMutationInput
  where?: UserWhereInput | null
}
```

These are further relevant generated types:

```ts
export type UserUpdateManyMutationInput = {
  id?: number | null
  name?: string | null
  email?: string | null
  role?: Role | null
  profileViews?: number | null
  coinflips?: UserUpdatecoinflipsInput | null
}

export type UserUpdatecoinflipsInput = {
  set?: Enumerable<boolean> | null
}

export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}
```

#### Reference

| Name    | Type                          | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `UserUpdateManyMutationInput` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`              | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                                 |

### Return type

`updateMany` returns an object of type `BatchPayload`, which is defined as follows:

```ts
export type BatchPayload = {
  count: number
}
```

The value of `count` is an integer and represents the number of records that were updated.

### Examples

**Update all `User` records where the `name` is `Alice` to `ALICE`**:

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

## deleteMany

The `deleteMany` query deletes a batch of existing database records in bulk and returns the number of deleted records. You can [filter](filtering) the list of records to be deleted.

### Options

#### Type

`deleteMany` takes as input an object of the following type:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}
```

#### Reference

| Name    | Type             | Required | Description                                                                           |
| ------- | ---------------- | -------- | ------------------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

### Return type

`deleteMany` returns an object of type `BatchPayload`, which is defined as follows:

```ts
export type BatchPayload = {
  count: number
}
```

The value of `count` is an integer and represents the number of records that were deleted.

### Examples

**Delete all `User` records where the `name` is `Alice`**:

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

## `count`

Use the `count()` method on any model property on your `PrismaClient` instance to return a the number of available records. You can [filter](filtering) the list of records to be counted.

### Options

#### Type

`count` an object of the following type as input:

```ts
export type FindManyUserArgs = {
  where?: UserWhereInput | null
  orderBy?: Enumerable<UserOrderByInput> | null
  skip?: number | null
  after?: UserWhereUniqueInput | null
  before?: UserWhereUniqueInput | null
  first?: number | null
  last?: number | null
}
```

These are further relevant generated types:

```ts
export type UserWhereInput = {
  id?: number | IntFilter | null
  name?: string | NullableStringFilter | null
  email?: string | StringFilter | null
  role?: Role | RoleFilter | null
  profileViews?: number | IntFilter | null
  posts?: PostFilter | null
  AND?: Enumerable<UserWhereInput> | null
  OR?: Enumerable<UserWhereInput> | null
  NOT?: Enumerable<UserWhereInput> | null
}

export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}

export type UserWhereUniqueInput = {
  id?: number | null
  email?: string | null
}

export type UserOrderByInput = {
  id?: SortOrder | null
  name?: SortOrder | null
  email?: SortOrder | null
  role?: SortOrder | null
  profileViews?: SortOrder | null
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```

#### Reference

| Name      | Type                   | Required | Description                                                                                                 |
| --------- | ---------------------- | -------- | ----------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`       | No       | Wraps _all_ fields of a model so that the list can be filtered by any model property.                       |
| `orderBy` | `Enumerable<UserOrderByInput>`     | No       | Lets you order the returned list by any model property.                                                     |
| `skip`    | `string`               | No       | Specifies how many of the returned objects in the list should be skipped.                                   |
| `after`   | `UserWhereUniqueInput` | No       | Specifies the starting object for the list (the value typically specifies an `id` or another unique value). |
| `before`  | `UserWhereUniqueInput` | No       | Specifies the last object for the list (the value typically specifies an `id` or another unique value).     |
| `first`   | `number`               | No       | Specifies how many elements should be returned in the list (as seen from the _beginning_ of the list).      |
| `last`    | `number`               | No       | Specifies how many elements should be returned in the list (as seen from the _end_ of the list).            |

### Return type

`count` returns an `number`:

```ts
export type BatchPayload = {
  count: number
}
```

### Examples

Count all `User` records:

```javascript
const result = await prisma.user.count();
```

Count all `User` records with at least one published `Post`:

```javascript
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

## Working with advanced scalar types

### Working with `Json` fields

See [Working with Json](working-with-json).

### Working with scalar lists / scalar arrays

The following example demonstrates how to set the value of a scalar list (`coinflips`) when you create a model:

```ts
const createdUser = await prisma.user.create({
  data: {
    email: "eloise@prisma.io",
    coinflips: [true, true, true, false, true],
  },
});
```

Scalar lists only support setting a value - you cannot add or remove elements, only overwrite the entire value. The following example retrieves user, uses `push()` to add three new coin flips, and overwrites the `coinflips` property in an `update`:

```ts
const user = await prisma.user.findOne({
  where: {
    email: "eloise@prisma.io",
  },
});

if (user) {
  console.log(user.coinflips);

  user.coinflips.push(true, true, false);

  const updatedUser = await prisma.user.update({
    where: {
      email: "eloise@prisma.io",
    },
    data: {
      coinflips: user.coinflips
    },
  });

  console.log(updatedUser.coinflips);
}
```

## Atomic operations on update

Atomic operations on update is available as a preview feature in 2.6.0 and later for `Float` and `Int` field types. This feature allows you to update a field based on its **current** value (such as *subtracting* or *dividing*) without risking a race condition.

<details><summary>Overview: Race conditions</summary>

A race conditions occurs when two or more operations must be done in sequence in order to complete a task. In the following example, two clients try to increase the same field (`postCount`) by one:

| Client | Operation | Value  |
|:--| :----- | :------------------ | :-------- |
|Client 1| **Get** field value     | `21` |
|Client 2| **Get** field value     | `21` |
|Client 2| **Set** field value     | `22` |
|Client 1| **Set** field value     | `22` ✘ |

The value *should* be `23`, but the two clients did not read and write to the `postCount` field in sequence. Atomic operations on update combine read and write into a single operation, which prevents a race condition:

| Client | Operation | Value  |
|:--| :----- | :------------------ | :-------- |
|Client 1| **Get and set** field value     | `21` &rarr; `22` |
|Client 2| **Get and set** field value     | `22` &rarr; `23` ✔ |

</details>

Add the highlighted feature flag to enable atomic number operations on update:

```prisma
generator client {
  provider = "prisma-client-js"
|  previewFeatures = ["atomicNumberOperations"]
}
```

> Please [share your feedback](https://github.com/prisma/prisma/issues/3491) on how this feature works for you. We are interested in both positive and negative feedback, so we know if this feature is already ready for production! (If encounter any problems, please open a [new issue in the `prisma/prisma` repository](https://github.com/prisma/prisma/issues/new/choose)).

### Reference

| Option | Description           
| :----- | :------------------ | 
| `increment`    | Adds `n` to the current value. | 
| `decrement`    | Subtacts `n` from the current value. | 
| `multiply`    | Multiplies the current value by `n`. | 
| `divide`    | Divides the current value by `n`. | 
| `set`    | Sets the current field value. Identical to `{ myField : n }`. | 

> **Note**: You can only perform **one** atomic update per field, per query.

`Int` and `Float` fields accept objects with the following type as input:

```ts
export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

#### Examples

##### Increment all `view` and `likes` fields of all `Post` records by `1`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1
    },
    likes: {
      increment: 1
    }
  }
})
```

##### Set all `count` fields of all `Post` records to `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0
    },
  }
})
```

Can also be written as:

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  }
})
```
